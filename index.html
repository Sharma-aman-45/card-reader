<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Honeyman ExhibitionCardReaderPro.">
    <title>Exhibition Card Reader Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        .background-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
            animation: fadeInDown 1s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 15px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.4);
            font-weight: 700;
            background: linear-gradient(45deg, #fff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.95;
            font-weight: 300;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1.2fr 0.8fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 25px;
            padding: 35px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
        }

        .card h2 {
            color: white;
            margin-bottom: 25px;
            font-size: 1.6rem;
            text-align: center;
            font-weight: 600;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .scanner-section {
            text-align: center;
        }

        .camera-container {
            position: relative;
            max-width: 100%;
            margin: 25px 0;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
            background: #000;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #video {
            width: 100%;
            height: auto;
            max-height: 400px;
            object-fit: cover;
            border-radius: 20px;
        }

        .camera-placeholder {
            color: rgba(255,255,255,0.7);
            font-size: 1.1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .camera-placeholder .icon {
            font-size: 3rem;
            opacity: 0.5;
        }

        #canvas {
            display: none;
        }

        .scanning-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(102, 126, 234, 0.1);
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: 20px;
        }

        .scanning-overlay.active {
            display: flex;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        .scan-line {
            width: 80%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ff00, transparent);
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateY(-100px); }
            100% { transform: translateY(100px); }
        }

        .upload-area {
            border: 3px dashed rgba(255,255,255,0.4);
            border-radius: 20px;
            padding: 40px 20px;
            text-align: center;
            margin: 25px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.05);
            color: white;
        }

        .upload-area:hover {
            border-color: rgba(255,255,255,0.8);
            background: rgba(255,255,255,0.1);
            transform: scale(1.02);
        }

        .upload-area.dragover {
            border-color: #00ff88;
            background: rgba(0,255,136,0.1);
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0,255,136,0.3);
        }

        .upload-area .icon {
            font-size: 2.5rem;
            margin-bottom: 15px;
            opacity: 0.8;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            margin: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .mode-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 0.9rem;
            padding: 8px 16px;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #00c851, #007e33);
            border-color: #00c851;
            box-shadow: 0 4px 15px rgba(0,200,81,0.3);
        }

        .mode-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
        }

        .mode-btn.active:hover {
            background: linear-gradient(135deg, #00d861, #008e43);
            box-shadow: 0 6px 20px rgba(0,200,81,0.4);
        }

        .btn.success {
            background: linear-gradient(135deg, #00c851, #007e33);
        }

        .btn.danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: white;
            font-size: 0.95rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .form-group input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 15px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.1);
            color: white;
            backdrop-filter: blur(10px);
        }

        .form-group input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .form-group input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
            background: rgba(255,255,255,0.15);
        }

        .clients-table {
            grid-column: 1 / -1;
            overflow-x: auto;
            animation: fadeInUp 1s ease-out 0.3s both;
        }

        .table-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .stats {
            background: rgba(255,255,255,0.1);
            padding: 15px 25px;
            border-radius: 15px;
            color: white;
            font-weight: 600;
            backdrop-filter: blur(10px);
            margin-left: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        th, td {
            padding: 15px 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: white;
        }

        th {
            background: linear-gradient(135deg, rgba(102,126,234,0.8), rgba(118,75,162,0.8));
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        tr:hover {
            background: rgba(255,255,255,0.1);
        }

        .linkedin-link {
            color: #00d4ff;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        .linkedin-link:hover {
            color: #00ff88;
            text-shadow: 0 0 5px rgba(0,255,136,0.5);
        }

        .status-message {
            padding: 20px;
            border-radius: 15px;
            margin: 15px 0;
            text-align: center;
            font-weight: 600;
            backdrop-filter: blur(10px);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .success {
            background: rgba(0, 200, 81, 0.2);
            color: #00ff88;
            border: 2px solid rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
        }

        .error {
            background: rgba(255, 68, 68, 0.2);
            color: #ff6b6b;
            border: 2px solid rgba(255, 107, 107, 0.3);
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.2);
        }

        .info {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            border: 2px solid rgba(0, 212, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        }

        .file-input {
            display: none;
        }

        .processing {
            display: none;
            text-align: center;
            padding: 30px;
            color: white;
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.2);
            border-top: 4px solid #00ff88;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .detection-info {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            color: white;
            font-size: 0.9rem;
            backdrop-filter: blur(5px);
        }

        .source-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin: 2px;
        }

        .source-qr {
            background: linear-gradient(135deg, #00c851, #007e33);
            color: white;
        }

        .source-ocr {
            background: linear-gradient(135deg, #ff8800, #cc6600);
            color: white;
        }

        .source-manual {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 25px;
            }
            
            .header h1 {
                font-size: 2.5rem;
            }
            
            .card {
                padding: 25px;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            table {
                font-size: 0.85rem;
            }
            
            th, td {
                padding: 10px 8px;
            }
            
            .table-controls {
                flex-direction: column;
            }
            
            .stats {
                margin-left: 0;
                text-align: center;
            }
        }

        /* Image Editor Styles */
        #brightnessSlider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.2);
            outline: none;
            cursor: pointer;
        }

        #brightnessSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        #brightnessSlider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        #brightnessSlider::-webkit-slider-track {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }

        #brightnessSlider::-moz-range-track {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            height: 6px;
        }

        .control-group {
            transition: all 0.3s ease;
        }

        .control-group:hover {
            background: rgba(255,255,255,0.1) !important;
            transform: translateY(-2px);
        }

        #editorCanvas {
            transition: all 0.3s ease;
        }

        #editorCanvas:hover {
            border-color: rgba(255,255,255,0.5);
            box-shadow: 0 0 20px rgba(0,255,136,0.2);
        }

        #cropOverlay {
            transition: all 0.2s ease;
        }
    </style>
</head>
<body>
    <div class="background-animation"></div>
    
    <div class="container">
        <div class="header">
            <h1>🚀 Exhibition Card Reader Pro</h1>
            <p>Advanced QR & Business Card Scanner with AI-Powered Data Extraction</p>
        </div>

        <div class="main-content">
            <!-- Enhanced Scanner Section -->
            <div class="card">
                <h2>📱 Smart Scanner</h2>
                <div class="scanner-section">
                    <div id="qr-reader" style="width:100%;max-width:400px;margin:0 auto;"></div>
                        <div class="camera-placeholder" id="cameraPlaceholder">
                            <div class="icon">📷</div>
                            <div>Click "Start Camera" to begin scanning</div>
                        </div>
                    <div style="margin: 20px 0;">
                        <div class="scan-mode-buttons" style="margin-bottom: 15px; text-align: center;">
                            <button id="qrModeBtn" class="btn mode-btn active" style="margin-right: 10px;">🔲 QR Code Mode</button>
                            <button id="imageModeBtn" class="btn mode-btn" style="margin-left: 10px;">🤖 AI Business Card Scanner</button>
                        </div>
                        <div style="text-align: center;">
                            <button id="startCamera" class="btn">🔴 Start Camera</button>
                            <button id="captureImage" class="btn" disabled>📸 Capture & Analyze</button>
                        </div>
                    </div>
                    <div class="detection-info">
                        <strong>🤖 Smart Detection:</strong> 
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li><strong>QR Mode:</strong> Scans QR codes for vCard and contact data</li>
                            <li><strong>AI Business Card Scanner:</strong> Captures image, shows preview, and uses AI vision for accurate data extraction</li>
                        </ul>
                        AI-powered extraction with image preview and confirmation. Falls back to OCR if needed.
                    </div>
                </div>

                <div class="upload-area" id="uploadArea">
                    <div class="icon">📁</div>
                    <p><strong>Drag & Drop Images Here</strong></p>
                    <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 10px;">
                        Supports QR codes, business cards, and contact images
                    </p>
                    <input type="file" id="fileInput" class="file-input" accept="image/*">
                    <button class="btn" onclick="document.getElementById('fileInput').click()">
                        Choose File
                    </button>
                </div>

                <!-- Image Editor Section -->
                <div class="image-editor" id="imageEditor" style="display: none;">
                    <h3 style="color: white; margin-bottom: 20px; text-align: center;">🖼️ Image Editor</h3>
                    
                    <div class="editor-container" style="
                        background: rgba(255,255,255,0.1);
                        border-radius: 15px;
                        padding: 20px;
                        margin-bottom: 20px;
                        backdrop-filter: blur(10px);
                        border: 1px solid rgba(255,255,255,0.2);
                    ">
                        <div class="canvas-container" style="
                            position: relative;
                            margin: 0 auto;
                            max-width: 100%;
                            text-align: center;
                        ">
                            <canvas id="editorCanvas" style="
                                max-width: 100%;
                                max-height: 400px;
                                border: 2px solid rgba(255,255,255,0.3);
                                border-radius: 10px;
                                cursor: crosshair;
                            "></canvas>
                            <div id="cropOverlay" style="
                                position: absolute;
                                border: 2px dashed #00ff88;
                                background: rgba(0,255,136,0.1);
                                display: none;
                                pointer-events: none;
                            "></div>
                        </div>
                        
                        <div class="editor-controls" style="
                            margin-top: 20px;
                            display: grid;
                            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                            gap: 15px;
                        ">
                            <!-- Crop Controls -->
                            <div class="control-group" style="
                                background: rgba(255,255,255,0.05);
                                padding: 15px;
                                border-radius: 10px;
                                border: 1px solid rgba(255,255,255,0.1);
                            ">
                                <h4 style="color: white; margin-bottom: 10px; font-size: 0.9rem;">✂️ Crop</h4>
                                <button id="cropBtn" class="btn mode-btn" style="margin: 5px;">Select Area</button>
                                <button id="applyCropBtn" class="btn success" style="margin: 5px; display: none;">Apply Crop</button>
                                <button id="cancelCropBtn" class="btn danger" style="margin: 5px; display: none;">Cancel</button>
                            </div>
                            
                            <!-- Brightness Controls -->
                            <div class="control-group" style="
                                background: rgba(255,255,255,0.05);
                                padding: 15px;
                                border-radius: 10px;
                                border: 1px solid rgba(255,255,255,0.1);
                            ">
                                <h4 style="color: white; margin-bottom: 10px; font-size: 0.9rem;">💡 Brightness</h4>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="color: white; font-size: 0.8rem;">-</span>
                                    <input type="range" id="brightnessSlider" min="-100" max="100" value="0" style="
                                        flex: 1;
                                        height: 6px;
                                        border-radius: 3px;
                                        background: rgba(255,255,255,0.2);
                                        outline: none;
                                        -webkit-appearance: none;
                                    ">
                                    <span style="color: white; font-size: 0.8rem;">+</span>
                                </div>
                                <div style="text-align: center; margin-top: 5px;">
                                    <span id="brightnessValue" style="color: white; font-size: 0.8rem;">0%</span>
                                </div>
                            </div>
                            
                            <!-- Rotation Controls -->
                            <div class="control-group" style="
                                background: rgba(255,255,255,0.05);
                                padding: 15px;
                                border-radius: 10px;
                                border: 1px solid rgba(255,255,255,0.1);
                            ">
                                <h4 style="color: white; margin-bottom: 10px; font-size: 0.8rem;">🔄 Rotate</h4>
                                <div style="display: flex; gap: 10px; justify-content: center;">
                                    <button id="rotateLeftBtn" class="btn mode-btn" style="padding: 8px 12px;">↶ -90°</button>
                                    <button id="rotateRightBtn" class="btn mode-btn" style="padding: 8px 12px;">↷ +90°</button>
                                </div>
                                <div style="text-align: center; margin-top: 10px;">
                                    <button id="resetRotationBtn" class="btn mode-btn" style="padding: 6px 10px; font-size: 0.8rem;">Reset</button>
                                </div>
                            </div>
                            
                            <!-- Action Buttons -->
                            <div class="control-group" style="
                                background: rgba(255,255,255,0.05);
                                padding: 15px;
                                border-radius: 10px;
                                border: 1px solid rgba(255,255,255,0.1);
                            ">
                                <h4 style="color: white; margin-bottom: 10px; font-size: 0.9rem;">⚡ Actions</h4>
                                <button id="processEditedBtn" class="btn success" style="margin: 5px; width: 100%;">Process Image</button>
                                <button id="resetEditorBtn" class="btn danger" style="margin: 5px; width: 100%;">Reset All</button>
                                <button id="testProcessBtn" class="btn" style="margin: 5px; width: 100%; background: #ff8800;">Test Process</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="processing" id="processing">
                    <div class="spinner"></div>
                    <p>🔍 Analyzing image and extracting contact data...</p>
                </div>

                <div id="statusMessage"></div>
            </div>

            <!-- Enhanced Manual Entry -->
            <div class="card">
                <h2>✍️ Manual Entry</h2>
                <form id="manualForm">
                    <div class="form-group">
                        <label for="manualName">👤 Full Name:</label>
                        <input type="text" id="manualName" placeholder="Enter client's full name">
                    </div>
                    
                    <div class="form-group">
                        <label for="manualEmail">📧 Email Address:</label>
                        <input type="email" id="manualEmail" placeholder="Enter email address">
                    </div>
                    
                    <div class="form-group">
                        <label for="manualPhone">📞 Phone Number:</label>
                        <input type="tel" id="manualPhone" placeholder="Enter phone number">
                    </div>
                    
                    <div class="form-group">
                        <label for="manualCompany">🏢 Company:</label>
                        <input type="text" id="manualCompany" placeholder="Enter company name (optional)">
                    </div>
                    
                    <div class="form-group">
                        <label for="manualLinkedIn">💼 LinkedIn Profile:</label>
                        <input type="url" id="manualLinkedIn" placeholder="LinkedIn profile URL (optional)">
                    </div>
                    
                    <div style="text-align: center; margin-top: 30px;">
                        <button type="submit" class="btn success">➕ Add Client</button>
                        <button type="button" id="searchLinkedIn" class="btn">🔍 Find LinkedIn</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Enhanced Clients Table -->
        <div class="card clients-table">
            <h2>👥 Collected Clients Database</h2>
            
            <div class="table-controls">
                <button id="exportData" class="btn success">📊 Export CSV</button>
                <button id="clearData" class="btn danger">🗑️ Clear All</button>
                <div class="stats" id="clientStats">
                    📊 Total Clients: 0
                </div>
            </div>
            
            <div style="overflow-x: auto;">
                <table id="clientsTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>👤 Name</th>
                            <th>📧 Email</th>
                            <th>📞 Phone</th>
                            <th>🏢 Company</th>
                            <th>💼 LinkedIn</th>
                            <th>🔍 Source</th>
                            <th>⏰ Added</th>
                            <th>🖊️ Edit</th>
                            <th>🗑️ Delete</th>
                        </tr>
                    </thead>
                    <tbody id="clientsTableBody">
                        <!-- Data will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Libraries -->
    <script src="https://unpkg.com/html5-qrcode"></script>
    <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>

    <script>
        // Helper class for the efficient name extraction
        class EfficientNameExtractor {
            constructor() {
                // Define name patterns with scoring weights
                this.namePatterns = [
                    // High confidence patterns (score: 10)
                    { pattern: /^[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/, score: 10, description: "Standard First Last" },
                    { pattern: /^[A-Z][a-z]{2,}\s+[A-Z]\.\s+[A-Z][a-z]{2,}$/, score: 10, description: "First M. Last" },
                    { pattern: /^[A-Z]\.\s+[A-Z][a-z]{2,}$/, score: 9, description: "F. Last" },
                    
                    // Medium confidence patterns (score: 7-8)
                    { pattern: /^[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/, score: 8, description: "First Middle Last" },
                    { pattern: /^[A-Z][a-z]{2,}\s+[A-Z][a-z]+-[A-Z][a-z]{2,}$/, score: 7, description: "First Hyphen-Last" },
                    { pattern: /^[A-Z][a-z]{2,}\s+[A-Z][a-z]+'[A-Z][a-z]{2,}$/, score: 7, description: "First O'Last" },
                    
                    // Title patterns (score: 8-9)
                    { pattern: /^Dr\.\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/i, score: 9, description: "Dr. First Last" },
                    { pattern: /^Mr\.\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/i, score: 9, description: "Mr. First Last" },
                    { pattern: /^Ms\.\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/i, score: 9, description: "Ms. First Last" },
                    { pattern: /^Mrs\.\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/i, score: 9, description: "Mrs. First Last" },
                    
                    // Lower confidence patterns (score: 5-6)
                    { pattern: /^[A-Z]{2,}\s+[A-Z]{2,}$/, score: 6, description: "FIRST LAST" },
                    { pattern: /^[A-Z][a-z]{1,}\s+[A-Z][a-z]{1,}$/, score: 5, description: "Short names" },
                    { pattern: /^[A-Z][a-z]{2,}$/, score: 4, description: "Single name" },
                    
                    // Initials patterns (score: 6-7)
                    { pattern: /^[A-Z]\.\s+[A-Z]\.\s+[A-Z][a-z]{2,}$/, score: 7, description: "A.B. Last" },
                    { pattern: /^[A-Z][a-z]{2,}\s+[A-Z]\.\s+[A-Z]\.$/, score: 6, description: "First A.B." }
                ];
                
                // Common words that should be excluded from names
                this.excludeWords = new Set([
                    'the', 'and', 'or', 'for', 'with', 'from', 'to', 'in', 'on', 'at', 'by', 'of', 'a', 'an',
                    'inc', 'llc', 'corp', 'ltd', 'company', 'co', 'corporation', 'group', 'solutions', 
                    'services', 'technologies', 'tech', 'systems', 'associates', 'partners', 'consulting',
                    'email', 'phone', 'tel', 'fax', 'mobile', 'cell', 'office', 'home', 'work',
                    'address', 'street', 'avenue', 'road', 'drive', 'lane', 'blvd', 'suite', 'apt',
                    'www', 'http', 'https', 'com', 'org', 'net', 'edu', 'gov'
                ]);
                
                // Common first names for additional validation
                this.commonFirstNames = new Set([
                    'james', 'john', 'robert', 'michael', 'william', 'david', 'richard', 'joseph', 'thomas', 'christopher',
                    'charles', 'daniel', 'matthew', 'anthony', 'mark', 'donald', 'steven', 'paul', 'andrew', 'joshua',
                    'mary', 'patricia', 'jennifer', 'linda', 'elizabeth', 'barbara', 'susan', 'jessica', 'sarah', 'karen',
                    'nancy', 'lisa', 'betty', 'helen', 'sandra', 'donna', 'carol', 'ruth', 'sharon', 'michelle'
                ]);
            }
            
            /**
             * Extract name with scoring system - main method
             */
            extractName(text) {
                if (!text || typeof text !== 'string') {
                    return { name: '', confidence: 0, method: 'invalid_input' };
                }
                
                // Clean and prepare text
                const lines = this.preprocessText(text);
                if (lines.length === 0) {
                    return { name: '', confidence: 0, method: 'no_lines' };
                }
                
                // Try different extraction methods in order of reliability
                const methods = [
                    () => this.extractWithPatternMatching(lines),
                    () => this.extractWithPositionalLogic(lines),
                    () => this.extractWithHeuristics(lines)
                ];
                
                for (let i = 0; i < methods.length; i++) {
                    const result = methods[i]();
                    if (result.confidence >= 5) { // Minimum confidence threshold
                        return result;
                    }
                }
                
                return { name: '', confidence: 0, method: 'no_match' };
            }
            
            /**
             * Preprocess text into clean lines
             */
            preprocessText(text) {
                return text
                    .split(/[\n\r]+/)
                    .map(line => line.trim())
                    .filter(line => {
                        if (line.length < 2) return false;
                        if (line.includes('@')) return false;
                        if (/https?:\/\//.test(line)) return false;
                        if (/^\+?\d[\d\s\-\(\)]{7,}/.test(line)) return false;
                        if (/^\d+/.test(line)) return false;
                        return true;
                    })
                    .slice(0, 8);
            }
            
            /**
             * Method 1: Pattern matching with scoring
             */
            extractWithPatternMatching(lines) {
                let bestMatch = { name: '', confidence: 0, method: 'pattern_matching' };
                
                for (const line of lines) {
                    for (const { pattern, score, description } of this.namePatterns) {
                        if (pattern.test(line)) {
                            let adjustedScore = score;
                            
                            // Boost score if first name is common
                            const firstWord = line.split(/\s+/)[0].toLowerCase().replace(/[^a-z]/g, '');
                            if (this.commonFirstNames.has(firstWord)) {
                                adjustedScore += 2;
                            }
                            
                            // Boost score if it's in the first few lines
                            const lineIndex = lines.indexOf(line);
                            if (lineIndex === 0) adjustedScore += 3;
                            else if (lineIndex === 1) adjustedScore += 2;
                            else if (lineIndex === 2) adjustedScore += 1;
                            
                            // Penalty for very long lines
                            if (line.length > 40) adjustedScore -= 2;
                            
                            // Penalty if line contains excluded words
                            const words = line.toLowerCase().split(/\s+/);
                            const hasExcludedWords = words.some(word => this.excludeWords.has(word));
                            if (hasExcludedWords) adjustedScore -= 3;
                            
                            if (adjustedScore > bestMatch.confidence) {
                                bestMatch = {
                                    name: line.trim(),
                                    confidence: adjustedScore,
                                    method: `pattern_matching_${description}`
                                };
                            }
                        }
                    }
                }
                
                return bestMatch;
            }
            
            /**
             * Method 2: Positional logic
             */
            extractWithPositionalLogic(lines) {
                for (let i = 0; i < Math.min(lines.length, 3); i++) {
                    const line = lines[i];
                    
                    if (this.isLikelyName(line)) {
                        let confidence = 6 - i;
                        
                        if (/^[A-Z][a-z]+\s+[A-Z][a-z]+$/.test(line)) {
                            confidence += 3;
                        }
                        
                        return {
                            name: line.trim(),
                            confidence: confidence,
                            method: `positional_logic_line_${i + 1}`
                        };
                    }
                }
                
                return { name: '', confidence: 0, method: 'positional_logic' };
            }
            
            /**
             * Method 3: Heuristic-based extraction
             */
            extractWithHeuristics(lines) {
                const candidates = [];
                
                for (const line of lines) {
                    if (this.isLikelyName(line)) {
                        let score = 0;
                        
                        const wordCount = line.split(/\s+/).length;
                        if (wordCount === 2) score += 4;
                        else if (wordCount === 3) score += 3;
                        else if (wordCount === 1) score += 1;
                        else score -= 1;
                        
                        const words = line.split(/\s+/);
                        const properlyCapitalized = words.every(word => 
                            /^[A-Z][a-z]*$/.test(word) || /^[A-Z]\.$/.test(word)
                        );
                        if (properlyCapitalized) score += 3;
                        
                        if (line.length >= 4 && line.length <= 30) score += 2;
                        if (line.length > 40) score -= 3;
                        
                        const letterRatio = (line.match(/[a-zA-Z]/g) || []).length / line.length;
                        if (letterRatio > 0.85) score += 2;
                        
                        candidates.push({
                            name: line.trim(),
                            confidence: Math.max(0, score),
                            method: 'heuristic_analysis'
                        });
                    }
                }
                
                candidates.sort((a, b) => b.confidence - a.confidence);
                return candidates[0] || { name: '', confidence: 0, method: 'heuristics' };
            }
            
            /**
             * Check if a line is likely to be a name
             */
            isLikelyName(line) {
                if (!line || line.length < 2 || line.length > 50) return false;
                
                if (!/^[A-Za-z\s\.\-']+$/.test(line)) return false;
                
                if (line === line.toUpperCase()) {
                    const words = line.split(/\s+/);
                    if (words.length > 3 || words.some(word => word.length > 8)) return false;
                }
                
                const words = line.toLowerCase().split(/\s+/);
                if (words.some(word => this.excludeWords.has(word))) return false;
                
                if (words.length > 5) return false;
                
                if (words.some(word => word.length > 20)) return false;
                
                return true;
            }
        }

        class ExhibitionCardReaderPro {
            constructor() {
                this.clients = this.loadClients();
                this.html5QrCode = null;
                this.cameraStarted = false;
                this.lastScanResult = null;
                this.currentScanMode = 'qr'; // 'qr' or 'image'
                this.isCapturing = false; // Prevent multiple captures
                
                // Image Editor Properties
                this.editorCanvas = null;
                this.editorCtx = null;
                this.originalImage = null;
                this.currentImage = null;
                this.rotation = 0;
                this.brightness = 0;
                this.isCropping = false;
                this.cropStart = null;
                this.cropEnd = null;
                this.cropOverlay = null;
                
                this.initializeEventListeners();
                this.updateClientsTable();
                this.setupDragAndDrop();
                this.updateScanModeUI();
                this.initializeImageEditor();
            }

            initializeEventListeners() {
                document.getElementById('startCamera').addEventListener('click', () => this.startCamera());
                document.getElementById('captureImage').addEventListener('click', () => this.captureAndAnalyzeImage());
                document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileUpload(e));
                document.getElementById('manualForm').addEventListener('submit', (e) => this.handleManualEntry(e));
                document.getElementById('searchLinkedIn').addEventListener('click', () => this.searchLinkedIn());
                document.getElementById('exportData').addEventListener('click', () => this.exportToCSV());
                document.getElementById('clearData').addEventListener('click', () => this.clearAllData());
                
                // Add scan mode toggle listeners
                document.getElementById('qrModeBtn').addEventListener('click', () => this.setScanMode('qr'));
                document.getElementById('imageModeBtn').addEventListener('click', () => this.setScanMode('image'));
                
                // Image Editor Event Listeners
                document.getElementById('cropBtn').addEventListener('click', () => this.toggleCropMode());
                document.getElementById('applyCropBtn').addEventListener('click', () => this.applyCrop());
                document.getElementById('cancelCropBtn').addEventListener('click', () => this.cancelCrop());
                document.getElementById('brightnessSlider').addEventListener('input', (e) => this.adjustBrightness(e.target.value));
                document.getElementById('rotateLeftBtn').addEventListener('click', () => this.rotateImage(-90));
                document.getElementById('rotateRightBtn').addEventListener('click', () => this.rotateImage(90));
                document.getElementById('resetRotationBtn').addEventListener('click', () => this.resetRotation());
                document.getElementById('processEditedBtn').addEventListener('click', () => this.processEditedImage());
                document.getElementById('resetEditorBtn').addEventListener('click', () => this.resetEditor());
                document.getElementById('testProcessBtn').addEventListener('click', () => this.testProcessImage());
            }

            setupDragAndDrop() {
                const uploadArea = document.getElementById('uploadArea');
                
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, this.preventDefaults, false);
                });

                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragover'), false);
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragover'), false);
                });

                uploadArea.addEventListener('drop', (e) => {
                    const files = e.dataTransfer.files;
                    console.log('Drop event triggered, files:', files);
                    if (files.length > 0) {
                        this.showStatus('📁 File dropped, loading into editor...', 'info');
                        this.loadImageIntoEditor(files[0]).then(() => {
                            this.showStatus('🖼️ Image loaded in editor. Edit the image or click "Process Image" to extract data.', 'info');
                        }).catch(error => {
                            console.error('Error loading dropped image into editor:', error);
                            this.showStatus('❌ Error loading image into editor', 'error');
                        });
                        // Clear any file input to ensure fresh state
                        const fileInput = document.getElementById('fileInput');
                        if (fileInput) {
                            fileInput.value = '';
                        }
                    }
                }, false);
            }

            preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            /**
             * Clear file input to allow re-uploading the same file
             */
            clearFileInput() {
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    fileInput.value = '';
                }
            }

            /**
             * Set the current scan mode and update UI
             */
            setScanMode(mode) {
                this.currentScanMode = mode;
                this.updateScanModeUI();
                
                const modeText = mode === 'qr' ? 'QR Code' : 'Business Card';
                this.showStatus(`🔄 Switched to ${modeText} scanning mode`, 'info');
                
                // Stop camera if running to apply new mode
                if (this.cameraStarted) {
                    this.stopCamera();
                }
            }

            /**
             * Update the scan mode UI buttons
             */
            updateScanModeUI() {
                const qrBtn = document.getElementById('qrModeBtn');
                const imageBtn = document.getElementById('imageModeBtn');
                const captureBtn = document.getElementById('captureImage');
                
                if (this.currentScanMode === 'qr') {
                    qrBtn.classList.add('active');
                    imageBtn.classList.remove('active');
                    // Disable capture button in QR mode
                    captureBtn.disabled = true;
                } else {
                    imageBtn.classList.add('active');
                    qrBtn.classList.remove('active');
                    // Enable capture button only if camera is started
                    captureBtn.disabled = !this.cameraStarted;
                }
                
                console.log('Mode updated:', this.currentScanMode, 'Capture enabled:', !captureBtn.disabled);
            }

            /**
             * Capture and analyze image for business card scanning
             */
            async captureAndAnalyzeImage() {
                console.log('captureAndAnalyzeImage called');
                
                // Prevent multiple captures
                if (this.isCapturing) {
                    this.showStatus('⏳ Already capturing, please wait...', 'warning');
                    return;
                }
                
                // Check if camera is started
                if (!this.cameraStarted) {
                    this.showStatus('❌ Camera not started. Please start camera first.', 'error');
                    return;
                }
                
                this.isCapturing = true;
                
                try {
                    this.showStatus('📸 Preparing to capture business card image...', 'info');
                    
                    // Show countdown for user feedback
                    for (let i = 2; i > 0; i--) {
                        this.showStatus(`📸 Capturing in ${i} seconds...`, 'info');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    this.showStatus('📸 Capturing business card image...', 'info');
                    
                    // Get the video element from html5-qrcode
                    const videoElement = document.querySelector('#qr-reader video');
                    console.log('Video element found:', videoElement);
                    
                    if (!videoElement) {
                        this.showStatus('❌ Camera not ready for capture - no video element found', 'error');
                        this.isCapturing = false;
                        return;
                    }
                    
                    // Additional check to ensure video is playing
                    if (videoElement.readyState < 2) {
                        this.showStatus('⏳ Camera still initializing, please wait...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                    
                    // Create canvas and capture frame
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = videoElement.videoWidth;
                    canvas.height = videoElement.videoHeight;
                    
                    console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
                    console.log('Video dimensions:', videoElement.videoWidth, 'x', videoElement.videoHeight);
                    
                    if (canvas.width === 0 || canvas.height === 0) {
                        this.showStatus('❌ Video not ready - dimensions are zero', 'error');
                        this.isCapturing = false;
                        return;
                    }
                    
                    ctx.drawImage(videoElement, 0, 0);
                    console.log('Frame captured successfully');
                    
                    // Convert to blob and load into editor
                    canvas.toBlob(async (blob) => {
                        console.log('Blob created:', blob);
                        if (blob) {
                            console.log('Blob size:', blob.size, 'bytes');
                            console.log('Loading captured image into editor...');
                            try {
                                // Create a file from the blob to load into editor
                                const file = new File([blob], 'captured-image.jpg', { type: 'image/jpeg' });
                                await this.loadImageIntoEditor(file);
                                console.log('Image loaded into editor successfully');
                                this.stopCamera();
                            } catch (error) {
                                console.error('Error loading captured image into editor:', error);
                                this.showStatus('❌ Error loading captured image into editor: ' + error.message, 'error');
                            }
                        } else {
                            console.error('Failed to create blob from canvas');
                            this.showStatus('❌ Failed to create image from camera', 'error');
                        }
                        this.isCapturing = false; // Reset capture flag
                    }, 'image/jpeg', 0.9);
                    
                } catch (error) {
                    this.showStatus('❌ Failed to capture image: ' + error.message, 'error');
                    this.isCapturing = false; // Reset capture flag on error
                }
            }

            async startCamera() {
                if (this.cameraStarted) return;
                
                if (!this.html5QrCode) {
                    this.html5QrCode = new Html5Qrcode("qr-reader");
                }

                document.getElementById('cameraPlaceholder').style.display = 'none';
                document.getElementById('startCamera').disabled = true;
                
                // Only enable capture button in business card mode
                const captureBtn = document.getElementById('captureImage');
                captureBtn.disabled = this.currentScanMode !== 'image';
                console.log('Capture button enabled:', !captureBtn.disabled, 'Mode:', this.currentScanMode);
                    
                try {
                    const devices = await Html5Qrcode.getCameras();
                    if (devices && devices.length) {
                        const config = this.currentScanMode === 'qr' 
                            ? { fps: 10, qrbox: 250 }
                            : { fps: 10, qrbox: { width: 400, height: 300 } };
                            
                        await this.html5QrCode.start(
                            { facingMode: "environment" },
                            config,
                            (decodedText, decodedResult) => {
                                if (this.currentScanMode === 'qr') {
                                    // QR Mode: Process QR code immediately
                                    if (this.lastScanResult !== decodedText) {
                                        this.lastScanResult = decodedText;
                                        this.processQRResult(decodedText, 'QR Camera');
                                        this.stopCamera();
                                    }
                                }
                                // Business Card Mode: Wait for manual capture button
                                // No auto-capture to prevent blur/wrong frame issues
                            },
                            (errorMessage) => {
                                // Handle scan errors
                            }
                        );
                        this.cameraStarted = true;
                        const modeText = this.currentScanMode === 'qr' ? 'QR codes' : 'business cards';
                        this.showStatus(`📷 Camera started! Point at ${modeText} for scanning.`, 'success');
                        
                        // For business card mode, add extra stabilization time and manual capture instruction
                        if (this.currentScanMode === 'image') {
                            setTimeout(() => {
                                this.showStatus('✅ Camera ready! Click "Capture & Analyze" when card is positioned.', 'success');
                            }, 3000);
                        }
                    } else {
                        this.showStatus('❌ No camera found.', 'error');
                    }
                } catch (err) {
                    this.showStatus('❌ Camera error: ' + err.message, 'error');
                }
            }

            async stopCamera() {
                if (this.html5QrCode && this.cameraStarted) {
                    await this.html5QrCode.stop();
                    this.cameraStarted = false;
                    document.getElementById('cameraPlaceholder').style.display = 'flex';
                    document.getElementById('startCamera').disabled = false;
                    document.getElementById('captureImage').disabled = true;
                    this.showStatus('⏹️ Camera stopped', 'info');
                }
            }

            async captureAndAnalyze() {
                if (!this.cameraStarted) {
                    this.showStatus('❌ Camera not started.', 'error');
                    return;
                }
                
                this.showProcessing(true);
                try {
                    // Get the video element from html5-qrcode
                    const video = document.querySelector('#qr-reader video');
                    if (!video) {
                        this.showStatus('❌ Video stream not found.', 'error');
                        this.showProcessing(false);
                        return;
                    }
                    
                    // Create canvas and capture frame
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    canvas.getContext('2d').drawImage(video, 0, 0);
                    const imageDataUrl = canvas.toDataURL('image/png');
                    
                    // Try QR scan from image
                    const qrResult = await this.scanQRCodeFromImage(imageDataUrl);
                    if (qrResult) {
                        await this.processQRResult(qrResult, 'Camera QR');
                } else {
                        this.showStatus('🔄 No QR found, running OCR...', 'info');
                        await this.analyzeImageWithOCR(imageDataUrl, 'Camera OCR');
                    }
                } catch (err) {
                    this.showStatus('❌ Error during capture: ' + err.message, 'error');
                } finally {
                    this.showProcessing(false);
                    this.stopCamera();
                }
            }

            async scanQRCodeFromImage(imageDataUrl) {
                try {
                    // Try html5-qrcode first
                    const html5QrCodeFile = new Html5Qrcode();
                    const blob = await (await fetch(imageDataUrl)).blob();
                    const qrText = await html5QrCodeFile.scanFile(blob, true);
                    return qrText;
                } catch (e) {
                    console.log('html5-qrcode failed, trying jsQR fallback:', e);
                    // Fallback to jsQR
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const code = jsQR(imageData.data, imageData.width, imageData.height);
                            
                            resolve(code ? code.data : null);
                        };
                        img.onerror = () => resolve(null);
                        img.src = imageDataUrl;
                    });
                }
            }

            async processQRResult(qrText, source) {
                console.log('Processing QR result:', qrText);
                const clientData = this.parseQRData(qrText);
                console.log('Extracted client data:', clientData);
                
                if (clientData.name || clientData.email || clientData.phone) {
                    await this.addClientWithLinkedInSearch(clientData, source);
                    this.showStatus('✅ Client data extracted and added successfully! Source: ' + source, 'success');
                } else {
                    this.showStatus('🔄 QR found but no contact info, running OCR...', 'info');
                    // For file uploads, we need to get the original image data for OCR
                    // This will be handled in the calling method
                    return false; // Indicate no contact info found
                }
                return true; // Indicate contact info was found
            }

            handleFileUpload(event) {
                const file = event.target.files[0];
                if (file) {
                    // Load image into editor first
                    this.loadImageIntoEditor(file).then(() => {
                        this.showStatus('🖼️ Image loaded in editor. Edit the image or click "Process Image" to extract data.', 'info');
                    }).catch(error => {
                        console.error('Error loading image into editor:', error);
                        this.showStatus('❌ Error loading image into editor', 'error');
                    });
                    // Clear the file input to allow re-uploading the same file
                    event.target.value = '';
                }
            }

            /**
             * Process business card with AI vision for better accuracy
             */
            async processBusinessCardWithAI(blob, canvas) {
                try {
                    this.showStatus('📸 Captured business card image', 'info');
                    
                    // Display the captured image on screen and wait for user confirmation
                    await this.displayCapturedImageAndWait(canvas, blob);
                    
                } catch (error) {
                    console.error('AI processing error:', error);
                    this.showStatus('❌ AI processing failed, trying OCR fallback...', 'warning');
                    await this.processImageFile(blob);
                }
            }

            /**
             * Display captured image on screen and wait for user confirmation
             */
            async displayCapturedImageAndWait(canvas, blob) {
                return new Promise((resolve, reject) => {
                    // Create image preview container if it doesn't exist
                    let previewContainer = document.getElementById('imagePreview');
                    if (!previewContainer) {
                        previewContainer = document.createElement('div');
                        previewContainer.id = 'imagePreview';
                        previewContainer.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background: white;
                            border: 2px solid #007bff;
                            border-radius: 10px;
                            padding: 10px;
                            z-index: 1000;
                            max-width: 80vw;
                            max-height: 80vh;
                            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                        `;
                        document.body.appendChild(previewContainer);
                    }
                    
                    // Clear previous content
                    previewContainer.innerHTML = '';
                    previewContainer.style.display = 'block';
                    
                    // Add image
                    const img = document.createElement('img');
                    img.src = canvas.toDataURL('image/jpeg', 0.9);
                    img.style.cssText = 'max-width: 100%; max-height: 70vh; border-radius: 5px;';
                    
                    // Add controls
                    const controls = document.createElement('div');
                    controls.style.cssText = 'text-align: center; margin-top: 10px;';
                    controls.innerHTML = `
                        <button id="confirmImage" class="btn btn-success" style="margin-right: 10px;">
                            ✅ Confirm & Process
                        </button>
                        <button id="retakeImage" class="btn btn-secondary">
                            📸 Retake
                        </button>
                    `;
                    
                    previewContainer.appendChild(img);
                    previewContainer.appendChild(controls);
                    
                    // Add event listeners
                    document.getElementById('confirmImage').addEventListener('click', async () => {
                        previewContainer.style.display = 'none';
                        this.showStatus('🤖 Processing confirmed business card with AI...', 'info');
                        
                        try {
                            // Convert blob to base64 for AI processing
                            const base64Image = await this.blobToBase64(blob);
                            
                            // Extract data using AI vision
                            const clientData = await this.extractBusinessCardDataWithAI(base64Image);
                            
                            if (clientData && (clientData.name || clientData.email || clientData.phone)) {
                                await this.addClientWithLinkedInSearch(clientData, 'AI Business Card Scanner');
                                this.showStatus('✅ Business card data extracted successfully with AI!', 'success');
                                resolve();
                            } else {
                                // Fallback to OCR if AI extraction fails
                                this.showStatus('🔄 AI extraction incomplete, trying OCR fallback...', 'info');
                                await this.processImageFile(blob);
                                resolve();
                            }
                        } catch (error) {
                            console.error('Error processing confirmed image:', error);
                            this.showStatus('❌ AI processing failed, trying OCR fallback...', 'warning');
                            await this.processImageFile(blob);
                            resolve();
                        }
                    });
                    
                    document.getElementById('retakeImage').addEventListener('click', () => {
                        previewContainer.style.display = 'none';
                        this.isCapturing = false;
                        this.showStatus('📸 Ready to capture new image', 'info');
                        reject(new Error('User chose to retake image'));
                    });
                    
                    // Auto-hide after 15 seconds
                    setTimeout(() => {
                        if (previewContainer.style.display !== 'none') {
                            previewContainer.style.display = 'none';
                            this.isCapturing = false;
                            this.showStatus('⏰ Image preview timed out', 'warning');
                            reject(new Error('Image preview timed out'));
                        }
                    }, 15000);
                });
            }

            /**
             * Display captured image on screen for user confirmation (legacy method)
             */
            displayCapturedImage(canvas) {
                // Create image preview container if it doesn't exist
                let previewContainer = document.getElementById('imagePreview');
                if (!previewContainer) {
                    previewContainer = document.createElement('div');
                    previewContainer.id = 'imagePreview';
                    previewContainer.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: white;
                        border: 2px solid #007bff;
                        border-radius: 10px;
                        padding: 10px;
                        z-index: 1000;
                        max-width: 80vw;
                        max-height: 80vh;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                    `;
                    document.body.appendChild(previewContainer);
                }
                
                // Clear previous content
                previewContainer.innerHTML = '';
                
                // Add image
                const img = document.createElement('img');
                img.src = canvas.toDataURL('image/jpeg', 0.9);
                img.style.cssText = 'max-width: 100%; max-height: 70vh; border-radius: 5px;';
                
                // Add controls
                const controls = document.createElement('div');
                controls.style.cssText = 'text-align: center; margin-top: 10px;';
                controls.innerHTML = `
                    <button id="confirmImage" class="btn btn-success" style="margin-right: 10px;">
                        ✅ Confirm & Process
                    </button>
                    <button id="retakeImage" class="btn btn-secondary">
                        📸 Retake
                    </button>
                `;
                
                previewContainer.appendChild(img);
                previewContainer.appendChild(controls);
                
                // Add event listeners
                document.getElementById('confirmImage').addEventListener('click', () => {
                    previewContainer.style.display = 'none';
                    this.processConfirmedImage(blob);
                });
                
                document.getElementById('retakeImage').addEventListener('click', () => {
                    previewContainer.style.display = 'none';
                    this.isCapturing = false;
                });
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    if (previewContainer.style.display !== 'none') {
                        previewContainer.style.display = 'none';
                    }
                }, 10000);
            }

            /**
             * Convert blob to base64 for AI processing
             */
            blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            /**
             * Extract business card data using AI vision
             */
            async extractBusinessCardDataWithAI(base64Image) {
                try {
                    // For now, we'll simulate AI processing with enhanced OCR
                    // In a real implementation, you would call an AI vision API
                    
                    // Create a temporary canvas to process the image
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    return new Promise((resolve) => {
                        img.onload = () => {
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            
                            // Use Tesseract.js for enhanced OCR
                            Tesseract.recognize(canvas, 'eng', {
                                logger: m => console.log('OCR Progress:', m)
                            }).then(({ data: { text } }) => {
                                console.log('AI OCR Text:', text);
                                
                                // Enhanced extraction with AI-like patterns
                                const clientData = this.extractBusinessCardDataFromText(text);
                                resolve(clientData);
                            }).catch(error => {
                                console.error('AI OCR Error:', error);
                                resolve(null);
                            });
                        };
                        img.src = base64Image;
                    });
                    
                } catch (error) {
                    console.error('AI extraction error:', error);
                    return null;
                }
            }

            /**
             * Enhanced business card data extraction
             */
            extractBusinessCardDataFromText(text) {
                const clientData = { name: '', email: '', phone: '', company: '', notes: '' };
                
                // Clean and normalize text
                const cleanText = text.replace(/\s+/g, ' ').trim();
                const lines = cleanText.split('\n').filter(line => line.trim().length > 0);
                
                console.log('Processing business card text:', cleanText);
                
                // Extract emails (highest priority)
                const emails = this.extractEmails(cleanText);
                if (emails.length > 0) {
                    clientData.email = emails[0];
                    console.log('Found email:', clientData.email);
                }
                
                // Extract phone numbers
                const phones = this.extractPhoneNumbers(cleanText);
                if (phones.length > 0) {
                    clientData.phone = phones[0];
                    console.log('Found phone:', clientData.phone);
                }
                
                // Extract name with enhanced patterns
                clientData.name = this.extractNameFromBusinessCard(lines, emails, phones);
                if (clientData.name) {
                    console.log('Found name:', clientData.name);
                }
                
                // Extract company with enhanced patterns
                clientData.company = this.extractCompanyFromBusinessCard(lines, emails, phones);
                if (clientData.company) {
                    console.log('Found company:', clientData.company);
                }
                
                // Store additional info in notes
                const additionalInfo = [];
                if (emails.length > 1) additionalInfo.push(`Additional emails: ${emails.slice(1).join(', ')}`);
                if (phones.length > 1) additionalInfo.push(`Additional phones: ${phones.slice(1).join(', ')}`);
                
                // Extract website if found
                const websiteMatch = cleanText.match(/https?:\/\/[^\s]+/g);
                if (websiteMatch) {
                    additionalInfo.push(`Website: ${websiteMatch[0]}`);
                }
                
                if (additionalInfo.length > 0) {
                    clientData.notes = additionalInfo.join('; ');
                }
                
                return clientData;
            }

            /**
             * Extract name from business card with enhanced patterns
             */
            extractNameFromBusinessCard(lines, emails, phones) {
                // Priority 1: Look for name patterns in first few lines
                for (let i = 0; i < Math.min(3, lines.length); i++) {
                    const line = lines[i].trim();
                    
                    // Skip if line contains email or phone
                    if (emails.some(email => line.includes(email)) || 
                        phones.some(phone => line.includes(phone))) {
                        continue;
                    }
                    
                    // Enhanced name patterns
                    const namePatterns = [
                        /^[A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3}$/, // "John Doe"
                        /^[A-Z][a-z]+\s+[A-Z]\.\s*[A-Z][a-z]+$/, // "John M. Doe"
                        /^[A-Z][a-z]+\s+[A-Z][a-z]+$/, // "John Doe"
                        /^[A-Z][a-z]+$/, // Single name
                    ];
                    
                    for (const pattern of namePatterns) {
                        if (pattern.test(line)) {
                            const nameExtractor = new EfficientNameExtractor();
                            const result = nameExtractor.extractName(line);
                            if (result.confidence >= 5) {
                                return this.validateNameWithDataset(result.name);
                            }
                        }
                    }
                }
                
                // Priority 2: Extract from email prefix
                if (emails.length > 0) {
                    const emailPrefix = emails[0].split('@')[0];
                    const nameFromEmail = emailPrefix
                        .replace(/[^a-zA-Z]/g, ' ')
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    if (nameFromEmail.split(' ').length <= 3) {
                        const nameExtractor = new EfficientNameExtractor();
                        const result = nameExtractor.extractName(nameFromEmail);
                        if (result.confidence >= 4) {
                            return this.validateNameWithDataset(result.name);
                        }
                    }
                }
                
                return '';
            }

            /**
             * Extract company from business card with enhanced patterns
             */
            extractCompanyFromBusinessCard(lines, emails, phones) {
                // Look for company patterns
                const companyPatterns = [
                    /(.*?)\s+(Inc\.?|LLC|Corp\.?|Ltd\.?|Company|Co\.?|Corporation|Group|Solutions|Services|Technologies|Tech|Systems|Associates|Partners|Consulting)(?!\w)/i,
                    /^[A-Z][a-zA-Z\s&]+(?:Inc\.?|LLC|Corp\.?|Ltd\.?)$/i,
                    /^[A-Z][a-zA-Z\s&]{3,}$/i // Standalone company names
                ];
                
                for (const line of lines) {
                    const cleanLine = line.trim();
                    
                    // Skip if line contains email or phone
                    if (emails.some(email => cleanLine.includes(email)) || 
                        phones.some(phone => cleanLine.includes(phone))) {
                        continue;
                    }
                    
                    for (const pattern of companyPatterns) {
                        const match = cleanLine.match(pattern);
                        if (match && cleanLine.length > 3) {
                            return cleanLine;
                        }
                    }
                }
                
                return '';
            }



            async processImageFile(file) {
                console.log('Processing file:', file.name, file.type);
                
                if (!file.type.startsWith('image/')) {
                    this.showStatus('❌ Please upload a valid image file.', 'error');
                    return;
                }

                // Clear file input to allow re-uploading the same file
                this.clearFileInput();

                // Add timestamp to ensure unique processing
                const timestamp = Date.now();
                console.log(`Processing file at timestamp: ${timestamp}`);

                this.showProcessing(true);
                this.showStatus(`🔍 Analyzing image for QR codes and text... (${timestamp})`, 'info');
                
                try {
                    // Try QR scan from file using html5-qrcode
                    const html5QrCodeFile = new Html5Qrcode();
                    const qrText = await html5QrCodeFile.scanFile(file, true);
                    
                    if (qrText) {
                        console.log('QR found:', qrText);
                        const contactFound = await this.processQRResult(qrText, 'File QR');
                        if (!contactFound) {
                            // QR found but no contact info, run OCR on the file
                            console.log('No contact info in QR, running OCR on file');
                const reader = new FileReader();
                            reader.onload = async (ev) => {
                                await this.analyzeImageWithOCR(ev.target.result, 'File OCR');
                };
                reader.readAsDataURL(file);
                        }
                    } else {
                        console.log('No QR found, trying OCR');
                        this.showStatus('🔄 No QR found, running OCR...', 'info');
                        const reader = new FileReader();
                        reader.onload = async (ev) => {
                            await this.analyzeImageWithOCR(ev.target.result, 'File OCR');
                        };
                        reader.readAsDataURL(file);
                    }
                } catch (err) {
                    console.log('html5-qrcode file scan failed, trying jsQR fallback:', err);
                    // Fallback to jsQR for file scanning
                    try {
                        const reader = new FileReader();
                        reader.onload = async (ev) => {
                            const qrResult = await this.scanQRCodeFromImage(ev.target.result);
                    if (qrResult) {
                                console.log('QR found with jsQR fallback:', qrResult);
                                const contactFound = await this.processQRResult(qrResult, 'File QR (jsQR)');
                                if (!contactFound) {
                                    // QR found but no contact info, run OCR
                                    console.log('No contact info in QR, running OCR');
                                    await this.analyzeImageWithOCR(ev.target.result, 'File OCR');
                                }
                        } else {
                                console.log('No QR found with jsQR, trying OCR');
                                this.showStatus('🔄 No QR found, running OCR...', 'info');
                                await this.analyzeImageWithOCR(ev.target.result, 'File OCR');
                            }
                        };
                        reader.readAsDataURL(file);
                    } catch (fallbackErr) {
                        console.error('Both QR methods failed:', fallbackErr);
                        this.showStatus('❌ Error analyzing file: ' + (fallbackErr.message || 'Unknown error'), 'error');
                    }
                } finally {
                    this.showProcessing(false);
                }
            }

            parseQRData(qrText) {
                const clientData = { name: '', email: '', phone: '', company: '', notes: '' };
                console.log('Parsing QR text:', qrText);
                
                // Initialize the efficient name extractor
                const nameExtractor = new EfficientNameExtractor();
                
                // Check if it's a vCard format
                if (qrText.startsWith('BEGIN:VCARD')) {
                    console.log('Detected vCard format');
                    const lines = qrText.split('\n');
                    lines.forEach(line => {
                        const cleanLine = line.trim();
                        if (cleanLine.startsWith('FN:')) clientData.name = cleanLine.substring(3);
                        if (cleanLine.startsWith('N:')) {
                            const nameParts = cleanLine.substring(2).split(';');
                            if (!clientData.name && nameParts.length >= 2) {
                                clientData.name = `${nameParts[1]} ${nameParts[0]}`.trim();
                            }
                        }
                        if (cleanLine.startsWith('EMAIL:') || cleanLine.includes('EMAIL:')) {
                            const emailMatch = cleanLine.match(/EMAIL[^:]*:(.*)/i);
                            if (emailMatch) clientData.email = emailMatch[1].trim();
                        }
                        if (cleanLine.startsWith('TEL:') || cleanLine.includes('TEL:')) {
                            const telMatch = cleanLine.match(/TEL[^:]*:(.*)/i);
                            if (telMatch) clientData.phone = telMatch[1].trim();
                        }
                        if (cleanLine.startsWith('ORG:')) clientData.company = cleanLine.substring(4);
                    });
                } else {
                    console.log('Parsing as plain text with enhanced extraction');
                    
                    // Extract all possible emails and phones
                    const allEmails = this.extractEmails(qrText);
                    const allPhones = this.extractPhoneNumbers(qrText);
                    
                    // Select the best email and phone
                    if (allEmails.length > 0) {
                        clientData.email = allEmails[0];
                        console.log('Found primary email:', clientData.email);
                        
                        // If we have multiple emails, consider adding secondary to notes
                        if (allEmails.length > 1) {
                            clientData.notes = `Additional emails: ${allEmails.slice(1).join(', ')}`;
                            console.log('Found additional emails:', allEmails.slice(1));
                        }
                    }
                    
                    if (allPhones.length > 0) {
                        clientData.phone = allPhones[0];
                        console.log('Found primary phone:', clientData.phone);
                        
                        // If we have multiple phones, consider adding secondary to notes
                        if (allPhones.length > 1) {
                            const phoneNote = `Additional phones: ${allPhones.slice(1).join(', ')}`;
                            clientData.notes = clientData.notes 
                                ? `${clientData.notes}; ${phoneNote}`
                                : phoneNote;
                            console.log('Found additional phones:', allPhones.slice(1));
                        }
                    }
                    
                    // Extract name with context awareness
                    clientData.name = this.extractNameWithContext(qrText);
                    if (clientData.name) {
                        console.log('Found name with context:', clientData.name);
                    }
                    
                    // Enhanced company extraction for QR codes
                    const lines = qrText.split('\n').filter(line => line.trim().length > 0);
                    const companyPatterns = [
                        // vCard ORG field (highest priority)
                        /^ORG:(.+)$/i,
                        // Company patterns with suffixes
                        /(.*?)\s+(Inc\.?|LLC|Corp\.?|Ltd\.?|Company|Co\.?|Corporation|Group|Solutions|Services|Technologies|Tech|Systems|Associates|Partners|Consulting)(?!\w)/i,
                        // Standalone company names
                        /^[A-Z][a-zA-Z\s&]+(?:Inc\.?|LLC|Corp\.?|Ltd\.?)$/i,
                        // Lines that look like company names (no email/phone patterns)
                        /^[A-Z][a-zA-Z\s&]{2,}$/i
                    ];
                    
                    for (const line of lines) {
                        const cleanLine = line.trim();
                        
                        // Skip if line contains email or phone patterns
                        if (cleanLine.includes('@') || /\d{7,}/.test(cleanLine)) {
                            continue;
                        }
                        
                        for (const pattern of companyPatterns) {
                            const match = cleanLine.match(pattern);
                            if (match && !clientData.company) {
                                let companyName = match[1] || match[0];
                                // Clean up the company name
                                companyName = companyName.replace(/^ORG:\s*/i, '').trim();
                                if (companyName.length > 2) {
                                    clientData.company = companyName;
                                    console.log('Found company:', clientData.company);
                                    break;
                                }
                            }
                        }
                        if (clientData.company) break;
                    }
                    
                    // If we have email but no name, try to extract name from email prefix
                    if (clientData.email && !clientData.name) {
                        const emailPrefix = clientData.email.split('@')[0];
                        const nameFromEmail = emailPrefix
                            .replace(/[^a-zA-Z]/g, ' ')
                            .replace(/\s+/g, ' ')
                            .trim();
                        
                        if (nameFromEmail.split(' ').length <= 3) {
                            const nameCheck = nameExtractor.extractName(nameFromEmail);
                            if (nameCheck.confidence >= 4) {
                                clientData.name = nameCheck.name;
                                console.log('Extracted name from email:', clientData.name);
                            }
                        }
                    }
                    
                    // Check if it's just a URL or error code (no contact info)
                    const isUrl = qrText.match(/^https?:\/\//);
                    const isErrorCode = qrText.match(/^(ERROR|FAIL|INVALID)/i);
                    
                    if (isUrl && !clientData.name && !clientData.email && !clientData.phone) {
                        // If it's just a URL, try to extract domain as company
                        const domainMatch = qrText.match(/https?:\/\/([^\/]+)/);
                        if (domainMatch) {
                            clientData.company = domainMatch[1].replace('www.', '');
                            console.log('Extracted company from URL:', clientData.company);
                        }
                    }
                }
                
                console.log('Final extracted data:', clientData);
                return clientData;
            }

            /**
             * Optimized phone number extraction with multiple number handling
             */
            extractPhoneNumbers(text) {
                // Enhanced phone regex patterns
                const phonePatterns = [
                    // Standard formats (highest priority)
                    /(?:\+?91[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})/g,
                    /(?:\+?[0-9]{1,3}[-.\s]?)?\(?[0-9]{2,4}\)?[-.\s]?[0-9]{2,4}[-.\s]?[0-9]{2,4}[-.\s]?[0-9]{2,4}/g,
                    
                    // International formats
                    /\+[\d\s\-\(\)]{10,20}/g,
                    
                    // Special cases (lower priority)
                    /tel:([+\d\s\-\(\)]+)/gi,
                    /phone:([+\d\s\-\(\)]+)/gi,
                    /mobile:([+\d\s\-\(\)]+)/gi
                ];

                const foundNumbers = new Set();
                
                // Try each pattern in order of priority
                for (const pattern of phonePatterns) {
                    const matches = text.match(pattern);
                    if (matches) {
                        matches.forEach(num => {
                            // Clean the number
                            let cleanNum = num.replace(/[^\d+]/g, '');
                            
                            // Remove tel: or phone: prefixes if present
                            if (cleanNum.startsWith('tel') || cleanNum.startsWith('phone')) {
                                cleanNum = cleanNum.replace(/^[a-z]+/i, '');
                            }
                            
                            // Validate length (minimum 7 digits for local numbers, 10 for full numbers)
                            if ((cleanNum.startsWith('+') && cleanNum.length >= 8) || 
                                (!cleanNum.startsWith('+') && cleanNum.length >= 7)) {
                                foundNumbers.add(cleanNum);
                            }
                        });
                        
                        // If we found numbers with high confidence pattern, stop searching
                        if (foundNumbers.size > 0 && pattern === phonePatterns[0]) break;
                    }
                }

                // Convert to array and prioritize numbers
                const numbers = Array.from(foundNumbers);
                
                // Prioritization logic:
                // 1. Numbers with + prefix (international)
                // 2. Longer numbers (more likely to be complete)
                // 3. Numbers that appear earlier in the text
                numbers.sort((a, b) => {
                    const aIsIntl = a.startsWith('+');
                    const bIsIntl = b.startsWith('+');
                    
                    if (aIsIntl && !bIsIntl) return -1;
                    if (!aIsIntl && bIsIntl) return 1;
                    
                    if (a.length !== b.length) return b.length - a.length;
                    
                    return text.indexOf(a) - text.indexOf(b);
                });

                return numbers;
            }

            /**
             * Enhanced email extraction with multiple email handling
             */
            extractEmails(text) {
                // Multiple email patterns for better accuracy
                const emailPatterns = [
                    // Standard email pattern
                    /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g,
                    // Email with common prefixes
                    /(?:email|e-mail|mail|contact)[\s:]*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/gi,
                    // Email in parentheses or brackets
                    /[\(\[][^\)\]]*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})[^\(\[\]]*[\)\]]/g
                ];
                
                const foundEmails = new Set();
                
                for (const pattern of emailPatterns) {
                    const matches = text.match(pattern);
                    if (matches && matches.length > 0) {
                        matches.forEach(email => {
                            // Clean up the email (remove prefixes, parentheses, etc.)
                            let cleanEmail = email;
                            
                            // Extract email from patterns with prefixes
                            if (pattern.source.includes('email|e-mail|mail|contact')) {
                                const emailMatch = email.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
                                if (emailMatch) cleanEmail = emailMatch[1];
                            }
                            
                            // Remove parentheses/brackets if present
                            cleanEmail = cleanEmail.replace(/[\(\)\[\]]/g, '');
                            
                            // Validate email format
                            if (this.isValidEmail(cleanEmail)) {
                                foundEmails.add(cleanEmail.toLowerCase());
                            }
                        });
                    }
                }
                
                // Convert to array and prioritize emails
                const emails = Array.from(foundEmails);
                
                // Prioritization logic:
                // 1. Personal emails (not business domains like noreply, info, etc.)
                // 2. Shorter emails (more likely to be personal)
                // 3. Emails that appear earlier in the text
                emails.sort((a, b) => {
                    const aIsPersonal = !a.includes('noreply') && !a.includes('info') && !a.includes('contact');
                    const bIsPersonal = !b.includes('noreply') && !b.includes('info') && !b.includes('contact');
                    
                    if (aIsPersonal && !bIsPersonal) return -1;
                    if (!aIsPersonal && bIsPersonal) return 1;
                    
                    if (a.length !== b.length) return a.length - b.length;
                    
                    return text.indexOf(a) - text.indexOf(b);
                });
                
                return emails;
            }

            /**
             * Enhanced name extraction considering surrounding context with name dataset validation
             */
            extractNameWithContext(text) {
                const nameExtractor = new EfficientNameExtractor();
                const nameResult = nameExtractor.extractName(text);
                
                // If we found a high confidence name, validate with dataset
                if (nameResult.confidence >= 7) {
                    const validatedName = this.validateNameWithDataset(nameResult.name);
                    if (validatedName) {
                        return validatedName;
                    }
                    return nameResult.name;
                }
                
                // Fallback to context-based extraction
                const lines = text.split('\n').filter(line => line.trim().length > 2);
                
                // Try to find name near email or phone
                const emails = this.extractEmails(text);
                const phones = this.extractPhoneNumbers(text);
                
                // If we have email or phone, look for name in nearby lines
                if (emails.length > 0 || phones.length > 0) {
                    const referencePoints = [...emails, ...phones];
                    
                    for (const point of referencePoints) {
                        const pointIndex = text.indexOf(point);
                        if (pointIndex === -1) continue;
                        
                        // Get the line containing the reference point
                        let lineIndex = 0;
                        let currentPos = 0;
                        for (let i = 0; i < lines.length; i++) {
                            currentPos += lines[i].length + 1; // +1 for newline
                            if (currentPos > pointIndex) {
                                lineIndex = i;
                                break;
                            }
                        }
                        
                        // Check previous lines for name
                        for (let i = Math.max(0, lineIndex - 2); i <= Math.min(lines.length - 1, lineIndex + 1); i++) {
                            const line = lines[i];
                            const check = nameExtractor.extractName(line);
                            if (check.confidence >= 5) {
                                const validatedName = this.validateNameWithDataset(check.name);
                                if (validatedName) {
                                    return validatedName;
                                }
                                return check.name;
                            }
                        }
                    }
                }
                
                // Final fallback to the best name we found (even if low confidence)
                if (nameResult.name) {
                    const validatedName = this.validateNameWithDataset(nameResult.name);
                    if (validatedName) {
                        return validatedName;
                    }
                }
                return nameResult.name || '';
            }

            /**
             * Validate and correct name using the name dataset
             */
            validateNameWithDataset(extractedName) {
                if (!extractedName || extractedName.length < 2) return null;
                
                // Clean the extracted name
                const cleanName = extractedName.trim().toLowerCase();
                const nameParts = cleanName.split(/\s+/);
                
                // Name dataset (common Indian names)
                const nameDataset = [
                    'aaban', 'aabharan', 'aabhas', 'aabhat', 'aabheer', 'aabir', 'aabishan', 'aacharya', 'aachman', 'aadarsh', 'aadarshan', 'aadavan', 'aadesh', 'aadhan', 'aadhar', 'aadhav', 'aadhi', 'aadhidev', 'aadhil', 'aadhiraj', 'aadhiran', 'aadhish', 'aadhishankar', 'aadhithan', 'aadhithya', 'aaditya', 'aadvay', 'aadvik', 'aadyant', 'aafiya', 'aafreen', 'aaftab', 'aagash', 'aahaan', 'aahan', 'aahil', 'aahlaad', 'aahnik', 'aahvan', 'aajeevan', 'aakaar', 'aakaash', 'aakarsh', 'aakash', 'aakashi', 'aakshat', 'aalam', 'aalan', 'aalap', 'aalok', 'aamil', 'aamir', 'aamish', 'aamod', 'aamodh', 'aanand', 'aanandit', 'aananth', 'aansh', 'aapt', 'aapu', 'aaqib', 'aaqil', 'aaradhak', 'aaran', 'aarav', 'aarif', 'aarish', 'aarit', 'aarnab', 'aarnav', 'aarsh', 'aarth', 'aaryan', 'aaryav', 'aashang', 'aashank', 'aashay', 'aashir', 'aashish', 'aashlesh', 'aashman', 'aashray', 'aashresh', 'aashrith', 'aashrut', 'aashu', 'aashutosh', 'aasif', 'aasim', 'aasit', 'aastha', 'aastik', 'aasvi', 'aathan', 'aathavan', 'aathees', 'aathijeyan', 'aathikan', 'aathipan', 'aathiran', 'aathish', 'aathith', 'aathithan', 'aathrav', 'aatif', 'aatish', 'aatma', 'aatmaj', 'aatman', 'aatmanand', 'aatmaram', 'aatmay', 'aatmik', 'aatrey', 'aatreya', 'aavansh', 'aavanyan', 'aavarthan', 'aaveg', 'aavesh', 'aavi', 'aavish', 'aayam', 'aayan', 'aayansh', 'aayu', 'aayush', 'aayudh', 'aayus', 'aayushmaan', 'aazim', 'abaan', 'abadhya', 'abay', 'abayan', 'abbas', 'abbhinav', 'abbir', 'abbott', 'abbud', 'abdul', 'abdullah', 'abdus', 'abed', 'abedin', 'abeer', 'abel', 'abenayan', 'abezag', 'abhaidev', 'abhaijeet', 'abharajithan', 'abhas', 'abhav', 'abhay', 'abhayan', 'abhayananda', 'abhayanankar', 'abheek', 'abheesht', 'abheet', 'abhey', 'abhibhava', 'abhicandra', 'abhidharm', 'abhidhi', 'abhigyaan', 'abhiijaat', 'abhijan', 'abhijat', 'abhijay', 'abhijaya', 'abhijeet', 'abhijit', 'abhijith', 'abhijun', 'abhik', 'abhikam', 'abhilash', 'abhilesh', 'abhim', 'abhiman', 'abhimand', 'abhimani', 'abhimanyu', 'abhimath', 'abhimoda', 'abhinabhas', 'abhinand', 'abhinanda', 'abhinandan', 'abhinandana', 'abhinash', 'abhinatha', 'abhinav', 'abhinava', 'abhinay', 'abhineet', 'abhinesh', 'abhinit', 'abhinivesh', 'abhinuj', 'abhipuj', 'abhir', 'abhiraam', 'abhiraj', 'abhiral', 'abhiram', 'abhirath', 'abhiroop', 'abhirup', 'abhisar', 'abhisek', 'abhisheik', 'abhishek', 'abhishekita', 'abhishrey', 'abhisoka', 'abhisumat', 'abhisumath', 'abhisyanta', 'abhith', 'abhivaadan', 'abhivadan', 'abhivanth', 'abhivira', 'abhjeet', 'abhoy', 'abhra', 'abhrakasin', 'abhram', 'abhranila', 'abhu', 'abhya', 'abhyagni', 'abhyan', 'abhyank', 'abhypsit', 'abhyuday', 'abhyudaya', 'abhyudev', 'abhyudita', 'abid', 'abidin', 'abijith', 'abimanyu', 'abinash', 'abinav', 'abinay', 'abinayan', 'abinesh', 'abinish', 'abiram', 'abisali', 'abishek', 'abivanth', 'abjayoni', 'abjit', 'abner', 'abninayan', 'abra', 'abrad', 'abraham', 'abrar', 'abrash', 'abrik', 'abu', 'abul', 'acalapati', 'acalendra', 'acalesvara', 'acanda', 'acaryanandana', 'acaryasuta', 'acaryatanaya', 'acchindra', 'acchutan', 'achal', 'achalapati', 'achalendra', 'achalesvara', 'achalraj', 'achanda', 'achapal', 'acharya', 'acharyanandana', 'acharyasuta', 'achindra', 'achint', 'achintya', 'achuthan', 'achyut', 'achyuta', 'achyutam', 'achyutaraya', 'achyuth', 'achyuthan', 'acintya', 'acyutaraya', 'adalarachan', 'adalarasen', 'adalarasu', 'adam', 'adarsh', 'adavan', 'adbhutah', 'addison', 'adedev', 'adeel', 'adeela', 'adeem', 'adeep', 'adel', 'adenya', 'adesh', 'adeshwar', 'adham', 'adharsh', 'adharv', 'adhavan', 'adheer', 'adheesh', 'adhik', 'adhikara', 'adhinath', 'adhinav', 'adhip', 'adhipa', 'adhir', 'adhiraiyan', 'adhiraj', 'adhiratha', 'adhish', 'adhit', 'adhita', 'adhithya', 'adhitya', 'adhrit', 'adhrith', 'adhvait', 'adhvesh', 'adhvik', 'adhyan', 'adhyayan', 'adhyuth', 'adi', 'adib', 'adidev', 'adikavi', 'adikya', 'adil', 'adiman', 'adinath', 'adipurush', 'adipurusha', 'adisesh', 'adit', 'aditeya', 'adith', 'adithiya', 'adithya', 'aditiya', 'aditraj', 'aditya', 'adityaharicharan', 'adityakiran', 'adityanandan', 'adityanandana', 'adityavardhana', 'adiv', 'adiyaman', 'adler', 'adley', 'adlin', 'adnan', 'adotka', 'adrav', 'adrian', 'adrien', 'adrik', 'adripathi', 'adrish', 'adriyan', 'adrush', 'adtiya', 'advait', 'advaith', 'advay', 'advaya', 'advik', 'advit', 'adviteeya', 'advith', 'advitya', 'adwaid', 'adwait', 'adwaita', 'advaitha', 'adwaith', 'adway', 'adwaya', 'adwik', 'adwin', 'adyant', 'aedan', 'aiden', 'aekansh', 'aeshan', 'aeyush', 'afeef', 'aftab', 'aftaab', 'afzal', 'agam', 'agamiya', 'agampreet', 'aganit', 'aganveer', 'agarv', 'agarvin', 'agasthya', 'agasti', 'agathiyan', 'agavoli', 'agendra', 'agha', 'aghartha', 'aghat', 'aghor', 'aghornath', 'aghosh', 'agilan', 'agnello', 'agnes', 'agneya', 'aagneya', 'agnibahu', 'agnihotra', 'agnikumara', 'agnimitra', 'agniprava', 'agniras', 'agniv', 'agnivesh', 'agnivo', 'agraj', 'agrani', 'agrim', 'agrima', 'agriya', 'agustya', 'agyeya', 'ahaan', 'ahachcudar', 'ahad', 'ahaliyan', 'ahalyan', 'ahamathi', 'ahamynthan', 'ahan', 'ahanaeyan', 'ahankar', 'ahanyan', 'ahar', 'aharan', 'aharathan', 'aharihan', 'aharijan', 'aharshi', 'aharsi', 'ahaventhan', 'ahi', 'ahijit', 'ahil', 'ahilan', 'ahim', 'ahin', 'ahir', 'ahlad', 'ahmad', 'ahnay', 'ahren', 'ahrooran', 'ahruran', 'ahsan', 'ahti', 'aiden', 'aifa', 'aijaz', 'aiken', 'ail', 'aiman', 'ainesh', 'ainitosh', 'airaawat', 'airawat', 'eirawat', 'erawat', 'irawat', 'airavath', 'airawat', 'aishwa', 'aiyan', 'aiyappa', 'aiyyapa', 'ajaat', 'ajaatshatru', 'ajatshatru', 'ajah', 'ajahni', 'ajai', 'ajaipal', 'ajamil', 'ajan', 'ajanma', 'ajanthan', 'ajanya', 'ajat', 'ajatashatru', 'ajathasathru', 'ajatshatru', 'ajay', 'ajayan', 'ajeesh', 'ajeet', 'ajendra', 'ajesh', 'ajinkya', 'ajish', 'ajisth', 'ajit', 'ajitaabh', 'ajitabh', 'ajitesh', 'ajith', 'ajithabh', 'ajithesh', 'ajkhyat', 'ajmal', 'ajmil', 'ajneesh', 'ajoy', 'akal', 'akaldeep', 'akalin', 'akaljot', 'akalmash', 'akalnivas', 'akalpa', 'akalpreet', 'akalroop', 'akalsharan', 'akalsimar', 'akalsukh', 'akand', 'akansh', 'akanshit', 'akarsh', 'akash', 'akashdeep', 'akashini', 'akathiyan', 'akbar', 'akeem', 'akendra', 'akhalesh', 'akhand', 'akharsh', 'akhas', 'akhil', 'akhilash', 'akhilesh', 'akhileshwar', 'akhileswar', 'akhsaj', 'akhtar', 'akhurath', 'akhyath', 'akif', 'akil', 'akilan', 'akilesh', 'akira', 'akkamma', 'akkrum', 'akmal', 'akram', 'akaram', 'akrash', 'akrish', 'akrit', 'akroor', 'akruti', 'aksh', 'akshad', 'akshagna', 'akshahantre', 'akshaj', 'akshan', 'akshansh', 'akshant', 'akshar', 'aksharan', 'akshat', 'akshath', 'akshay', 'akshaya', 'akshayan', 'akshaykeerti', 'akshey', 'akshit', 'akshith', 'akshobhya', 'akshu', 'akshun', 'akshyan', 'akshyat', 'akul', 'ala', 'alaa', 'alaap', 'alabhya', 'alagan', 'alagappan', 'alagarasu', 'alagen', 'alaginiyan', 'alagiri', 'alahan', 'alakeshan', 'alakeshwaran', 'alakshendra', 'alamgir', 'alampata', 'alan', 'allan', 'alankar', 'alankrit', 'alarka', 'alastair', 'albern', 'albert', 'albion', 'alden', 'aldis', 'aldrich', 'alec', 'aleem', 'alek', 'alexander', 'alfie', 'alfred', 'algernon', 'alhad', 'alhasan', 'alhusain', 'alhusayn', 'ali', 'alice', 'alif', 'alin', 'alipta', 'allah', 'allaiyamuthan', 'allappariyan', 'alman', 'almir', 'alok', 'alok', 'aalok', 'aloke', 'alokendra', 'alolupan', 'alop', 'alpesh', 'alpha', 'alpit', 'alston', 'altaf', 'altair', 'alton', 'alvin', 'amaan', 'amaanat', 'amaar', 'amaay', 'amad', 'amadhya', 'amain', 'amaithipriyan', 'amaiyaran', 'amal', 'amalendu', 'amalesh', 'amam', 'aman', 'amanat', 'amanath', 'amanbir', 'amandeep', 'amandev', 'amaneesh', 'amanjeet', 'amanpal', 'amanpreet', 'amapramaadhy', 'amar', 'amaradhevan', 'amaran', 'amaranaath', 'amarnath', 'amaranayagan', 'amardeep', 'amardev', 'amarender', 'amarendra', 'amaresh', 'amarinder', 'amaris', 'amarjeet', 'amarjot', 'amarleen', 'amarnath', 'amarpreet', 'amarshayan', 'amarthevan', 'amartya', 'amav', 'amay', 'ambadi', 'ambak', 'ambalavan', 'ambar', 'ambareesh', 'ambarish', 'ambav', 'amber', 'amberish', 'ambesh', 'ambhoj', 'ambikanath', 'ambikapathi', 'ambikeya', 'ambili', 'ambrose', 'ambud', 'ambuj', 'ambujakshan', 'ambunath', 'ameer', 'ameet', 'amer', 'amery', 'amet', 'amey', 'ameyaatmaa', 'ameyatma', 'amid', 'amil', 'amildhiniyan', 'amileigh', 'amin', 'ameen', 'amir', 'amirathan', 'amirtha', 'amirtharasan', 'amish', 'amit', 'amitab', 'amitabh', 'amitaabh', 'amitabha', 'amitav', 'amitava', 'amitay', 'amitbikram', 'amitesh', 'amith', 'amithran', 'amitiyoti', 'amitrasudan', 'amiy', 'amjad', 'amlan', 'amlangusum', 'amod', 'amogh', 'amoghah', 'amoghraj', 'amol', 'amolak', 'amolik', 'amoorta', 'amos', 'ampulli', 'amrik', 'amrinder', 'amrish', 'amrit', 'amritambu', 'amritaya', 'amrith', 'amrithash', 'amritpal', 'amrut', 'amruth', 'amrutheswar', 'amsan', 'amshu', 'amshul', 'amshuman', 'amuda', 'amudan', 'amudhan', 'amuk', 'amul', 'amuthan', 'amuthiniyan', 'amuthithan', 'amzad', 'an', 'anaad', 'anaadhrushya', 'anaadi', 'anaadih', 'anaan', 'anaathi', 'anadh', 'anadhi', 'anadi', 'anagh', 'anahath', 'anak', 'anakh', 'anakul', 'anal', 'anam', 'anamay', 'anamaya', 'anami', 'anamitra', 'anan', 'ananay', 'anand', 'aanand', 'ananda', 'anandaganesh', 'anandamay', 'anandan', 'anandh', 'anandhamurugan', 'anandhan', 'anandhu', 'anandsagar', 'anang', 'ananinay', 'ananmay', 'ananmaya', 'anant', 'anantachidrupamayam', 'anantadrishti', 'anantaguna', 'anantajeet', 'anantajit', 'ananth', 'anant', 'ananthaa', 'ananthan', 'ananthu', 'anantim', 'anantram', 'anany', 'ananye', 'ananyo', 'anash', 'anashay', 'anashin', 'anashwar', 'anashya', 'anathikan', 'anav', 'anaye', 'anbaenthi', 'anbalagan', 'anbarasan', 'anbarasu', 'anbazhagan', 'anbu', 'anbuchelvan', 'anbumadi', 'anbuselvan', 'anbushelvan', 'anchit', 'andeep', 'andrew', 'aneek', 'aneeq', 'anees', 'aneesh', 'aneeth', 'anek', 'anesh', 'angad', 'angada', 'angadan', 'angaj', 'angak', 'angamuthu', 'angara', 'angaran', 'angayapriyan', 'angiras', 'angith', 'angleen', 'angus', 'anhar', 'anidev', 'aniesh', 'aniij', 'anik', 'anikait', 'anikanchan', 'anikant', 'aniket', 'aniketh', 'anikt', 'anil', 'anilaabh', 'anilabh', 'anilan', 'anilesh', 'animan', 'animash', 'animesh', 'anindith', 'anindo', 'anindya', 'aniq', 'anirban', 'aniroodh', 'aniruddh', 'aniruddha', 'aniruddhan', 'anirudh', 'anirudhha', 'anirudra', 'anirudu', 'aniruth', 'anirvan', 'anirved', 'anirvin', 'anirvinya', 'anis', 'anish', 'anishk', 'anishvar', 'aniswar', 'anit', 'aniteja', 'aniv', 'anivardh', 'anjaan', 'anjak', 'anjal', 'anjan', 'anjanappa', 'anjaneya', 'anjas', 'anjasa', 'anjay', 'anjesh', 'anjik', 'anjish', 'anjor', 'anjum', 'anjuman', 'ankal', 'ankesh', 'ankit', 'ankith', 'ankolit', 'ankur', 'ankush', 'anmay', 'anmesh', 'anmol', 'anna', 'annanathan', 'anniruddha', 'annsh', 'annuabhuj', 'annul', 'anokha', 'anoob', 'anoop', 'anoor', 'anosh', 'anoush', 'anpalagan', 'anpalahan', 'anpalakan', 'anpan', 'anpukiniyan', 'anram', 'ansal', 'ansel', 'ansh', 'anshaan', 'anshak', 'anshal', 'anshin', 'anshit', 'anshrith', 'anshu', 'anshuk', 'anshul', 'anshum', 'anshuman', 'anshumaan', 'anshumat', 'ansil', 'ansu', 'ansuman', 'antam', 'antar', 'antarang', 'antareeksh', 'antariksh', 'anthamaan', 'anthaman', 'anthikan', 'anthony', 'anthudaran', 'antim', 'antrix', 'anubhab', 'anubhaj', 'anubhav', 'anubodh', 'anuchan', 'anuchana', 'anudarshan', 'anudeep', 'anudev', 'anugrah', 'anugya', 'anuh', 'anuha', 'anuj', 'anukash', 'anukrit', 'anukul', 'anul', 'anumit', 'anumodith', 'anunay', 'anup', 'anupam', 'anupreet', 'anuprit', 'anuraag', 'anurag', 'anuraag', 'anuraj', 'anuritha', 'anurodh', 'anuroop', 'anurup', 'anuroop', 'anush', 'anushahan', 'anushan', 'anushivan', 'anuthaman', 'anutharshan', 'anutosh', 'anuttam', 'anuvindha', 'anuyog', 'anvay', 'anveer', 'anvesh', 'anveshan', 'anvit', 'anvith', 'anwar', 'anwesh', 'anwit', 'anyah', 'anyang', 'anzan', 'apar', 'aparajeet', 'aparajit', 'aparant', 'aparichit', 'apasyu', 'apij', 'apoorv', 'appaji', 'apparajito', 'appu', 'apsaran', 'apure', 'apurti', 'apurv', 'apurva', 'apoorva', 'ara', 'araahan', 'arab', 'aradhy', 'araha', 'arahan', 'arakhsan', 'aralan', 'aram', 'arambhi', 'aranab', 'aranamuthan', 'aranmakan', 'aranyak', 'araon', 'arasu', 'arav', 'aravali', 'aravan', 'aravin', 'aravind', 'aravindan', 'aravindhan', 'aravinth', 'arawo', 'archak', 'archan', 'archat', 'archer', 'archibald', 'archin', 'archish', 'archishman', 'archit', 'archith', 'archuna', 'ardashir', 'ardhendu', 'arean', 'areehah', 'areen', 'aref', 'arif', 'arekh', 'aresh', 'arganesh', 'argha', 'arghya', 'arha', 'arhaan', 'arhan', 'arhant', 'arhat', 'ariez', 'arihaan', 'arihan', 'arihant', 'ariharan', 'arijeet', 'arijit', 'arin', 'arindam', 'arindham', 'arine', 'arinjay', 'arinjoy', 'arish', 'arishwaran', 'arit', 'arivahan', 'arivalagan', 'arivali', 'arivarasan', 'arivarasu', 'arivoli', 'arivolli', 'arivozhi', 'arivuchelvan', 'arivukumaran', 'arivumadhi', 'arivumani', 'arivunambi', 'arivuselvan', 'arivuththamil', 'ariyan', 'arjan', 'arjav', 'arjeeth', 'arjit', 'arju', 'arjun', 'arjuna', 'arjunan', 'arjune', 'arjunna', 'arjunnan', 'arjunnen', 'ark', 'arka', 'arkaj', 'arkash', 'arkesh', 'arkin', 'arkish', 'arksh', 'arlen', 'arman', 'arnab', 'arnad', 'arnav', 'arnesh', 'arnik', 'arnish', 'arnit', 'arnoh', 'arnold', 'arnon', 'arnrit', 'aroha', 'arohan', 'aroop', 'aroush', 'arpan', 'arpil', 'arpit', 'arravind', 'arravinth', 'arsalan', 'arsha', 'arshad', 'arshan', 'artabandhu', 'artagnan', 'artatrana', 'arth', 'artham', 'arthav', 'arthikan', 'arthin', 'arthish', 'arthit', 'arthur', 'arudhra', 'aruj', 'arujas', 'arul', 'arulan', 'arulchelvan', 'arulganeshan', 'arulkumar', 'arulmozhiselvan', 'arulmozhivarman', 'arulnithi', 'arumai', 'arumbu', 'arumin', 'arumugam', 'arumugan', 'arumugathamudhu', 'arumughan', 'arumukhan', 'arun', 'arunabh', 'arunachaleshwara', 'arunageethayan', 'arunan', 'arunesh', 'arungedan', 'arunkannan', 'arunmozhithevan', 'arunmozhivarman', 'arunoday', 'arunothayan', 'arunthavan', 'aruran', 'arush', 'arushan', 'arushanan', 'aruth', 'arva', 'arvalan', 'arvel', 'arvin', 'arvind', 'arvinda', 'arvindswamy', 'ary', 'arya', 'aryaa', 'aryaan', 'aryadit', 'aryadita', 'aryamaan', 'aryaman', 'aryan', 'aryaraj', 'aryasb', 'aryash', 'aryav', 'aryavan', 'aryaveer', 'asad', 'asaja', 'asas', 'asav', 'aseelah', 'aseem', 'asees', 'asgar', 'ashakiran', 'ashan', 'ashank', 'ashankit', 'ashanko', 'ashcharya', 'asheem', 'ashesh', 'ashik', 'ashimat', 'ashirvad', 'ashis', 'ashish', 'ashit', 'ashith', 'ashitosh', 'ashkan', 'ashkaran', 'ashlesh', 'ashman', 'ashmik', 'ashmit', 'ashmith', 'ashneel', 'asho', 'ashok', 'ashokan', 'ashooja', 'ashpan', 'ashraf', 'asraf', 'ashrav', 'ashravya', 'ashray', 'ashrit', 'ashrith', 'ashrut', 'ashsri', 'ashtavakra', 'ashu', 'ashuthosh', 'ashutosh', 'aashutosh', 'ashva', 'ashvad', 'ashvanth', 'ashvarya', 'ashvat', 'ashvath', 'ashvik', 'ashvin', 'ashvind', 'ashwaghosh', 'ashwant', 'ashwanth', 'ashwarth', 'ashwath', 'ashwatham', 'ashwathama', 'ashwatthama', 'ashwathama', 'ashwesh', 'ashwin', 'ashwinraj', 'asidhan', 'asim', 'asish', 'asit', 'asitvaran', 'aslam', 'aslan', 'aslesh', 'aslun', 'aslunak', 'aslunit', 'asmit', 'asmith', 'asner', 'asok', 'asokan', 'asotosa', 'aashutosh', 'asrith', 'astik', 'astitva', 'astitya', 'astrit', 'asuman', 'asvin', 'aswanth', 'aswantha', 'aswapn', 'aswathaama', 'aswin', 'aswinikumar', 'atal', 'atambhu', 'atanu', 'atas', 'atash', 'ateeksh', 'ateet', 'atharav', 'atharv', 'atharva', 'atharvan', 'atheesh', 'athi', 'athiban', 'athighashen', 'athikaya', 'athikunan', 'athinarayanan', 'athiraiyan', 'athirayan', 'athish', 'athishan', 'athishay', 'athishen', 'athithan', 'athitya', 'athiyen', 'athrava', 'athreya', 'athrv', 'athul', 'athyajat', 'ati', 'atikish', 'atiksh', 'atim', 'atimanav', 'atin', 'atish', 'atishay', 'atit', 'atiya', 'atma', 'atmadeep', 'atmaj', 'atmajyothi', 'atmakanth', 'atman', 'atmanand', 'atmananda', 'atmaprakash', 'atmaram', 'atmik', 'atraiu', 'atralarasu', 'atreya', 'atri', 'atul', 'atultejas', 'atulya', 'atun', 'atvar', 'atvi', 'atwater', 'atwood', 'aubrey', 'audvik', 'augadh', 'auniket', 'aurel', 'austin', 'avadh', 'avadhesh', 'avadhoot', 'avalok', 'avan', 'avaneesh', 'avanish', 'avaneeth', 'avanesh', 'avanindra', 'avanish', 'avanithan', 'avaraj', 'avas', 'avashesh', 'avasyu', 'avatar', 'avaya', 'avdhoot', 'avdhut', 'aveekshith', 'aveen', 'avery', 'avhimanyu', 'avi', 'avichal', 'avigyan', 'avijit', 'avik', 'avikalp', 'avikam', 'avikrish', 'avikrut', 'avikshit', 'avilash', 'avin', 'avinash', 'avinay', 'avinesh', 'avingha', 'avir', 'aviraaj', 'aviraj', 'aviral', 'avirat', 'avirbhav', 'avirup', 'avish', 'avishkar', 'aviyukta', 'avkash', 'avneesh', 'avnendra', 'avnesh', 'avniel', 'avtar', 'avya', 'avyaansh', 'avyan', 'avyaya', 'avyayaprabhu', 'avyukt', 'avyukta', 'avyukth', 'awadhesh', 'awan', 'awas', 'awdhesh', 'awesh', 'axel', 'ayaan', 'ayaansh', 'ayan', 'ayank', 'ayansh', 'ayavanth', 'ayilyam', 'ayngaran', 'ayobaahu', 'ayodhya', 'ayog', 'ayub', 'ayudh', 'ayushmaan', 'ayushman', 'ayyan', 'ayyapan', 'ayyappa', 'ayyappadas', 'ayyappan', 'azad', 'azar', 'azeez', 'aziz', 'azhaar', 'azhagan', 'azhagar', 'azhagu', 'azhar'
                ];
                
                // Check if any part of the extracted name matches the dataset
                for (const namePart of nameParts) {
                    if (namePart.length < 2) continue;
                    
                    // Direct match
                    if (nameDataset.includes(namePart)) {
                        console.log(`Name validated with dataset: ${namePart} -> ${extractedName}`);
                        return extractedName;
                    }
                    
                    // Fuzzy match for common variations
                    const variations = this.generateNameVariations(namePart);
                    for (const variation of variations) {
                        if (nameDataset.includes(variation)) {
                            console.log(`Name corrected with dataset: ${namePart} -> ${variation}`);
                            return extractedName.replace(namePart, variation);
                        }
                    }
                }
                
                return null;
            }

            /**
             * Generate common name variations for fuzzy matching
             */
            generateNameVariations(name) {
                const variations = [];
                
                // Common spelling variations
                if (name.includes('aa')) variations.push(name.replace(/aa/g, 'a'));
                if (name.includes('a')) variations.push(name.replace(/a/g, 'aa'));
                if (name.includes('ee')) variations.push(name.replace(/ee/g, 'i'));
                if (name.includes('i')) variations.push(name.replace(/i/g, 'ee'));
                if (name.includes('oo')) variations.push(name.replace(/oo/g, 'u'));
                if (name.includes('u')) variations.push(name.replace(/u/g, 'oo'));
                
                // Common letter substitutions
                if (name.includes('c')) variations.push(name.replace(/c/g, 'k'));
                if (name.includes('k')) variations.push(name.push(name.replace(/k/g, 'c')));
                if (name.includes('ph')) variations.push(name.replace(/ph/g, 'f'));
                if (name.includes('f')) variations.push(name.replace(/f/g, 'ph'));
                
                // Remove common suffixes
                if (name.endsWith('an')) variations.push(name.slice(0, -2));
                if (name.endsWith('esh')) variations.push(name.slice(0, -3));
                if (name.endsWith('ish')) variations.push(name.slice(0, -3));
                
                return variations;
            }

            // EMAIL VALIDATION HELPER
            isValidEmail(email) {
                const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
                return emailRegex.test(email) && 
                       email.length >= 5 && 
                       email.length <= 254 &&
                       !email.includes('..') &&
                       !email.startsWith('.') &&
                       !email.endsWith('.');
            }

            // Enhanced OCR text extraction using the new optimized methods
            extractClientDataFromText(text) {
                console.log('Extracting client data from text:', text);
                const clientData = { name: '', email: '', phone: '', company: '', notes: '' };
                
                // Extract all possible emails and phones using optimized methods
                const allEmails = this.extractEmails(text);
                const allPhones = this.extractPhoneNumbers(text);
                
                // Select the best email and phone
                if (allEmails.length > 0) {
                    clientData.email = allEmails[0];
                    console.log('OCR found primary email:', clientData.email);
                    
                    // If we have multiple emails, add secondary to notes
                    if (allEmails.length > 1) {
                        clientData.notes = `Additional emails: ${allEmails.slice(1).join(', ')}`;
                        console.log('OCR found additional emails:', allEmails.slice(1));
                    }
                }
                
                if (allPhones.length > 0) {
                    clientData.phone = allPhones[0];
                    console.log('OCR found primary phone:', clientData.phone);
                    
                    // If we have multiple phones, add secondary to notes
                    if (allPhones.length > 1) {
                        const phoneNote = `Additional phones: ${allPhones.slice(1).join(', ')}`;
                        clientData.notes = clientData.notes 
                            ? `${clientData.notes}; ${phoneNote}`
                            : phoneNote;
                        console.log('OCR found additional phones:', allPhones.slice(1));
                    }
                }
                
                // Extract name with context awareness (lower threshold for OCR)
                const nameExtractor = new EfficientNameExtractor();
                const nameResult = nameExtractor.extractName(text);
                if (nameResult.name && nameResult.confidence >= 4) { // Lower threshold for OCR
                    clientData.name = nameResult.name;
                    console.log(`OCR name extraction: ${clientData.name} (confidence: ${nameResult.confidence})`);
                } else {
                    // Try context-based extraction for OCR
                    clientData.name = this.extractNameWithContext(text);
                    if (clientData.name) {
                        console.log('OCR found name with context:', clientData.name);
                    }
                }
                
                // Extract company (existing logic)
                const lines = text.split('\n').filter(line => line.trim().length > 2);
                const companyPatterns = [
                    /(.*?)\s+(Inc\.?|LLC|Corp\.?|Ltd\.?|Company|Co\.?|Corporation|Group|Solutions|Services|Technologies|Tech)(?!\w)/i,
                    /^[A-Z][a-zA-Z\s&]+(?:Inc\.?|LLC|Corp\.?|Ltd\.?)$/i
                ];
                
                for (const line of lines) {
                    const cleanLine = line.trim();
                    for (const pattern of companyPatterns) {
                        const match = cleanLine.match(pattern);
                        if (match && !clientData.company) {
                            clientData.company = match[0];
                            console.log('OCR found company:', clientData.company);
                            break;
                        }
                    }
                    if (clientData.company) break;
                }
                
                // If we have email but no name, try to extract name from email prefix
                if (clientData.email && !clientData.name) {
                    const emailPrefix = clientData.email.split('@')[0];
                    const nameFromEmail = emailPrefix
                        .replace(/[^a-zA-Z]/g, ' ')
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    if (nameFromEmail.split(' ').length <= 3) {
                        const nameCheck = nameExtractor.extractName(nameFromEmail);
                        if (nameCheck.confidence >= 3) { // Lower threshold for OCR
                            clientData.name = nameCheck.name;
                            console.log('OCR extracted name from email:', clientData.name);
                        }
                    }
                }
                
                console.log('Final extracted client data:', clientData);
                return clientData;
            }

            async analyzeImageWithOCR(imageData, source) {
                try {
                    console.log('Starting OCR analysis for source:', source);
                    this.showStatus('🤖 Performing text recognition...', 'info');
                    
                    const { data: { text } } = await Tesseract.recognize(imageData, 'eng', {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                this.showStatus(`🔍 OCR Progress: ${Math.round(m.progress * 100)}%`, 'info');
                            }
                        }
                    });
                    
                    console.log('OCR text extracted:', text);
                    const clientData = this.extractClientDataFromText(text);
                    console.log('Extracted client data:', clientData);
                    
                    // Allow adding if at least email, name, or phone is found
                    if (clientData.email || clientData.name || clientData.phone) {
                        console.log('Contact info found, adding client...');
                        await this.addClientWithLinkedInSearch(clientData, source);
                    } else {
                        console.log('No contact info found in OCR text');
                        this.showStatus('❌ No contact information found in the image. Please try manual entry.', 'error');
                    }
                } catch (error) {
                    console.error('OCR processing failed:', error);
                    this.showStatus('❌ OCR processing failed: ' + error.message, 'error');
                }
            }

            async addClientWithLinkedInSearch(clientData, source) {
                console.log('Adding client with data:', clientData, 'Source:', source);
                
                if (clientData.name) {
                    this.showStatus('🔍 Searching for LinkedIn profile...', 'info');
                    clientData.linkedIn = await this.findLinkedInProfile(clientData.name, clientData.company);
                }
                
                this.addClient({...clientData, source});
                this.showStatus(`✅ Client data extracted and added successfully! Source: ${source}`, 'success');
                console.log('Client added successfully');
            }

            async findLinkedInProfile(name, company = '') {
                try {
                    // Create LinkedIn search URL
                    const searchQuery = `${name} ${company}`.trim().replace(/\s+/g, '+');
                    const linkedInSearchURL = `https://www.linkedin.com/search/results/people/?keywords=${encodeURIComponent(searchQuery)}`;
                    
                    return linkedInSearchURL;
                } catch (error) {
                    console.log('LinkedIn search failed:', error);
                    return '';
                }
            }

            searchLinkedIn() {
                const name = document.getElementById('manualName').value;
                const company = document.getElementById('manualCompany').value;
                
                if (!name.trim()) {
                    this.showStatus('❌ Please enter a name to search LinkedIn', 'error');
                    return;
                }
                
                const searchQuery = `${name} ${company}`.trim().replace(/\s+/g, '+');
                const linkedInURL = `https://www.linkedin.com/search/results/people/?keywords=${encodeURIComponent(searchQuery)}`;
                
                document.getElementById('manualLinkedIn').value = linkedInURL;
                this.showStatus('🔗 LinkedIn search URL generated!', 'success');
                
                // Open LinkedIn search in new tab
                window.open(linkedInURL, '_blank');
            }

            handleManualEntry(event) {
                event.preventDefault();
                
                const clientData = {
                    name: document.getElementById('manualName').value.trim(),
                    email: document.getElementById('manualEmail').value.trim(),
                    phone: document.getElementById('manualPhone').value.trim(),
                    company: document.getElementById('manualCompany').value.trim(),
                    linkedIn: document.getElementById('manualLinkedIn').value.trim(),
                    source: 'Manual Entry'
                };
                
                if (!clientData.name && !clientData.email && !clientData.phone) {
                    this.showStatus('❌ Please fill in at least name, email, or phone number', 'error');
                    return;
                }
                
                // Validate email format
                if (clientData.email && !this.isValidEmail(clientData.email)) {
                    this.showStatus('❌ Please enter a valid email address', 'error');
                    return;
                }
                
                this.addClient(clientData);
                this.showStatus('✅ Client added successfully via manual entry!', 'success');
                
                // Clear form
                document.getElementById('manualForm').reset();
            }

            isValidEmail(email) {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                return emailRegex.test(email);
            }

            addClient(clientData) {
                const client = {
                    id: Date.now(),
                    ...clientData,
                    timestamp: new Date().toLocaleString()
                };
                
                this.clients.push(client);
                this.saveClients();
                this.updateClientsTable();
            }

            updateClientsTable() {
                const tbody = document.getElementById('clientsTableBody');
                const stats = document.getElementById('clientStats');
                
                tbody.innerHTML = '';
                
                if (this.clients.length === 0) {
                    tbody.innerHTML = `
                        <tr>
                            <td colspan="9" style="text-align: center; padding: 40px; opacity: 0.7;">
                                📭 No clients added yet. Start scanning or add manually!
                            </td>
                        </tr>
                    `;
                } else {
                    this.clients.forEach((client, index) => {
                        const row = tbody.insertRow();
                        const sourceClass = client.source.toLowerCase().includes('qr') ? 'source-qr' : 
                                          client.source.toLowerCase().includes('ocr') ? 'source-ocr' : 'source-manual';
                        
                        row.innerHTML = `
                            <td><strong>${index + 1}</strong></td>
                            <td>${client.name || '<em>N/A</em>'}</td>
                            <td>${client.email || '<em>N/A</em>'}</td>
                            <td>${client.phone || '<em>N/A</em>'}</td>
                            <td>${client.company || '<em>N/A</em>'}</td>
                            <td>${client.linkedIn ? `<a href="${client.linkedIn}" target="_blank" class="linkedin-link">🔗 LinkedIn</a>` : '<em>N/A</em>'}</td>
                            <td><span class="source-badge ${sourceClass}">${client.source}</span></td>
                            <td>${client.timestamp}</td>
                            <td>
                                <button class="btn btn-sm btn-primary edit-btn" data-index="${index}">
                                    <i class="fas fa-edit"></i> Edit
                                </button>
                            </td>
                            <td>
                                <button class="btn btn-sm btn-danger delete-btn" data-index="${index}" title="Delete this record">
                                    ❌ Delete
                                </button>
                            </td>
                        `;
                        
                        row.style.animation = 'fadeInUp 0.5s ease-out';
                    });
                }
                
                // Update stats
                const qrCount = this.clients.filter(c => c.source.toLowerCase().includes('qr')).length;
                const ocrCount = this.clients.filter(c => c.source.toLowerCase().includes('ocr')).length;
                const manualCount = this.clients.filter(c => c.source === 'Manual Entry').length;
                
                stats.innerHTML = `
                    📊 Total: ${this.clients.length} | 
                    📱 QR: ${qrCount} | 
                    🤖 OCR: ${ocrCount} | 
                    ✍️ Manual: ${manualCount}
                `;
                
                // Add event listeners for edit buttons
                document.querySelectorAll('.edit-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.closest('.edit-btn').dataset.index);
                        console.log('Edit button clicked for index:', index);
                        this.editClient(index);
                    });
                });

                // Add event listeners for delete buttons
                document.querySelectorAll('.delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.closest('.delete-btn').dataset.index);
                        console.log('Delete button clicked for index:', index);
                        this.deleteClient(index);
                    });
                });
            }

            exportToCSV() {
                if (this.clients.length === 0) {
                    this.showStatus('❌ No data to export', 'error');
                    return;
                }
                
                const headers = ['Name', 'Email', 'Phone', 'Company', 'LinkedIn', 'Source', 'Timestamp'];
                const csvContent = [
                    headers.join(','),
                    ...this.clients.map(client => [
                        `"${(client.name || '').replace(/"/g, '""')}"`,
                        `"${(client.email || '').replace(/"/g, '""')}"`,
                        `"${(client.phone || '').replace(/"/g, '""')}"`,
                        `"${(client.company || '').replace(/"/g, '""')}"`,
                        `"${(client.linkedIn || '').replace(/"/g, '""')}"`,
                        `"${client.source.replace(/"/g, '""')}"`,
                        `"${client.timestamp.replace(/"/g, '""')}"`
                    ].join(','))
                ].join('\n');
                
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `exhibition-clients-${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                this.showStatus('📊 Data exported successfully!', 'success');
            }

            deleteClient(index) {
                if (index < 0 || index >= this.clients.length) {
                    this.showStatus('❌ Invalid client index', 'error');
                    return;
                }

                const client = this.clients[index];
                const confirmDelete = confirm(`Are you sure you want to delete ${client.name || 'this client'}?`);
                
                if (confirmDelete) {
                    this.clients.splice(index, 1);
                    this.saveClients();
                    this.updateClientsTable();
                    this.showStatus(`🗑️ Deleted client: ${client.name || 'Unknown'}`, 'success');
                }
            }

            clearAllData() {
                if (this.clients.length === 0) {
                    this.showStatus('❌ No data to clear', 'error');
                    return;
                }
                
                if (confirm(`🗑️ Are you sure you want to clear all ${this.clients.length} client records? This action cannot be undone.`)) {
                    this.clients = [];
                    this.saveClients();
                    this.updateClientsTable();
                    this.showStatus('🗑️ All client data cleared', 'info');
                }
            }

            loadClients() {
                try {
                    const stored = localStorage.getItem('exhibitionCardReaderClients');
                    return stored ? JSON.parse(stored) : [];
                } catch (error) {
                    console.error('Error loading clients:', error);
                    return [];
                }
            }

            saveClients() {
                try {
                    localStorage.setItem('exhibitionCardReaderClients', JSON.stringify(this.clients));
                    console.log('Clients saved to localStorage:', this.clients.length);
                } catch (error) {
                    console.error('Error saving clients:', error);
                }
            }

            showStatus(message, type) {
                const statusEl = document.getElementById('statusMessage');
                statusEl.innerHTML = `<div class="status-message ${type}">${message}</div>`;
                
                // Auto-hide success and info messages after 5 seconds
                if (type === 'success' || type === 'info') {
                    setTimeout(() => {
                        if (statusEl.innerHTML.includes(message)) {
                            statusEl.innerHTML = '';
                        }
                    }, 5000);
                }
            }

            showProcessing(show) {
                document.getElementById('processing').style.display = show ? 'block' : 'none';
            }

            // ===== IMAGE EDITOR METHODS =====
            
            initializeImageEditor() {
                this.editorCanvas = document.getElementById('editorCanvas');
                this.editorCtx = this.editorCanvas.getContext('2d');
                this.cropOverlay = document.getElementById('cropOverlay');
                
                // Set up canvas event listeners for cropping
                this.editorCanvas.addEventListener('mousedown', (e) => this.handleCropMouseDown(e));
                this.editorCanvas.addEventListener('mousemove', (e) => this.handleCropMouseMove(e));
                this.editorCanvas.addEventListener('mouseup', (e) => this.handleCropMouseUp(e));
                
                // Touch events for mobile
                this.editorCanvas.addEventListener('touchstart', (e) => this.handleCropTouchStart(e));
                this.editorCanvas.addEventListener('touchmove', (e) => this.handleCropTouchMove(e));
                this.editorCanvas.addEventListener('touchend', (e) => this.handleCropTouchEnd(e));
            }

            /**
             * Load image into editor
             */
            loadImageIntoEditor(imageFile) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            this.originalImage = img;
                            this.currentImage = img;
                            this.rotation = 0;
                            this.brightness = 0;
                            this.resetEditor();
                            this.renderImage();
                            this.showImageEditor();
                            resolve();
                        };
                        img.onerror = reject;
                        img.src = e.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(imageFile);
                });
            }

            /**
             * Show the image editor
             */
            showImageEditor() {
                document.getElementById('imageEditor').style.display = 'block';
                this.showStatus('🖼️ Image loaded in editor. Use the controls to enhance the image.', 'info');
            }

            /**
             * Hide the image editor
             */
            hideImageEditor() {
                document.getElementById('imageEditor').style.display = 'none';
            }

            /**
             * Render the current image with all applied effects
             */
            renderImage() {
                if (!this.currentImage) return;

                const canvas = this.editorCanvas;
                const ctx = this.editorCtx;
                
                // Calculate dimensions to fit in canvas while maintaining aspect ratio
                const maxWidth = 600;
                const maxHeight = 400;
                const scale = Math.min(maxWidth / this.currentImage.width, maxHeight / this.currentImage.height);
                
                canvas.width = this.currentImage.width * scale;
                canvas.height = this.currentImage.height * scale;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Apply rotation
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate((this.rotation * Math.PI) / 180);
                
                // Apply brightness filter
                if (this.brightness !== 0) {
                    ctx.filter = `brightness(${100 + parseInt(this.brightness)}%)`;
                }
                
                // Draw image
                ctx.drawImage(
                    this.currentImage,
                    -canvas.width / 2,
                    -canvas.height / 2,
                    canvas.width,
                    canvas.height
                );
                
                ctx.restore();
            }

            /**
             * Toggle crop mode
             */
            toggleCropMode() {
                this.isCropping = !this.isCropping;
                const cropBtn = document.getElementById('cropBtn');
                const applyBtn = document.getElementById('applyCropBtn');
                const cancelBtn = document.getElementById('cancelCropBtn');
                
                if (this.isCropping) {
                    cropBtn.textContent = 'Cancel Selection';
                    cropBtn.classList.add('active');
                    applyBtn.style.display = 'inline-block';
                    cancelBtn.style.display = 'inline-block';
                    this.editorCanvas.style.cursor = 'crosshair';
                    this.showStatus('✂️ Click and drag to select crop area', 'info');
                } else {
                    cropBtn.textContent = 'Select Area';
                    cropBtn.classList.remove('active');
                    applyBtn.style.display = 'none';
                    cancelBtn.style.display = 'none';
                    this.editorCanvas.style.cursor = 'default';
                    this.hideCropOverlay();
                }
            }

            /**
             * Handle crop mouse down
             */
            handleCropMouseDown(e) {
                if (!this.isCropping) return;
                
                const rect = this.editorCanvas.getBoundingClientRect();
                this.cropStart = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                this.cropEnd = { ...this.cropStart };
                this.showCropOverlay();
            }

            /**
             * Handle crop mouse move
             */
            handleCropMouseMove(e) {
                if (!this.isCropping || !this.cropStart) return;
                
                const rect = this.editorCanvas.getBoundingClientRect();
                this.cropEnd = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                this.updateCropOverlay();
            }

            /**
             * Handle crop mouse up
             */
            handleCropMouseUp(e) {
                if (!this.isCropping) return;
                // Crop selection is complete, user can now apply or cancel
            }

            /**
             * Handle touch events for mobile
             */
            handleCropTouchStart(e) {
                if (!this.isCropping) return;
                e.preventDefault();
                const touch = e.touches[0];
                const rect = this.editorCanvas.getBoundingClientRect();
                this.cropStart = {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
                this.cropEnd = { ...this.cropStart };
                this.showCropOverlay();
            }

            handleCropTouchMove(e) {
                if (!this.isCropping || !this.cropStart) return;
                e.preventDefault();
                const touch = e.touches[0];
                const rect = this.editorCanvas.getBoundingClientRect();
                this.cropEnd = {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
                this.updateCropOverlay();
            }

            handleCropTouchEnd(e) {
                if (!this.isCropping) return;
                e.preventDefault();
            }

            /**
             * Show crop overlay
             */
            showCropOverlay() {
                this.cropOverlay.style.display = 'block';
            }

            /**
             * Hide crop overlay
             */
            hideCropOverlay() {
                this.cropOverlay.style.display = 'none';
                this.cropStart = null;
                this.cropEnd = null;
            }

            /**
             * Update crop overlay position and size
             */
            updateCropOverlay() {
                if (!this.cropStart || !this.cropEnd) return;
                
                const left = Math.min(this.cropStart.x, this.cropEnd.x);
                const top = Math.min(this.cropStart.y, this.cropEnd.y);
                const width = Math.abs(this.cropEnd.x - this.cropStart.x);
                const height = Math.abs(this.cropEnd.y - this.cropStart.y);
                
                this.cropOverlay.style.left = left + 'px';
                this.cropOverlay.style.top = top + 'px';
                this.cropOverlay.style.width = width + 'px';
                this.cropOverlay.style.height = height + 'px';
            }

            /**
             * Apply crop to image
             */
            applyCrop() {
                if (!this.cropStart || !this.cropEnd) return;
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Calculate crop dimensions
                const left = Math.min(this.cropStart.x, this.cropEnd.x);
                const top = Math.min(this.cropStart.y, this.cropEnd.y);
                const width = Math.abs(this.cropEnd.x - this.cropStart.x);
                const height = Math.abs(this.cropEnd.y - this.cropStart.y);
                
                // Set canvas size to crop dimensions
                canvas.width = width;
                canvas.height = height;
                
                // Draw cropped portion
                ctx.drawImage(
                    this.editorCanvas,
                    left, top, width, height,
                    0, 0, width, height
                );
                
                // Create new image from cropped canvas
                const croppedImage = new Image();
                croppedImage.onload = () => {
                    this.currentImage = croppedImage;
                    this.rotation = 0; // Reset rotation after crop
                    this.renderImage();
                    this.hideCropOverlay();
                    this.toggleCropMode(); // Exit crop mode
                    this.showStatus('✅ Image cropped successfully', 'success');
                };
                croppedImage.src = canvas.toDataURL();
            }

            /**
             * Cancel crop operation
             */
            cancelCrop() {
                this.hideCropOverlay();
                this.toggleCropMode();
            }

            /**
             * Adjust brightness
             */
            adjustBrightness(value) {
                this.brightness = parseInt(value);
                document.getElementById('brightnessValue').textContent = this.brightness + '%';
                this.renderImage();
            }

            /**
             * Rotate image
             */
            rotateImage(degrees) {
                this.rotation += degrees;
                this.renderImage();
                this.showStatus(`🔄 Image rotated ${degrees > 0 ? '+' : ''}${degrees}°`, 'info');
            }

            /**
             * Reset rotation
             */
            resetRotation() {
                this.rotation = 0;
                this.renderImage();
                this.showStatus('🔄 Rotation reset', 'info');
            }

            /**
             * Reset all editor changes
             */
            resetEditor() {
                this.currentImage = this.originalImage;
                this.rotation = 0;
                this.brightness = 0;
                this.hideCropOverlay();
                this.toggleCropMode(); // Exit crop mode if active
                
                // Reset UI
                document.getElementById('brightnessSlider').value = 0;
                document.getElementById('brightnessValue').textContent = '0%';
                
                this.renderImage();
                this.showStatus('🔄 Editor reset to original image', 'info');
            }

            /**
             * Process the edited image
             */
            async processEditedImage() {
                if (!this.currentImage) {
                    this.showStatus('❌ No image to process', 'error');
                    return;
                }
                
                this.showStatus('🔍 Processing edited image...', 'info');
                
                // Convert canvas to blob
                const canvas = this.editorCanvas;
                canvas.toBlob(async (blob) => {
                    if (blob) {
                        try {
                            console.log('Processing edited image blob:', blob.size, 'bytes');
                            
                            // Try QR scan first
                            let qrText = null;
                            try {
                                const html5QrCodeFile = new Html5Qrcode();
                                qrText = await html5QrCodeFile.scanFile(blob, true);
                                console.log('QR scan result:', qrText);
                            } catch (qrError) {
                                console.log('QR scan failed, trying OCR:', qrError);
                                // QR scan failed, continue to OCR
                            }
                            
                            if (qrText) {
                                console.log('QR code found, processing...');
                                const contactFound = await this.processQRResult(qrText, 'Edited Image QR');
                                if (!contactFound) {
                                    // QR found but no contact info, run OCR
                                    console.log('QR found but no contact info, running OCR...');
                                    await this.analyzeImageWithOCR(canvas.toDataURL(), 'Edited Image OCR');
                                }
                            } else {
                                // No QR found, run OCR
                                console.log('No QR found, running OCR...');
                                this.showStatus('🔄 No QR found, running OCR on edited image...', 'info');
                                await this.analyzeImageWithOCR(canvas.toDataURL(), 'Edited Image OCR');
                            }
                            
                            // Hide editor after processing
                            this.hideImageEditor();
                            
                        } catch (error) {
                            console.error('Error processing edited image:', error);
                            this.showStatus('❌ Error processing edited image: ' + error.message, 'error');
                        }
                    } else {
                        this.showStatus('❌ Failed to create image from editor', 'error');
                    }
                }, 'image/jpeg', 0.9);
            }

            /**
             * Test method for debugging process image functionality
             */
            async testProcessImage() {
                console.log('Test process image called');
                this.showStatus('🧪 Testing process image functionality...', 'info');
                
                if (!this.currentImage) {
                    this.showStatus('❌ No image loaded for testing', 'error');
                    return;
                }
                
                try {
                    // Test with a simple OCR first
                    const canvas = this.editorCanvas;
                    const imageDataUrl = canvas.toDataURL('image/jpeg', 0.9);
                    
                    console.log('Testing with image data URL:', imageDataUrl.substring(0, 100) + '...');
                    
                    // Test OCR directly
                    await this.analyzeImageWithOCR(imageDataUrl, 'Test Process');
                    
                } catch (error) {
                    console.error('Test process failed:', error);
                    this.showStatus('❌ Test process failed: ' + error.message, 'error');
                }
            }

            editClient(index) {
                const client = this.clients[index];
                if (!client) return;
                
                // Create and show edit modal with better styling
                const modal = document.createElement('div');
                modal.className = 'edit-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 9999;
                    backdrop-filter: blur(5px);
                `;
                
                modal.innerHTML = `
                    <div class="edit-modal-content" style="
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        border-radius: 20px;
                        padding: 0;
                        width: 90%;
                        max-width: 500px;
                        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                        border: 2px solid rgba(255,255,255,0.1);
                        backdrop-filter: blur(10px);
                    ">
                        <div style="
                            background: rgba(255,255,255,0.1);
                            padding: 25px 30px;
                            border-radius: 18px 18px 0 0;
                            border-bottom: 1px solid rgba(255,255,255,0.2);
                        ">
                            <h3 style="
                                color: white;
                                margin: 0;
                                font-size: 1.5rem;
                                font-weight: 600;
                                display: flex;
                                align-items: center;
                                gap: 10px;
                            ">
                                ✏️ Edit Client
                            </h3>
                        </div>
                        
                        <div style="padding: 30px;">
                            <form id="editClientForm">
                                <div style="margin-bottom: 20px;">
                                    <label style="
                                        color: white;
                                        font-weight: 600;
                                        margin-bottom: 8px;
                                        display: block;
                                        font-size: 0.9rem;
                                    ">👤 Name *</label>
                                    <input type="text" class="edit-input" id="editName" value="${client.name || ''}" required style="
                                        width: 100%;
                                        padding: 12px 15px;
                                        border: 2px solid rgba(255,255,255,0.2);
                                        border-radius: 10px;
                                        background: rgba(255,255,255,0.1);
                                        color: white;
                                        font-size: 1rem;
                                        transition: all 0.3s ease;
                                    " placeholder="Enter full name">
                                </div>
                                
                                <div style="margin-bottom: 20px;">
                                    <label style="
                                        color: white;
                                        font-weight: 600;
                                        margin-bottom: 8px;
                                        display: block;
                                        font-size: 0.9rem;
                                    ">📧 Email</label>
                                    <input type="email" class="edit-input" id="editEmail" value="${client.email || ''}" style="
                                        width: 100%;
                                        padding: 12px 15px;
                                        border: 2px solid rgba(255,255,255,0.2);
                                        border-radius: 10px;
                                        background: rgba(255,255,255,0.1);
                                        color: white;
                                        font-size: 1rem;
                                        transition: all 0.3s ease;
                                    " placeholder="Enter email address">
                                </div>
                                
                                <div style="margin-bottom: 20px;">
                                    <label style="
                                        color: white;
                                        font-weight: 600;
                                        margin-bottom: 8px;
                                        display: block;
                                        font-size: 0.9rem;
                                    ">📞 Phone</label>
                                    <input type="tel" class="edit-input" id="editPhone" value="${client.phone || ''}" style="
                                        width: 100%;
                                        padding: 12px 15px;
                                        border: 2px solid rgba(255,255,255,0.2);
                                        border-radius: 10px;
                                        background: rgba(255,255,255,0.1);
                                        color: white;
                                        font-size: 1rem;
                                        transition: all 0.3s ease;
                                    " placeholder="Enter phone number">
                                </div>
                                
                                <div style="margin-bottom: 20px;">
                                    <label style="
                                        color: white;
                                        font-weight: 600;
                                        margin-bottom: 8px;
                                        display: block;
                                        font-size: 0.9rem;
                                    ">🏢 Company</label>
                                    <input type="text" class="edit-input" id="editCompany" value="${client.company || ''}" style="
                                        width: 100%;
                                        padding: 12px 15px;
                                        border: 2px solid rgba(255,255,255,0.2);
                                        border-radius: 10px;
                                        background: rgba(255,255,255,0.1);
                                        color: white;
                                        font-size: 1rem;
                                        transition: all 0.3s ease;
                                    " placeholder="Enter company name">
                                </div>
                                
                                <div style="margin-bottom: 25px;">
                                    <label style="
                                        color: white;
                                        font-weight: 600;
                                        margin-bottom: 8px;
                                        display: block;
                                        font-size: 0.9rem;
                                    ">🔗 LinkedIn</label>
                                    <input type="url" class="edit-input" id="editLinkedin" value="${client.linkedIn || ''}" style="
                                        width: 100%;
                                        padding: 12px 15px;
                                        border: 2px solid rgba(255,255,255,0.2);
                                        border-radius: 10px;
                                        background: rgba(255,255,255,0.1);
                                        color: white;
                                        font-size: 1rem;
                                        transition: all 0.3s ease;
                                    " placeholder="Enter LinkedIn URL">
                                </div>
                            </form>
                        </div>
                        
                        <div style="
                            padding: 20px 30px 30px;
                            display: flex;
                            gap: 15px;
                            justify-content: flex-end;
                        ">
                            <button type="button" class="edit-cancel-btn" onclick="this.closest('.edit-modal').remove()" style="
                                padding: 12px 25px;
                                border: 2px solid rgba(255,255,255,0.3);
                                border-radius: 10px;
                                background: rgba(255,255,255,0.1);
                                color: white;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                font-size: 0.9rem;
                            ">❌ Cancel</button>
                            <button type="button" class="edit-update-btn" style="
                                padding: 12px 25px;
                                border: none;
                                border-radius: 10px;
                                background: linear-gradient(135deg, #00c851, #007e33);
                                color: white;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                font-size: 0.9rem;
                                box-shadow: 0 4px 15px rgba(0,200,81,0.3);
                            ">✅ Update Client</button>
                            <button type="button" class="update-btn" data-index="${index}" style="display: none;"></button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Add hover effects for inputs
                const inputs = modal.querySelectorAll('.edit-input');
                inputs.forEach(input => {
                    input.addEventListener('focus', () => {
                        input.style.borderColor = 'rgba(255,255,255,0.5)';
                        input.style.background = 'rgba(255,255,255,0.15)';
                    });
                    input.addEventListener('blur', () => {
                        input.style.borderColor = 'rgba(255,255,255,0.2)';
                        input.style.background = 'rgba(255,255,255,0.1)';
                    });
                });
                
                // Add hover effects for buttons
                const cancelBtn = modal.querySelector('.edit-cancel-btn');
                const updateBtn = modal.querySelector('.edit-update-btn');
                const hiddenUpdateBtn = modal.querySelector('.update-btn');
                
                // Add click event for update button
                updateBtn.addEventListener('click', () => {
                    const index = parseInt(hiddenUpdateBtn.dataset.index);
                    console.log('Update button clicked for index:', index);
                    this.updateClient(index);
                });
                
                cancelBtn.addEventListener('mouseenter', () => {
                    cancelBtn.style.background = 'rgba(255,255,255,0.2)';
                    cancelBtn.style.borderColor = 'rgba(255,255,255,0.5)';
                });
                cancelBtn.addEventListener('mouseleave', () => {
                    cancelBtn.style.background = 'rgba(255,255,255,0.1)';
                    cancelBtn.style.borderColor = 'rgba(255,255,255,0.3)';
                });
                
                updateBtn.addEventListener('mouseenter', () => {
                    updateBtn.style.transform = 'translateY(-2px)';
                    updateBtn.style.boxShadow = '0 6px 20px rgba(0,200,81,0.4)';
                });
                updateBtn.addEventListener('mouseleave', () => {
                    updateBtn.style.transform = 'translateY(0)';
                    updateBtn.style.boxShadow = '0 4px 15px rgba(0,200,81,0.3)';
                });
                
                // Focus on first input
                setTimeout(() => {
                    document.getElementById('editName').focus();
                }, 100);
                
                // Close modal when clicking outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }
            
            updateClient(index) {
                const name = document.getElementById('editName').value.trim();
                const email = document.getElementById('editEmail').value.trim();
                const phone = document.getElementById('editPhone').value.trim();
                const company = document.getElementById('editCompany').value.trim();
                const linkedin = document.getElementById('editLinkedin').value.trim();
                
                if (!name) {
                    alert('Name is required!');
                    return;
                }
                
                // Update client data with all existing fields preserved
                const updatedClient = {
                    ...this.clients[index], // Preserve existing fields like source, timestamp, etc.
                    name: name,
                    email: email,
                    phone: phone,
                    company: company,
                    linkedIn: linkedin
                };
                
                // Update the client in the array
                this.clients[index] = updatedClient;
                
                // Save to localStorage
                this.saveClients();
                
                // Update display
                this.updateClientsTable();
                
                // Close modal
                document.querySelector('.modal').remove();
                
                // Show success message
                this.showStatus('✅ Client updated successfully!', 'success');
                
                console.log('Client updated:', updatedClient);
            }
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            try {
                new ExhibitionCardReaderPro();
                console.log('🚀 Exhibition Card Reader Pro initialized successfully!');
            } catch (error) {
                console.error('❌ Error initializing application:', error);
                document.body.innerHTML = `
                    <div style="text-align: center; padding: 50px; color: white;">
                        <h1>❌ Application Error</h1>
                        <p>Failed to initialize the card reader. Please refresh the page.</p>
                        <p style="font-size: 0.9rem; opacity: 0.8;">Error: ${error.message}</p>
                    </div>
                `;
            }
        });

        // Add some helpful keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        document.getElementById('startCamera').click();
                        break;
                    case 'e':
                        e.preventDefault();
                        document.getElementById('exportData').click();
                        break;
                }
            }
        });
    </script>
</body>
</html>