<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Honeyman ExhibitionCardReaderPro.">
    <title>Exhibition Card Reader Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        .background-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
            animation: fadeInDown 1s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 15px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.4);
            font-weight: 700;
            background: linear-gradient(45deg, #fff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.95;
            font-weight: 300;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1.2fr 0.8fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 25px;
            padding: 35px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
        }

        .card h2 {
            color: white;
            margin-bottom: 25px;
            font-size: 1.6rem;
            text-align: center;
            font-weight: 600;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .scanner-section {
            text-align: center;
        }

        .camera-container {
            position: relative;
            max-width: 100%;
            margin: 25px 0;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
            background: #000;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #video {
            width: 100%;
            height: auto;
            max-height: 400px;
            object-fit: cover;
            border-radius: 20px;
        }

        .camera-placeholder {
            color: rgba(255,255,255,0.7);
            font-size: 1.1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .camera-placeholder .icon {
            font-size: 3rem;
            opacity: 0.5;
        }

        #canvas {
            display: none;
        }

        .scanning-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(102, 126, 234, 0.1);
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: 20px;
        }

        .scanning-overlay.active {
            display: flex;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        .scan-line {
            width: 80%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ff00, transparent);
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateY(-100px); }
            100% { transform: translateY(100px); }
        }

        .upload-area {
            border: 3px dashed rgba(255,255,255,0.4);
            border-radius: 20px;
            padding: 40px 20px;
            text-align: center;
            margin: 25px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.05);
            color: white;
        }

        .upload-area:hover {
            border-color: rgba(255,255,255,0.8);
            background: rgba(255,255,255,0.1);
            transform: scale(1.02);
        }

        .upload-area.dragover {
            border-color: #00ff88;
            background: rgba(0,255,136,0.1);
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0,255,136,0.3);
        }

        .upload-area .icon {
            font-size: 2.5rem;
            margin-bottom: 15px;
            opacity: 0.8;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            margin: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .mode-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 0.9rem;
            padding: 8px 16px;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #00c851, #007e33);
            border-color: #00c851;
            box-shadow: 0 4px 15px rgba(0,200,81,0.3);
        }

        .mode-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
        }

        .mode-btn.active:hover {
            background: linear-gradient(135deg, #00d861, #008e43);
            box-shadow: 0 6px 20px rgba(0,200,81,0.4);
        }

        .btn.success {
            background: linear-gradient(135deg, #00c851, #007e33);
        }

        .btn.danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: white;
            font-size: 0.95rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .form-group input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 15px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.1);
            color: white;
            backdrop-filter: blur(10px);
        }

        .form-group input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .form-group input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
            background: rgba(255,255,255,0.15);
        }

        .clients-table {
            grid-column: 1 / -1;
            overflow-x: auto;
            animation: fadeInUp 1s ease-out 0.3s both;
        }

        .table-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .stats {
            background: rgba(255,255,255,0.1);
            padding: 15px 25px;
            border-radius: 15px;
            color: white;
            font-weight: 600;
            backdrop-filter: blur(10px);
            margin-left: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        th, td {
            padding: 15px 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: white;
        }

        th {
            background: linear-gradient(135deg, rgba(102,126,234,0.8), rgba(118,75,162,0.8));
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        tr:hover {
            background: rgba(255,255,255,0.1);
        }

        .linkedin-link {
            color: #00d4ff;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        .linkedin-link:hover {
            color: #00ff88;
            text-shadow: 0 0 5px rgba(0,255,136,0.5);
        }

        .status-message {
            padding: 20px;
            border-radius: 15px;
            margin: 15px 0;
            text-align: center;
            font-weight: 600;
            backdrop-filter: blur(10px);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .success {
            background: rgba(0, 200, 81, 0.2);
            color: #00ff88;
            border: 2px solid rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
        }

        .error {
            background: rgba(255, 68, 68, 0.2);
            color: #ff6b6b;
            border: 2px solid rgba(255, 107, 107, 0.3);
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.2);
        }

        .info {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            border: 2px solid rgba(0, 212, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        }

        .file-input {
            display: none;
        }

        .processing {
            display: none;
            text-align: center;
            padding: 30px;
            color: white;
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.2);
            border-top: 4px solid #00ff88;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .detection-info {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            color: white;
            font-size: 0.9rem;
            backdrop-filter: blur(5px);
        }

        .source-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin: 2px;
        }

        .source-qr {
            background: linear-gradient(135deg, #00c851, #007e33);
            color: white;
        }

        .source-ocr {
            background: linear-gradient(135deg, #ff8800, #cc6600);
            color: white;
        }

        .source-manual {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 25px;
            }
            
            .header h1 {
                font-size: 2.5rem;
            }
            
            .card {
                padding: 25px;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            table {
                font-size: 0.85rem;
            }
            
            th, td {
                padding: 10px 8px;
            }
            
            .table-controls {
                flex-direction: column;
            }
            
            .stats {
                margin-left: 0;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="background-animation"></div>
    
    <div class="container">
        <div class="header">
            <h1>🚀 Exhibition Card Reader Pro</h1>
            <p>Advanced QR & Business Card Scanner with AI-Powered Data Extraction</p>
        </div>

        <div class="main-content">
            <!-- Enhanced Scanner Section -->
            <div class="card">
                <h2>📱 Smart Scanner</h2>
                <div class="scanner-section">
                    <div id="qr-reader" style="width:100%;max-width:400px;margin:0 auto;"></div>
                        <div class="camera-placeholder" id="cameraPlaceholder">
                            <div class="icon">📷</div>
                            <div>Click "Start Camera" to begin scanning</div>
                        </div>
                    <div style="margin: 20px 0;">
                        <div class="scan-mode-buttons" style="margin-bottom: 15px; text-align: center;">
                            <button id="qrModeBtn" class="btn mode-btn active" style="margin-right: 10px;">🔲 QR Code Mode</button>
                            <button id="imageModeBtn" class="btn mode-btn" style="margin-left: 10px;">📄 Business Card Mode</button>
                        </div>
                        <div style="text-align: center;">
                            <button id="startCamera" class="btn">🔴 Start Camera</button>
                            <button id="captureImage" class="btn" disabled>📸 Capture & Analyze</button>
                        </div>
                    </div>
                    <div class="detection-info">
                        <strong>🤖 Smart Detection:</strong> 
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li><strong>QR Mode:</strong> Scans QR codes for vCard and contact data</li>
                            <li><strong>Business Card Mode:</strong> Captures and analyzes entire business card text</li>
                        </ul>
                        Automatically falls back to OCR if QR codes contain only links or error codes.
                    </div>
                </div>

                <div class="upload-area" id="uploadArea">
                    <div class="icon">📁</div>
                    <p><strong>Drag & Drop Images Here</strong></p>
                    <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 10px;">
                        Supports QR codes, business cards, and contact images
                    </p>
                    <input type="file" id="fileInput" class="file-input" accept="image/*">
                    <button class="btn" onclick="document.getElementById('fileInput').click()">
                        Choose File
                    </button>
                </div>

                <div class="processing" id="processing">
                    <div class="spinner"></div>
                    <p>🔍 Analyzing image and extracting contact data...</p>
                </div>

                <div id="statusMessage"></div>
            </div>

            <!-- Enhanced Manual Entry -->
            <div class="card">
                <h2>✍️ Manual Entry</h2>
                <form id="manualForm">
                    <div class="form-group">
                        <label for="manualName">👤 Full Name:</label>
                        <input type="text" id="manualName" placeholder="Enter client's full name">
                    </div>
                    
                    <div class="form-group">
                        <label for="manualEmail">📧 Email Address:</label>
                        <input type="email" id="manualEmail" placeholder="Enter email address">
                    </div>
                    
                    <div class="form-group">
                        <label for="manualPhone">📞 Phone Number:</label>
                        <input type="tel" id="manualPhone" placeholder="Enter phone number">
                    </div>
                    
                    <div class="form-group">
                        <label for="manualCompany">🏢 Company:</label>
                        <input type="text" id="manualCompany" placeholder="Enter company name (optional)">
                    </div>
                    
                    <div class="form-group">
                        <label for="manualLinkedIn">💼 LinkedIn Profile:</label>
                        <input type="url" id="manualLinkedIn" placeholder="LinkedIn profile URL (optional)">
                    </div>
                    
                    <div style="text-align: center; margin-top: 30px;">
                        <button type="submit" class="btn success">➕ Add Client</button>
                        <button type="button" id="searchLinkedIn" class="btn">🔍 Find LinkedIn</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Enhanced Clients Table -->
        <div class="card clients-table">
            <h2>👥 Collected Clients Database</h2>
            
            <div class="table-controls">
                <button id="exportData" class="btn success">📊 Export CSV</button>
                <button id="clearData" class="btn danger">🗑️ Clear All</button>
                <div class="stats" id="clientStats">
                    📊 Total Clients: 0
                </div>
            </div>
            
            <div style="overflow-x: auto;">
                <table id="clientsTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>👤 Name</th>
                            <th>📧 Email</th>
                            <th>📞 Phone</th>
                            <th>🏢 Company</th>
                            <th>💼 LinkedIn</th>
                            <th>🔍 Source</th>
                            <th>⏰ Added</th>
                            <th>🖊️ Edit</th>
                            <th>🗑️ Delete</th>
                        </tr>
                    </thead>
                    <tbody id="clientsTableBody">
                        <!-- Data will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Libraries -->
    <script src="https://unpkg.com/html5-qrcode"></script>
    <script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>

   <script>
    class EfficientNameExtractor {
    constructor() {
        // Define name patterns with scoring weights
        this.namePatterns = [
            // High confidence patterns (score: 10)
            { pattern: /^[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/, score: 10, description: "Standard First Last" },
            { pattern: /^[A-Z][a-z]{2,}\s+[A-Z]\.\s+[A-Z][a-z]{2,}$/, score: 10, description: "First M. Last" },
            { pattern: /^[A-Z]\.\s+[A-Z][a-z]{2,}$/, score: 9, description: "F. Last" },

            // Medium confidence patterns (score: 7-8)
            { pattern: /^[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/, score: 8, description: "First Middle Last" },
            { pattern: /^[A-Z][a-z]{2,}\s+[A-Z][a-z]+-[A-Z][a-z]{2,}$/, score: 7, description: "First Hyphen-Last" },
            { pattern: /^[A-Z][a-z]{2,}\s+[A-Z][a-z]+'[A-Z][a-z]{2,}$/, score: 7, description: "First O'Last" },

            // Title patterns (score: 8-9)
            { pattern: /^Dr\.\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/i, score: 9, description: "Dr. First Last" },
            { pattern: /^Mr\.\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/i, score: 9, description: "Mr. First Last" },
            { pattern: /^Ms\.\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/i, score: 9, description: "Ms. First Last" },
            { pattern: /^Mrs\.\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/i, score: 9, description: "Mrs. First Last" },

            // Lower confidence patterns (score: 5-6)
            { pattern: /^[A-Z]{2,}\s+[A-Z]{2,}$/, score: 6, description: "FIRST LAST" },
            { pattern: /^[A-Z][a-z]{1,}\s+[A-Z][a-z]{1,}$/, score: 5, description: "Short names" },
            { pattern: /^[A-Z][a-z]{2,}$/, score: 4, description: "Single name" },

            // Initials patterns (score: 6-7)
            { pattern: /^[A-Z]\.\s+[A-Z]\.\s+[A-Z][a-z]{2,}$/, score: 7, description: "A.B. Last" },
            { pattern: /^[A-Z][a-z]{2,}\s+[A-Z]\.\s+[A-Z]\.$/, score: 6, description: "First A.B." }
        ];

        // Common words that should be excluded from names
        this.excludeWords = new Set([
            'the', 'and', 'or', 'for', 'with', 'from', 'to', 'in', 'on', 'at', 'by', 'of', 'a', 'an',
            'inc', 'llc', 'corp', 'ltd', 'company', 'co', 'corporation', 'group', 'solutions',
            'services', 'technologies', 'tech', 'systems', 'associates', 'partners', 'consulting',
            'email', 'phone', 'tel', 'fax', 'mobile', 'cell', 'office', 'home', 'work',
            'address', 'street', 'avenue', 'road', 'drive', 'lane', 'blvd', 'suite', 'apt',
            'www', 'http', 'https', 'com', 'org', 'net', 'edu', 'gov', 'pvt', 'limited' // Added common company terms
        ]);

        // Common first names for additional validation (kept for context, can be expanded)
        this.commonFirstNames = new Set([
            'james', 'john', 'robert', 'michael', 'william', 'david', 'richard', 'joseph', 'thomas', 'christopher',
            'charles', 'daniel', 'matthew', 'anthony', 'mark', 'donald', 'steven', 'paul', 'andrew', 'joshua',
            'mary', 'patricia', 'jennifer', 'linda', 'elizabeth', 'barbara', 'susan', 'jessica', 'sarah', 'karen',
            'nancy', 'lisa', 'betty', 'helen', 'sandra', 'donna', 'carol', 'ruth', 'sharon', 'michelle'
        ]);
    }

    /**
     * Extract name with scoring system - main method
     */
    extractName(text) {
        if (!text || typeof text !== 'string') {
            return { name: '', confidence: 0, method: 'invalid_input' };
        }

        // Clean and prepare text
        const lines = this.preprocessText(text);
        if (lines.length === 0) {
            return { name: '', confidence: 0, method: 'no_lines' };
        }

        // Try different extraction methods in order of reliability
        const methods = [
            () => this.extractWithPatternMatching(lines),
            () => this.extractWithPositionalLogic(lines),
            () => this.extractWithHeuristics(lines)
        ];

        for (let i = 0; i < methods.length; i++) {
            const result = methods[i]();
            if (result.confidence >= 5) { // Minimum confidence threshold
                return result;
            }
        }

        return { name: '', confidence: 0, method: 'no_match' };
    }

    /**
     * Preprocess text into clean lines
     */
    preprocessText(text) {
        return text
            .split(/[\n\r]+/)
            .map(line => line.trim())
            .filter(line => {
                if (line.length < 2) return false;
                // Exclude lines that are clearly not names (e.g., contain @, URL, or start with digits)
                if (line.includes('@')) return false;
                if (/https?:\/\//.test(line)) return false;
                if (/^\+?\d[\d\s\-\(\)]{7,}/.test(line)) return false;
                if (/^\d+/.test(line)) return false;
                // Exclude lines with common business/contact terms that are not names
                const lowerLine = line.toLowerCase();
                if (this.excludeWords.has(lowerLine) || this.excludeWords.has(lowerLine.split(' ')[0])) return false;
                return true;
            })
            .slice(0, 8); // Consider only the first few lines for names
    }

    /**
     * Method 1: Pattern matching with scoring
     */
    extractWithPatternMatching(lines) {
        let bestMatch = { name: '', confidence: 0, method: 'pattern_matching' };

        for (const line of lines) {
            for (const { pattern, score, description } of this.namePatterns) {
                if (pattern.test(line)) {
                    let adjustedScore = score;

                    // Boost score if first name is common
                    const firstWord = line.split(/\s+/)[0].toLowerCase().replace(/[^a-z]/g, '');
                    if (this.commonFirstNames.has(firstWord)) {
                        adjustedScore += 2;
                    }

                    // Boost score if it's in the first few lines
                    const lineIndex = lines.indexOf(line);
                    if (lineIndex === 0) adjustedScore += 3;
                    else if (lineIndex === 1) adjustedScore += 2;
                    else if (lineIndex === 2) adjustedScore += 1;

                    // Penalty for very long lines
                    if (line.length > 40) adjustedScore -= 2;

                    // Penalty if line contains excluded words
                    const words = line.toLowerCase().split(/\s+/);
                    const hasExcludedWords = words.some(word => this.excludeWords.has(word));
                    if (hasExcludedWords) adjustedScore -= 3;

                    if (adjustedScore > bestMatch.confidence) {
                        bestMatch = {
                            name: line.trim(),
                            confidence: adjustedScore,
                            method: `pattern_matching_${description}`
                        };
                    }
                }
            }
        }

        return bestMatch;
    }

    /**
     * Method 2: Positional logic
     */
    extractWithPositionalLogic(lines) {
        for (let i = 0; i < Math.min(lines.length, 3); i++) {
            const line = lines[i];

            if (this.isLikelyName(line)) {
                let confidence = 6 - i;

                if (/^[A-Z][a-z]+\s+[A-Z][a-z]+$/.test(line)) {
                    confidence += 3;
                }

                return {
                    name: line.trim(),
                    confidence: confidence,
                    method: `positional_logic_line_${i + 1}`
                };
            }
        }

        return { name: '', confidence: 0, method: 'positional_logic' };
    }

    /**
     * Method 3: Heuristic-based extraction
     */
    extractWithHeuristics(lines) {
        const candidates = [];

        for (const line of lines) {
            if (this.isLikelyName(line)) {
                let score = 0;

                const wordCount = line.split(/\s+/).length;
                if (wordCount === 2) score += 4;
                else if (wordCount === 3) score += 3;
                else if (wordCount === 1) score += 1;
                else score -= 1;

                const words = line.split(/\s+/);
                const properlyCapitalized = words.every(word =>
                    /^[A-Z][a-z]*$/.test(word) || /^[A-Z]\.$/.test(word)
                );
                if (properlyCapitalized) score += 3;

                if (line.length >= 4 && line.length <= 30) score += 2;
                if (line.length > 40) score -= 3;

                const letterRatio = (line.match(/[a-zA-Z]/g) || []).length / line.length;
                if (letterRatio > 0.85) score += 2;

                candidates.push({
                    name: line.trim(),
                    confidence: Math.max(0, score),
                    method: 'heuristic_analysis'
                });
            }
        }

        candidates.sort((a, b) => b.confidence - a.confidence);
        return candidates[0] || { name: '', confidence: 0, method: 'heuristics' };
    }

    /**
     * Check if a line is likely to be a name
     */
    isLikelyName(line) {
        if (!line || line.length < 2 || line.length > 50) return false;

        // Allow common name characters and spaces, hyphens, apostrophes, dots for initials
        if (!/^[A-Za-z\s\.\-']+$/.test(line)) return false;

        // If line is all caps, it's less likely to be a name unless very short
        if (line === line.toUpperCase()) {
            const words = line.split(/\s+/);
            if (words.length > 3 || words.some(word => word.length > 8)) return false;
        }

        const words = line.toLowerCase().split(/\s+/);
        // Check if any word is in the exclude list
        if (words.some(word => this.excludeWords.has(word))) return false;

        // Too many words or very long words are less likely to be names
        if (words.length > 5 || words.some(word => word.length > 20)) return false;

        return true;
    }
}

class ExhibitionCardReaderPro {
    constructor() {
        this.clients = this.loadClients();
        this.html5QrCode = null;
        this.cameraStarted = false;
        this.lastScanResult = null; // To prevent duplicate QR scans from camera
        this.currentScanMode = 'qr'; // 'qr' or 'image'
        this.isCapturing = false; // Prevent multiple captures
        this.tesseractWorker = null; // Tesseract.js worker instance

        this.initializeEventListeners();
        this.updateClientsTable();
        this.setupDragAndDrop();
        this.updateScanModeUI();
        this.initTesseractWorker(); // Initialize Tesseract worker on startup
    }

    initializeEventListeners() {
        document.getElementById('startCamera').addEventListener('click', () => this.startCamera());
        document.getElementById('captureImage').addEventListener('click', () => this.captureAndAnalyzeImage());
        document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileUpload(e));
        document.getElementById('manualForm').addEventListener('submit', (e) => this.handleManualEntry(e));
        document.getElementById('searchLinkedIn').addEventListener('click', () => this.searchLinkedIn());
        document.getElementById('exportData').addEventListener('click', () => this.exportToCSV());
        document.getElementById('clearData').addEventListener('click', () => this.clearAllData());

        // Add scan mode toggle listeners
        document.getElementById('qrModeBtn').addEventListener('click', () => this.setScanMode('qr'));
        document.getElementById('imageModeBtn').addEventListener('click', () => this.setScanMode('image'));
    }
    async initTesseractWorker() {
        if (this.tesseractWorker) {
            console.log('Tesseract.js worker already initialized.');
            return;
        }

        try {
            this.showStatus('⚙️ Initializing OCR engine (this may take a moment)...', 'info');
            this.tesseractWorker = await Tesseract.createWorker('eng', 1, { // Specify 'eng' directly here
                logger: m => {
                    if (m.status === 'loading tesseract core') {
                        this.showStatus('⚙️ Loading Tesseract Core...', 'info');
                    } else if (m.status === 'loading language traineddata') {
                        this.showStatus('⚙️ Loading language data (eng)...', 'info');
                    } else if (m.status === 'initializing api') {
                        this.showStatus('⚙️ Initializing OCR API...', 'info');
                    } else if (m.status === 'recognizing text') {
                        this.showStatus(`🔍 OCR Progress: ${Math.round(m.progress * 100)}%`, 'info');
                    }
                }
            });
            // The above `createWorker` call directly handles load() and loadLanguage()
            // No need for separate await this.tesseractWorker.load(); and loadLanguage()
            
            // However, an explicit initialize() call can sometimes help ensure readiness
            await this.tesseractWorker.initialize('eng'); 

            console.log('Tesseract.js worker initialized successfully.');
            this.showStatus('✅ OCR engine ready!', 'success');
        } catch (error) {
            console.error('Failed to initialize Tesseract.js worker:', error);
            this.showStatus('❌ Failed to load OCR engine. Please check your internet connection and try refreshing.', 'error');
            this.tesseractWorker = null; // Ensure worker is null on failure
        }
    }

    setupDragAndDrop() {
        const uploadArea = document.getElementById('uploadArea');

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, this.preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragover'), false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragover'), false);
        });

        uploadArea.addEventListener('drop', (e) => {
            const files = e.dataTransfer.files;
            console.log('Drop event triggered, files:', files);
            if (files.length > 0) {
                this.showStatus('📁 File dropped, processing...', 'info');
                this.processImageFile(files[0]);
                // Clear any file input to ensure fresh state
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    fileInput.value = '';
                }
            }
        }, false);
    }

    preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    /**
     * Initialize Tesseract.js worker
     */
    async initTesseractWorker() {
        if (!this.tesseractWorker) {
            try {
                this.tesseractWorker = Tesseract.createWorker({
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            this.showStatus(`🔍 OCR Progress: ${Math.round(m.progress * 100)}%`, 'info');
                        }
                    }
                });
                await this.tesseractWorker.load();
                await this.tesseractWorker.loadLanguage('eng');
                await this.tesseractWorker.initialize('eng');
                console.log('Tesseract.js worker initialized successfully.');
            } catch (error) {
                console.error('Failed to initialize Tesseract.js worker:', error);
                this.showStatus('❌ Failed to load OCR engine. Please check your internet connection or try again.', 'error');
            }
        }
    }

    /**
     * Clear file input to allow re-uploading the same file
     */
    clearFileInput() {
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
            fileInput.value = '';
        }
    }

    /**
     * Set the current scan mode and update UI
     */
    setScanMode(mode) {
        this.currentScanMode = mode;
        this.updateScanModeUI();

        const modeText = mode === 'qr' ? 'QR Code' : 'Business Card';
        this.showStatus(`🔄 Switched to ${modeText} scanning mode`, 'info');

        // Stop camera if running to apply new mode
        if (this.cameraStarted) {
            this.stopCamera();
        }
    }

    /**
     * Update the scan mode UI buttons
     */
    updateScanModeUI() {
        const qrBtn = document.getElementById('qrModeBtn');
        const imageBtn = document.getElementById('imageModeBtn');
        const captureBtn = document.getElementById('captureImage');

        if (this.currentScanMode === 'qr') {
            qrBtn.classList.add('active');
            imageBtn.classList.remove('active');
            // Disable capture button in QR mode, it's auto-scan
            captureBtn.disabled = true;
        } else {
            imageBtn.classList.add('active');
            qrBtn.classList.remove('active');
            // Enable capture button only if camera is started and in image mode
            captureBtn.disabled = !this.cameraStarted;
        }

        console.log('Mode updated:', this.currentScanMode, 'Capture enabled:', !captureBtn.disabled);
    }

    /**
     * Capture and analyze image for business card scanning
     */
    async captureAndAnalyzeImage() {
        console.log('captureAndAnalyzeImage called');

        // Prevent multiple captures
        if (this.isCapturing) {
            this.showStatus('⏳ Already capturing, please wait...', 'warning');
            return;
        }

        // Check if camera is started
        if (!this.cameraStarted) {
            this.showStatus('❌ Camera not started. Please start camera first.', 'error');
            return;
        }

        this.isCapturing = true; // Set capturing flag

        try {
            this.showStatus('📸 Preparing to capture business card image...', 'info');

            // Show countdown for user feedback
            for (let i = 2; i > 0; i--) {
                this.showStatus(`📸 Capturing in ${i} seconds...`, 'info');
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            this.showStatus('📸 Capturing business card image...', 'info');

            // Get the video element from html5-qrcode
            const videoElement = document.querySelector('#qr-reader video');
            console.log('Video element found:', videoElement);

            if (!videoElement) {
                this.showStatus('❌ Camera not ready for capture - no video element found', 'error');
                this.isCapturing = false;
                return;
            }

            // Ensure video is playing and ready
            if (videoElement.readyState < 2) {
                this.showStatus('⏳ Camera still initializing, please wait...', 'info');
                await new Promise(resolve => setTimeout(resolve, 2000)); // Wait a bit longer
                if (videoElement.readyState < 2) { // Check again
                    this.showStatus('❌ Camera not ready for capture - video stream not playing.', 'error');
                    this.isCapturing = false;
                    return;
                }
            }

            // Create canvas and capture frame
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas dimensions to video feed dimensions for accurate capture
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;

            if (canvas.width === 0 || canvas.height === 0) {
                this.showStatus('❌ Video not ready - dimensions are zero. Try restarting camera.', 'error');
                this.isCapturing = false;
                return;
            }

            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            console.log('Frame captured successfully. Canvas dimensions:', canvas.width, 'x', canvas.height);

            // Convert to blob and process
            canvas.toBlob(async (blob) => {
                console.log('Blob created:', blob);
                if (blob) {
                    console.log('Blob size:', blob.size, 'bytes');
                    await this.processImageFile(blob); // Process the captured image
                    this.stopCamera(); // Stop camera after successful capture and processing
                } else {
                    console.error('Failed to create blob from canvas');
                    this.showStatus('❌ Failed to create image from camera', 'error');
                }
                this.isCapturing = false; // Reset capture flag
            }, 'image/jpeg', 0.9); // Use JPEG for smaller size, 0.9 quality
        } catch (error) {
            this.showStatus('❌ Failed to capture image: ' + error.message, 'error');
            console.error('Capture error:', error);
            this.isCapturing = false; // Reset capture flag on error
        }
    }

    async startCamera() {
        if (this.cameraStarted) return;

        if (!this.html5QrCode) {
            this.html5QrCode = new Html5Qrcode("qr-reader");
        }

        document.getElementById('cameraPlaceholder').style.display = 'none';
        document.getElementById('startCamera').disabled = true;

        // Only enable capture button in business card mode
        const captureBtn = document.getElementById('captureImage');
        captureBtn.disabled = this.currentScanMode !== 'image';
        console.log('Capture button enabled:', !captureBtn.disabled, 'Mode:', this.currentScanMode);

        try {
            const devices = await Html5Qrcode.getCameras();
            if (devices && devices.length) {
                const config = this.currentScanMode === 'qr'
                    ? { fps: 10, qrbox: 250 }
                    : { fps: 10, qrbox: { width: 400, height: 300 } }; // Adjusted qrbox for image mode to be visible

                await this.html5QrCode.start(
                    { facingMode: "environment" }, // Prefer rear camera
                    config,
                    (decodedText, decodedResult) => {
                        if (this.currentScanMode === 'qr') {
                            // QR Mode: Process QR code immediately
                            if (this.lastScanResult !== decodedText) { // Avoid processing same QR multiple times
                                this.lastScanResult = decodedText;
                                this.processQRResult(decodedText, 'QR Camera');
                                this.stopCamera(); // Stop camera after a successful QR scan
                            }
                        }
                        // Business Card Mode: No auto-capture here, waiting for manual button click
                    },
                    (errorMessage) => {
                        // Handle scan errors (e.g., no QR code found in QR mode)
                        // console.warn('QR scan error:', errorMessage);
                    }
                );
                this.cameraStarted = true;
                const modeText = this.currentScanMode === 'qr' ? 'QR codes' : 'business cards';
                this.showStatus(`📷 Camera started! Point at ${modeText} for scanning.`, 'success');

                // For business card mode, add extra stabilization time and manual capture instruction
                if (this.currentScanMode === 'image') {
                    setTimeout(() => {
                        this.showStatus('✅ Camera ready! Position the business card and click "Capture & Analyze".', 'success');
                    }, 2000); // Give camera more time to stabilize
                }
            } else {
                this.showStatus('❌ No camera found.', 'error');
            }
        } catch (err) {
            this.showStatus('❌ Camera error: ' + err.message, 'error');
            console.error('Camera start error:', err);
        }
    }

    async stopCamera() {
        if (this.html5QrCode && this.cameraStarted) {
            try {
                await this.html5QrCode.stop();
                this.cameraStarted = false;
                document.getElementById('cameraPlaceholder').style.display = 'flex';
                document.getElementById('startCamera').disabled = false;
                document.getElementById('captureImage').disabled = true; // Disable capture button when camera stops
                this.showStatus('⏹️ Camera stopped', 'info');
                this.lastScanResult = null; // Reset last scan result
            } catch (err) {
                console.error('Error stopping camera:', err);
                this.showStatus('⚠️ Error stopping camera, it might already be off.', 'warning');
            }
        }
    }

    // Removed the redundant `captureAndAnalyze` method as its logic is now within `captureAndAnalyzeImage`

    async scanQRCodeFromImage(imageDataUrl) {
        try {
            // Try html5-qrcode first for robust QR detection
            const html5QrCodeFile = new Html5Qrcode();
            const blob = await (await fetch(imageDataUrl)).blob();
            const qrText = await html5QrCodeFile.scanFile(blob, false); // Use false for disable worker
            return qrText;
        } catch (e) {
            console.log('html5-qrcode file scan failed, trying jsQR fallback:', e);
            // Fallback to jsQR for file scanning if html5-qrcode fails
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    try {
                        const code = jsQR(imageData.data, imageData.width, imageData.height);
                        resolve(code ? code.data : null);
                    } catch (jsqrError) {
                        console.error('jsQR processing error:', jsqrError);
                        resolve(null);
                    }
                };
                img.onerror = () => {
                    console.error('Image loading error for jsQR fallback.');
                    resolve(null);
                };
                img.src = imageDataUrl;
            });
        }
    }

    async processQRResult(qrText, source) {
        console.log('Processing QR result:', qrText);
        const clientData = this.parseQRData(qrText);
        console.log('Extracted client data:', clientData);

        // A QR code often contains a URL or other non-contact data.
        // If it's a URL and we haven't extracted any contact info,
        // then try OCR on the original image (if available and needed).
        if (!clientData.name && !clientData.email && !clientData.phone) {
            this.showStatus('🔄 QR found but no standard contact info, attempting OCR fallback...', 'info');
            return false; // Indicate that contact info was not found via QR for potential OCR fallback
        } else {
            await this.addClientWithLinkedInSearch(clientData, source);
            this.showStatus('✅ Client data extracted and added successfully! Source: ' + source, 'success');
            return true; // Indicate contact info was found
        }
    }

    handleFileUpload(event) {
        const file = event.target.files[0];
        if (file) {
            this.processImageFile(file);
            // Clear the file input to allow re-uploading the same file
            event.target.value = '';
        }
    }

    async processImageFile(file) {
        console.log('Processing file:', file.name, file.type);

        if (!file.type.startsWith('image/')) {
            this.showStatus('❌ Please upload a valid image file.', 'error');
            return;
        }

        this.clearFileInput(); // Clear input value for subsequent uploads

        this.showProcessing(true);
        this.showStatus(`🔍 Analyzing image for QR codes and text...`, 'info');

        try {
            const reader = new FileReader();
            reader.onload = async (ev) => {
                const imageDataUrl = ev.target.result;
                let contactFoundViaQR = false;

                // 1. Try QR scan first
                const qrText = await this.scanQRCodeFromImage(imageDataUrl);
                if (qrText) {
                    console.log('QR found:', qrText);
                    contactFoundViaQR = await this.processQRResult(qrText, 'File QR');
                } else {
                    console.log('No QR found in file.');
                }

                // 2. If no QR or QR didn't yield contact info, proceed with OCR
                if (!contactFoundViaQR) {
                    this.showStatus('🔄 No contact data from QR or QR was not found. Running OCR...', 'info');
                    await this.analyzeImageWithOCR(imageDataUrl, 'File OCR');
                }
            };
            reader.readAsDataURL(file); // Read file as Data URL for Tesseract.js
        } catch (err) {
            console.error('Error processing image file:', err);
            this.showStatus('❌ Error processing image file: ' + (err.message || 'Unknown error'), 'error');
        } finally {
            this.showProcessing(false);
        }
    }

    parseQRData(qrText) {
        const clientData = { name: '', email: '', phone: '', company: '', linkedIn: '', notes: '' };
        console.log('Parsing QR text:', qrText);

        // Initialize the efficient name extractor
        const nameExtractor = new EfficientNameExtractor();

        // Check if it's a vCard format
        if (qrText.startsWith('BEGIN:VCARD')) {
            console.log('Detected vCard format');
            const lines = qrText.split('\n');
            lines.forEach(line => {
                const cleanLine = line.trim();
                // Prioritize FN (Formatted Name)
                if (cleanLine.startsWith('FN:')) clientData.name = cleanLine.substring(3).trim();
                // Fallback to N (Name) if FN is not present or empty
                if (cleanLine.startsWith('N:') && !clientData.name) {
                    const nameParts = cleanLine.substring(2).split(';');
                    // vCard N format: N:family-name;given-name;additional-names;honorific-prefixes;honorific-suffixes
                    // Reconstruct as "GivenName FamilyName"
                    if (nameParts.length > 0) {
                        const givenName = nameParts[1] ? nameParts[1].trim() : '';
                        const familyName = nameParts[0] ? nameParts[0].trim() : '';
                        clientData.name = `${givenName} ${familyName}`.trim();
                    }
                }
                if (cleanLine.startsWith('EMAIL:') || cleanLine.includes('EMAIL;')) {
                    const emailMatch = cleanLine.match(/EMAIL(?:;TYPE=[^:]+)*:(.*)/i);
                    if (emailMatch) clientData.email = emailMatch[1].trim();
                }
                if (cleanLine.startsWith('TEL:') || cleanLine.includes('TEL;')) {
                    const telMatch = cleanLine.match(/TEL(?:;TYPE=[^:]+)*:(.*)/i);
                    if (telMatch) clientData.phone = telMatch[1].trim();
                }
                if (cleanLine.startsWith('ORG:')) clientData.company = cleanLine.substring(4).trim();
                if (cleanLine.startsWith('URL:')) {
                    // Check if it's a LinkedIn URL
                    if (cleanLine.includes('linkedin.com/in/') || cleanLine.includes('linkedin.com/pub/')) {
                        clientData.linkedIn = cleanLine.substring(4).trim();
                    }
                }
            });
        } else {
            console.log('Parsing as plain text with enhanced extraction');

            // Extract all possible emails and phones
            const allEmails = this.extractEmails(qrText);
            const allPhones = this.extractPhoneNumbers(qrText);

            if (allEmails.length > 0) {
                clientData.email = allEmails[0];
                if (allEmails.length > 1) {
                    clientData.notes = `Additional emails: ${allEmails.slice(1).join(', ')}`;
                }
            }

            if (allPhones.length > 0) {
                clientData.phone = allPhones[0];
                if (allPhones.length > 1) {
                    const phoneNote = `Additional phones: ${allPhones.slice(1).join(', ')}`;
                    clientData.notes = clientData.notes
                        ? `${clientData.notes}; ${phoneNote}`
                        : phoneNote;
                }
            }

            // Enhanced name extraction for QR codes (context-aware)
            clientData.name = this.extractNameWithContext(qrText);

            // Enhanced company extraction for QR codes
            const companyMatch = this.extractCompanyFromText(qrText);
            if (companyMatch) clientData.company = companyMatch;

            // Check for LinkedIn URLs in plain text QR
            const linkedInMatch = qrText.match(/(https?:\/\/(?:www\.)?linkedin\.com\/(?:in|pub)\/[^/\s]+)/i);
            if (linkedInMatch) {
                clientData.linkedIn = linkedInMatch[1].trim();
            }

            // If it's just a URL and no other contact info, extract domain as company
            const isUrlOnly = qrText.match(/^https?:\/\/[^\s]+$/) && !clientData.name && !clientData.email && !clientData.phone;
            if (isUrlOnly) {
                const domainMatch = qrText.match(/https?:\/\/([^\/]+)/);
                if (domainMatch) {
                    clientData.company = domainMatch[1].replace('www.', '').split('.')[0].trim();
                    console.log('Extracted company from URL:', clientData.company);
                }
            }
        }

        console.log('Final extracted data:', clientData);
        return clientData;
    }

    /**
     * Optimized phone number extraction with multiple number handling
     */
    extractPhoneNumbers(text) {
        // Enhanced phone regex patterns covering various global and Indian formats
        const phonePatterns = [
            // International with '+' prefix, allowing spaces, dashes, parentheses
            /\+\d{1,4}[-.\s]?\(?\d{1,4}\)?[-.\s]?\d{1,4}[-.\s]?\d{1,9}(?:x\d+)?/g,
            // Standard 10-digit Indian mobile/landline numbers (starting with 6,7,8,9,0)
            /[67890]\d{9}/g,
            // 7 to 12 digit numbers, allowing spaces, dashes, parentheses, dots
            /\(?\d{3}\)?[-.\s]?\d{3,4}[-.\s]?\d{4}/g,
            // Explicit 'tel:' or 'phone:' prefixes
            /(?:tel|phone):?\s*([+\d\s\-\(\).]{7,})/gi
        ];

        const foundNumbers = new Set();

        for (const pattern of phonePatterns) {
            let match;
            while ((match = pattern.exec(text)) !== null) {
                let num = match[1] || match[0]; // Take captured group if available, else full match
                let cleanNum = num.replace(/[^\d+]/g, '').trim();

                // Simple validation: must have at least 7 digits (after cleaning)
                if (cleanNum.length >= 7) {
                    foundNumbers.add(cleanNum);
                }
            }
        }

        // Convert to array and prioritize numbers
        const numbers = Array.from(foundNumbers);

        // Prioritization logic:
        // 1. Numbers with '+' prefix (international)
        // 2. Longer numbers (more likely to be complete)
        // 3. Numbers that appear earlier in the text
        numbers.sort((a, b) => {
            const aIsIntl = a.startsWith('+');
            const bIsIntl = b.startsWith('+');

            if (aIsIntl && !bIsIntl) return -1;
            if (!aIsIntl && bIsIntl) return 1;

            if (a.length !== b.length) return b.length - a.length;

            return text.indexOf(a) - text.indexOf(b); // Keep original order if lengths are same
        });

        return numbers;
    }

    /**
     * Enhanced email extraction with multiple email handling
     */
    extractEmails(text) {
        // More robust email patterns
        const emailPatterns = [
            // Standard email pattern
            /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}/g, // Expanded TLD length
            // Email with common prefixes like 'email:', 'e-mail:', 'mail:'
            /(?:email|e-mail|mail|contact)\s*:\s*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63})/gi,
            // Email surrounded by parentheses or brackets, without explicit prefix
            /[\(<\[{] ?([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}) ?[}>\)\]]/g
        ];

        const foundEmails = new Set();

        for (const pattern of emailPatterns) {
            let match;
            while ((match = pattern.exec(text)) !== null) {
                let email = match[1] || match[0]; // Take captured group if available, else full match
                let cleanEmail = email.replace(/[\(\)\[\]{}<>]/g, '').trim(); // Remove common delimiters

                if (this.isValidEmail(cleanEmail)) {
                    foundEmails.add(cleanEmail.toLowerCase());
                }
            }
        }

        const emails = Array.from(foundEmails);

        // Prioritization logic:
        // 1. Emails that appear to be personal (not info@, sales@ etc.)
        // 2. Shorter emails (sometimes more direct)
        // 3. Emails appearing earlier in the text
        emails.sort((a, b) => {
            const aIsPersonal = !/(info|sales|support|admin|contact|help|webmaster)@/i.test(a);
            const bIsPersonal = !/(info|sales|support|admin|contact|help|webmaster)@/i.test(b);

            if (aIsPersonal && !bIsPersonal) return -1;
            if (!aIsPersonal && bIsPersonal) return 1;

            if (a.length !== b.length) return a.length - b.length;

            return text.indexOf(a) - text.indexOf(b);
        });

        return emails;
    }


    /**
     * Enhanced name extraction considering surrounding context with name dataset validation
     */
    extractNameWithContext(text) {
        const nameExtractor = new EfficientNameExtractor();
        let bestName = { name: '', confidence: 0 };

        // 1. Try direct pattern matching on full text
        const directMatch = nameExtractor.extractName(text);
        if (directMatch.confidence > bestName.confidence) {
            bestName = directMatch;
        }

        const lines = text.split('\n').filter(line => line.trim().length > 2);

        // 2. Try to find name near email or phone
        const emails = this.extractEmails(text);
        const phones = this.extractPhoneNumbers(text);
        const contactPoints = [...emails, ...phones];

        for (const point of contactPoints) {
            const pointIndex = text.indexOf(point);
            if (pointIndex === -1) continue;

            // Search in lines immediately before and after the contact point
            for (let i = 0; i < lines.length; i++) {
                if (text.indexOf(lines[i]) <= pointIndex + lines[i].length && text.indexOf(lines[i]) >= pointIndex - 50) {
                    const line = lines[i];
                    const nameResult = nameExtractor.extractName(line);
                    if (nameResult.confidence > bestName.confidence) {
                        bestName = nameResult;
                    }
                }
            }
        }

        // 3. Prioritize lines that are capitalized like names and not obviously company/email/phone
        for (const line of lines) {
            if (line.includes('@') || /\d/.test(line) || line.toLowerCase().includes('http')) continue;
            const words = line.split(/\s+/);
            if (words.every(word => /^[A-Z][a-z]*$/.test(word) || /^[A-Z]\.$/.test(word))) {
                const nameResult = nameExtractor.extractName(line);
                if (nameResult.confidence > bestName.confidence) {
                    bestName = nameResult;
                }
            }
        }

        // Apply dataset validation to the best found name
        if (bestName.name) {
            const validatedName = this.validateNameWithDataset(bestName.name);
            if (validatedName) {
                return validatedName;
            }
        }
        return bestName.name || '';
    }

    /**
     * Validate and correct name using a common Indian names dataset
     * This dataset is limited and could be greatly expanded for better accuracy.
     */
    validateNameWithDataset(extractedName) {
        if (!extractedName || extractedName.length < 2) return null;

        // Convert to title case for better matching against dataset
        const cleanedExtractedName = extractedName.trim().replace(/\s+/g, ' ').split(' ').map(word =>
            word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        ).join(' ');

        const nameParts = cleanedExtractedName.toLowerCase().split(/\s+/);

        // A small, representative dataset of common Indian names
        // In a real application, this would be a much larger, external database or API.
        const nameDataset = [
            'aaban', 'aabharan', 'aabhas', 'aabhat', 'aabheer', 'aabir', 'aabishan', 'aacharya', 'aachman', 'aadarsh',
            'aadhav', 'aadhi', 'aadidev', 'aadil', 'aadish', 'aaditya', 'aadvay', 'aadvik', 'aayush', 'abdul',
            'abhay', 'abheek', 'abhijit', 'abhilash', 'abhimanyu', 'abhinav', 'abhishek', 'achyut', 'adarsh', 'aditya',
            'ajay', 'ajeet', 'akhil', 'akhilesh', 'akash', 'akshay', 'alok', 'aman', 'amar', 'amit', 'amol',
            'anand', 'ananta', 'aneesh', 'anil', 'anirudh', 'anish', 'ankit', 'ankur', 'anuj', 'anupam',
            'anurag', 'arjun', 'arun', 'aryan', 'ashok', 'ashish', 'ashwin', 'atul', 'avinash', 'ayush',
            // Common Female names (though the current context is male-dominant)
            'aarohi', 'aisha', 'akanksha', 'akshara', 'alaya', 'amara', 'ananya', 'anjali', 'anjana', 'anjum',
            'anushka', 'aparna', 'aradhana', 'aroha', 'asha', 'bhumi', 'bindu', 'chhaya', 'damini', 'deepti',
            'devina', 'disha', 'divya', 'ekta', 'gauri', 'geeta', 'gunjan', 'harini', 'hema', 'ishita',
            'jaya', 'jyoti', 'kajal', 'kavita', 'khushi', 'kiran', 'lakshmi', 'lata', 'madhuri', 'mahi',
            'malini', 'meena', 'meera', 'mira', 'monika', 'naina', 'nandini', 'neha', 'nikita', 'nisha',
            'pallavi', 'pooja', 'priti', 'priya', 'radhika', 'rani', 'rekha', 'rima', 'riya', 'roshni',
            'rupa', 'sakshi', 'sangeeta', 'sarika', 'seema', 'shanti', 'shikha', 'shruti', 'simran', 'smita',
            'sneha', 'sonal', 'sonia', 'surbhi', 'swati', 'tanvi', 'usha', 'vandana', 'vidya', 'vini',
            'yamini', 'zareen'
        ];

        // Check if any part of the extracted name matches the dataset (case-insensitive)
        for (const namePart of nameParts) {
            if (namePart.length < 2) continue; // Skip very short words

            // Direct match
            if (nameDataset.includes(namePart)) {
                console.log(`Name validated with dataset: ${namePart} -> ${extractedName}`);
                return cleanedExtractedName; // Return the cleaned, title-cased name
            }
        }

        // If no direct match, consider accepting if it follows naming conventions and isn't a common non-name word.
        // This is a heuristic and can be improved with a much larger dataset.
        const firstWordCapitalized = nameParts.length > 0 && nameParts[0].charAt(0) === nameParts[0].charAt(0).toUpperCase();
        const hasMultipleWords = nameParts.length > 1;
        const noExcludedWords = !nameParts.some(word => this.nameExtractor.excludeWords.has(word));

        if (firstWordCapitalized && hasMultipleWords && noExcludedWords && extractedName.length >= 4) {
            console.log(`Name accepted by heuristic: ${extractedName}`);
            return cleanedExtractedName;
        }

        return null; // Return null if not confidently a name
    }

    // Removed `generateNameVariations` as it's less reliable than direct dataset matching for validation.

    // EMAIL VALIDATION HELPER
    isValidEmail(email) {
        // More robust email regex
        const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
        return emailRegex.test(email) &&
               email.length >= 5 &&
               email.length <= 254 &&
               !email.includes('..') &&
               !email.startsWith('.') &&
               !email.endsWith('.');
    }

    // Enhanced OCR text extraction using the new optimized methods
    extractClientDataFromText(text) {
        console.log('Processing OCR text:', text);
        const clientData = { name: '', email: '', phone: '', company: '', linkedIn: '', notes: '' };

        // Clean and normalize text for better processing
        const cleanText = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim();
        const lines = cleanText.split('\n').map(line => line.trim()).filter(line => line.length > 0);

        console.log('Processed lines:', lines);

        // Extract Email
        const allEmails = this.extractEmails(cleanText);
        if (allEmails.length > 0) {
            clientData.email = allEmails[0];
            if (allEmails.length > 1) {
                clientData.notes += `Additional emails: ${allEmails.slice(1).join(', ')}. `;
            }
        }

        // Extract Phone
        const allPhones = this.extractPhoneNumbers(cleanText);
        if (allPhones.length > 0) {
            clientData.phone = allPhones[0];
            if (allPhones.length > 1) {
                clientData.notes += `Additional phones: ${allPhones.slice(1).join(', ')}. `;
            }
        }

        // Extract LinkedIn URL
        const linkedInMatch = cleanText.match(/(https?:\/\/(?:www\.)?linkedin\.com\/(?:in|pub)\/[^/\s]+)/i);
        if (linkedInMatch) {
            clientData.linkedIn = linkedInMatch[1].trim();
        }

        // Extract Name - Crucial for business cards
        clientData.name = this.extractNameFromBusinessCard(lines, cleanText);

        // Extract Company
        clientData.company = this.extractCompanyFromBusinessCard(lines, cleanText);

        // Fallback: If no name found, try to extract from email prefix or first plausible line
        if (!clientData.name && clientData.email) {
            const emailPrefix = clientData.email.split('@')[0];
            const nameFromEmail = emailPrefix
                .replace(/[^a-zA-Z]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
            const nameExtractor = new EfficientNameExtractor();
            const nameCheck = nameExtractor.extractName(nameFromEmail);
            if (nameCheck.confidence >= 3) { // Lower confidence for email fallback
                clientData.name = nameCheck.name;
                console.log('OCR extracted name from email:', clientData.name);
            }
        }

        // Clean up notes if empty
        if (clientData.notes.trim() === '') {
            clientData.notes = '';
        }

        console.log('Final extracted data (OCR):', clientData);
        return clientData;
    }

    async analyzeImageWithOCR(imageData, source) {
        if (!this.tesseractWorker) {
            // Attempt to re-initialize if not ready, but usually initTesseractWorker() handles on load
            this.showStatus('⏳ OCR engine not initialized. Attempting to initialize...', 'info');
            await this.initTesseractWorker();
            if (!this.tesseractWorker) {
                this.showStatus('❌ OCR engine failed to initialize. Cannot perform text recognition.', 'error');
                this.showProcessing(false);
                return;
            }
        }

        try {
            this.showStatus('🤖 Performing text recognition...', 'info');

            // Use the already initialized worker
            const { data: { text } } = await this.tesseractWorker.recognize(imageData); // Ensure this is awaited

            if (!text || text.trim().length < 10) {
                this.showStatus('⚠️ OCR did not find enough readable text. Image might be blurry or too complex.', 'warning');
                this.showProcessing(false);
                return;
            }

            const clientData = this.extractClientDataFromText(text);

            if (clientData.email || clientData.name || clientData.phone) {
                await this.addClientWithLinkedInSearch(clientData, source);
                this.showStatus(`✅ Client data extracted and added successfully! Source: ${source}`, 'success');
            } else {
                this.showStatus('❌ No valid contact information found in the image after OCR. Please try manual entry or a clearer image.', 'error');
            }
        } catch (error) {
            console.error('OCR processing failed:', error);
            this.showStatus('❌ OCR processing failed: ' + error.message, 'error');
        } finally {
            this.showProcessing(false);
        }
    }


    /**
     * Extract name specifically from business card format
     */
    extractNameFromBusinessCard(lines, fullText) {
        const nameExtractor = new EfficientNameExtractor();
        let bestCandidate = { name: '', confidence: 0 };

        // 1. Prioritize lines that are most likely to be names (e.g., first few lines, proper capitalization)
        for (let i = 0; i < Math.min(5, lines.length); i++) {
            const line = lines[i];
            if (line.includes('@') || /\d{7,}/.test(line) || line.includes('www.') ||
                line.toLowerCase().includes('email') || line.toLowerCase().includes('phone') ||
                line.toLowerCase().includes('fax') || line.toLowerCase().includes('mobile') ||
                line.toLowerCase().includes('tel') || line.toLowerCase().includes('http')) {
                continue; // Skip lines containing common contact info or URLs
            }

            const nameResult = nameExtractor.extractName(line);
            if (nameResult.name && nameResult.confidence > bestCandidate.confidence) {
                bestCandidate = nameResult;
            }
        }

        // 2. Look for name-like patterns that might be missed by simple line checks
        // Example: "John Doe - CEO" or "Dr. Jane Smith"
        const potentialNamesInFullText = fullText.match(/([A-Z][a-z]+(?:\s+[A-Z][a-z.]+){1,4})/g); // Matches 2-5 capitalized words
        if (potentialNamesInFullText) {
            for (const pn of potentialNamesInFullText) {
                const nameResult = nameExtractor.extractName(pn);
                if (nameResult.name && nameResult.confidence > bestCandidate.confidence) {
                    // Give a slight boost if found in full text match but not line directly,
                    // but prefer line-based if confidence is equal
                    if (nameResult.confidence === bestCandidate.confidence) {
                        if (fullText.indexOf(pn) < fullText.indexOf(bestCandidate.name)) {
                            bestCandidate = nameResult;
                        }
                    } else {
                        bestCandidate = nameResult;
                    }
                }
            }
        }

        // 3. Fallback to context-based extraction (last resort)
        if (!bestCandidate.name) {
            const contextName = this.extractNameWithContext(fullText); // This already uses the EfficientNameExtractor
            if (contextName) {
                const nameResult = nameExtractor.extractName(contextName);
                if (nameResult.name && nameResult.confidence > bestCandidate.confidence) {
                    bestCandidate = nameResult;
                }
            }
        }

        // Final validation using the dataset
        if (bestCandidate.name) {
            const validatedName = this.validateNameWithDataset(bestCandidate.name);
            if (validatedName) {
                return validatedName;
            }
        }

        return bestCandidate.name || '';
    }


    /**
     * Extract company specifically from business card format
     */
    extractCompanyFromBusinessCard(lines, fullText) {
        // Expanded company patterns for business cards, prioritizing common keywords and capitalization
        const companyPatterns = [
            // vCard ORG field (highest priority)
            /^ORG:(.+)$/i,
            // Common suffixes (case-insensitive for robust matching)
            /(.*?)\s*(?:Inc\.?|LLC|Corp\.?|Ltd\.?|Company|Co\.?|Corporation|Group|Solutions|Services|Technologies|Tech|Systems|Associates|Partners|Consulting|Infotech|Software|Digital|Media|Marketing|Design|Studio|Agency|Pvt\.?|Limited|Global|Enterprises)(?!\w)/i,
            // Standalone company names (often capitalized, may contain '&' or numbers)
            /^([A-Z0-9][a-zA-Z0-9\s&.\-]+(?:Inc\.?|LLC|Corp\.?|Ltd\.?)?)$/i,
            // Lines that look like company names (no email/phone/name patterns, often with multiple capitalized words)
            /^([A-Z][a-zA-Z\s&]{3,})(?:\s+(?:Industries|Group|Corp|Co|Ltd))?$/i
        ];

        // 1. Look for company patterns in lines
        for (const line of lines) {
            // Skip if line contains email, phone, or LinkedIn patterns (likely not company name)
            if (line.includes('@') || /\d{7,}/.test(line) || line.toLowerCase().includes('email') ||
                line.toLowerCase().includes('phone') || line.toLowerCase().includes('tel') ||
                line.toLowerCase().includes('linkedin.com')) {
                continue;
            }
            // Also skip if it's very short or looks like a job title
            if (line.length < 3 || /(?:manager|director|specialist|engineer|consultant)/i.test(line)) {
                continue;
            }

            for (const pattern of companyPatterns) {
                const match = line.match(pattern);
                if (match) {
                    let companyName = match[1] || match[0];
                    companyName = companyName.replace(/^ORG:\s*/i, '').trim();
                    // Basic length validation
                    if (companyName.length > 2 && companyName.length < 70 && !this.nameExtractor.isLikelyName(companyName)) {
                        return companyName;
                    }
                }
            }
        }

        // 2. Look for domain-based company names (e.g., from www.example.com)
        const domainMatch = fullText.match(/www\.([^\/\s]+(?:\.[a-z]{2,63}){1,2})/i);
        if (domainMatch) {
            const domain = domainMatch[1].replace('www.', '').split('.')[0].trim();
            if (domain.length > 3 && !this.nameExtractor.isLikelyName(domain)) {
                return domain.charAt(0).toUpperCase() + domain.slice(1); // Capitalize first letter
            }
        }

        // 3. Fallback: Search for common company keywords in the full text
        const commonCompanyKeywords = ['Pvt Ltd', 'Inc', 'LLC', 'Corp', 'Ltd', 'Company', 'Group', 'Solutions', 'Services', 'Technologies'];
        for (const keyword of commonCompanyKeywords) {
            const regex = new RegExp(`([A-Za-z0-9\\s&.-]+?)\\s*${keyword}`, 'i');
            const match = fullText.match(regex);
            if (match && match[1]) {
                const potentialCompany = match[1].trim();
                if (potentialCompany.length > 2 && !this.nameExtractor.isLikelyName(potentialCompany)) {
                    return potentialCompany + ' ' + keyword;
                }
            }
        }

        return '';
    }

    /**
     * Generic company extraction for any text (used by QR data parsing too)
     */
    extractCompanyFromText(text) {
        // Re-use business card logic for robust company extraction
        const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        return this.extractCompanyFromBusinessCard(lines, text);
    }

    async addClientWithLinkedInSearch(clientData, source) {
        if (clientData.name && !clientData.linkedIn) { // Only search if name exists and LinkedIn isn't already found
            this.showStatus('🔍 Searching for LinkedIn profile...', 'info');
            clientData.linkedIn = await this.findLinkedInProfile(clientData.name, clientData.company);
        }

        this.addClient({ ...clientData, source });
        // Status message already shown inside processQRResult or analyzeImageWithOCR
    }

    async findLinkedInProfile(name, company = '') {
        try {
            // Create LinkedIn search URL
            const searchQuery = `${name} ${company}`.trim().replace(/\s+/g, '+');
            const linkedInSearchURL = `https://www.linkedin.com/search/results/people/?keywords=${encodeURIComponent(searchQuery)}`;

            // Note: Directly accessing and parsing LinkedIn search results programmatically is often blocked
            // by LinkedIn's robots.txt and anti-scraping measures. This link just opens the search.
            return linkedInSearchURL;
        } catch (error) {
            console.log('LinkedIn search URL generation failed:', error);
            return '';
        }
    }

    searchLinkedIn() {
        const name = document.getElementById('manualName').value;
        const company = document.getElementById('manualCompany').value;

        if (!name.trim()) {
            this.showStatus('❌ Please enter a name to search LinkedIn', 'error');
            return;
        }

        const searchQuery = `${name} ${company}`.trim().replace(/\s+/g, '+');
        const linkedInURL = `https://www.linkedin.com/search/results/people/?keywords=${encodeURIComponent(searchQuery)}`;

        document.getElementById('manualLinkedIn').value = linkedInURL;
        this.showStatus('🔗 LinkedIn search URL generated!', 'success');

        // Open LinkedIn search in new tab
        window.open(linkedInURL, '_blank');
    }

    handleManualEntry(event) {
        event.preventDefault();

        const clientData = {
            name: document.getElementById('manualName').value.trim(),
            email: document.getElementById('manualEmail').value.trim(),
            phone: document.getElementById('manualPhone').value.trim(),
            company: document.getElementById('manualCompany').value.trim(),
            linkedIn: document.getElementById('manualLinkedIn').value.trim(),
            source: 'Manual Entry'
        };

        if (!clientData.name && !clientData.email && !clientData.phone) {
            this.showStatus('❌ Please fill in at least name, email, or phone number', 'error');
            return;
        }

        // Validate email format if provided
        if (clientData.email && !this.isValidEmail(clientData.email)) {
            this.showStatus('❌ Please enter a valid email address', 'error');
            return;
        }

        this.addClient(clientData);
        this.showStatus('✅ Client added successfully via manual entry!', 'success');

        // Clear form
        document.getElementById('manualForm').reset();
    }

    addClient(clientData) {
        // Ensure all fields are strings or empty strings
        const client = {
            id: Date.now(),
            name: clientData.name || '',
            email: clientData.email || '',
            phone: clientData.phone || '',
            company: clientData.company || '',
            linkedIn: clientData.linkedIn || '',
            source: clientData.source || 'Unknown',
            notes: clientData.notes || '', // Added notes field
            timestamp: new Date().toLocaleString()
        };

        this.clients.push(client);
        this.saveClients();
        this.updateClientsTable();
    }

    updateClientsTable() {
        const tbody = document.getElementById('clientsTableBody');
        const stats = document.getElementById('clientStats');

        tbody.innerHTML = '';

        if (this.clients.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="10" style="text-align: center; padding: 40px; opacity: 0.7;">
                        📭 No clients added yet. Start scanning or add manually!
                    </td>
                </tr>
            `;
        } else {
            this.clients.forEach((client, index) => {
                const row = tbody.insertRow();
                const sourceClass = client.source.toLowerCase().includes('qr') ? 'source-qr' :
                    client.source.toLowerCase().includes('ocr') ? 'source-ocr' : 'source-manual';

                row.innerHTML = `
                    <td><strong>${index + 1}</strong></td>
                    <td>${client.name || '<em>N/A</em>'}</td>
                    <td>${client.email || '<em>N/A</em>'}</td>
                    <td>${client.phone || '<em>N/A</em>'}</td>
                    <td>${client.company || '<em>N/A</em>'}</td>
                    <td>${client.linkedIn ? `<a href="${client.linkedIn}" target="_blank" class="linkedin-link">🔗 LinkedIn</a>` : '<em>N/A</em>'}</td>
                    <td><span class="source-badge ${sourceClass}">${client.source}</span></td>
                    <td>${client.timestamp}</td>
                    <td>
                        <button class="btn btn-sm btn-primary edit-btn" data-index="${index}">
                            ✏️ Edit
                        </button>
                    </td>
                    <td>
                        <button class="btn btn-sm btn-danger delete-btn" data-index="${index}" title="Delete this record">
                            ❌ Delete
                        </button>
                    </td>
                `;

                row.style.animation = 'fadeInUp 0.5s ease-out';
            });
        }

        // Update stats
        const qrCount = this.clients.filter(c => c.source.toLowerCase().includes('qr')).length;
        const ocrCount = this.clients.filter(c => c.source.toLowerCase().includes('ocr')).length;
        const manualCount = this.clients.filter(c => c.source === 'Manual Entry').length;

        stats.innerHTML = `
            📊 Total: ${this.clients.length} |
            📱 QR: ${qrCount} |
            🤖 OCR: ${ocrCount} |
            ✍️ Manual: ${manualCount}
        `;

        // Add event listeners for edit buttons
        document.querySelectorAll('.edit-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                // Ensure we get the button itself, not its child icon
                const targetBtn = e.target.closest('.edit-btn');
                if (targetBtn) {
                    const index = parseInt(targetBtn.dataset.index);
                    this.editClient(index);
                }
            });
        });

        // Add event listeners for delete buttons
        document.querySelectorAll('.delete-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                // Ensure we get the button itself, not its child icon
                const targetBtn = e.target.closest('.delete-btn');
                if (targetBtn) {
                    const index = parseInt(targetBtn.dataset.index);
                    this.deleteClient(index);
                }
            });
        });
    }

    exportToCSV() {
        if (this.clients.length === 0) {
            this.showStatus('❌ No data to export', 'error');
            return;
        }

        const headers = ['Name', 'Email', 'Phone', 'Company', 'LinkedIn', 'Source', 'Notes', 'Timestamp'];
        const csvContent = [
            headers.join(','),
            ...this.clients.map(client => [
                `"${(client.name || '').replace(/"/g, '""')}"`,
                `"${(client.email || '').replace(/"/g, '""')}"`,
                `"${(client.phone || '').replace(/"/g, '""')}"`,
                `"${(client.company || '').replace(/"/g, '""')}"`,
                `"${(client.linkedIn || '').replace(/"/g, '""')}"`,
                `"${(client.source || '').replace(/"/g, '""')}"`,
                `"${(client.notes || '').replace(/"/g, '""')}"`, // Added notes to CSV
                `"${(client.timestamp || '').replace(/"/g, '""')}"`
            ].join(','))
        ].join('\n');

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `exhibition-clients-${new Date().toISOString().split('T')[0]}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);

        this.showStatus('📊 Data exported successfully!', 'success');
    }

    deleteClient(index) {
        if (index < 0 || index >= this.clients.length) {
            this.showStatus('❌ Invalid client index', 'error');
            return;
        }

        const client = this.clients[index];
        const confirmDelete = confirm(`Are you sure you want to delete ${client.name || 'this client'}?`);

        if (confirmDelete) {
            this.clients.splice(index, 1);
            this.saveClients();
            this.updateClientsTable();
            this.showStatus(`🗑️ Deleted client: ${client.name || 'Unknown'}`, 'success');
        }
    }

    clearAllData() {
        if (this.clients.length === 0) {
            this.showStatus('❌ No data to clear', 'error');
            return;
        }

        if (confirm(`🗑️ Are you sure you want to clear all ${this.clients.length} client records? This action cannot be undone.`)) {
            this.clients = [];
            this.saveClients();
            this.updateClientsTable();
            this.showStatus('🗑️ All client data cleared', 'info');
        }
    }

    loadClients() {
        try {
            const stored = localStorage.getItem('exhibitionCardReaderClients');
            return stored ? JSON.parse(stored) : [];
        } catch (error) {
            console.error('Error loading clients:', error);
            return [];
        }
    }

    saveClients() {
        try {
            localStorage.setItem('exhibitionCardReaderClients', JSON.stringify(this.clients));
            console.log('Clients saved to localStorage:', this.clients.length);
        } catch (error) {
            console.error('Error saving clients:', error);
        }
    }

    showStatus(message, type) {
        const statusEl = document.getElementById('statusMessage');
        statusEl.innerHTML = `<div class="status-message ${type}">${message}</div>`;

        // Auto-hide success and info messages after 5 seconds
        if (type === 'success' || type === 'info') {
            setTimeout(() => {
                // Only clear if the current message is still the one we set
                if (statusEl.innerHTML.includes(message)) {
                    statusEl.innerHTML = '';
                }
            }, 5000);
        }
    }

    showProcessing(show) {
        document.getElementById('processing').style.display = show ? 'block' : 'none';
        // Disable buttons when processing
        document.getElementById('startCamera').disabled = show;
        document.getElementById('captureImage').disabled = show;
        document.getElementById('fileInput').disabled = show;
        document.getElementById('uploadArea').style.pointerEvents = show ? 'none' : 'auto';
        document.getElementById('manualForm').style.pointerEvents = show ? 'none' : 'auto';
    }

    editClient(index) {
        const client = this.clients[index];
        if (!client) return;

        // Remove any existing modal to prevent duplicates
        const existingModal = document.querySelector('.edit-modal');
        if (existingModal) {
            existingModal.remove();
        }

        // Create and show edit modal with better styling
        const modal = document.createElement('div');
        modal.className = 'edit-modal';
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease-out;
        `;

        modal.innerHTML = `
            <div class="edit-modal-content" style="
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border-radius: 20px;
                padding: 0;
                width: 90%;
                max-width: 500px;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                border: 2px solid rgba(255,255,255,0.1);
                backdrop-filter: blur(10px);
                animation: slideInFromTop 0.4s ease-out;
            ">
                <div style="
                    background: rgba(255,255,255,0.1);
                    padding: 25px 30px;
                    border-radius: 18px 18px 0 0;
                    border-bottom: 1px solid rgba(255,255,255,0.2);
                ">
                    <h3 style="
                        color: white;
                        margin: 0;
                        font-size: 1.5rem;
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: 10px;
                    ">
                        ✏️ Edit Client
                    </h3>
                </div>

                <div style="padding: 30px;">
                    <form id="editClientForm">
                        <div style="margin-bottom: 20px;">
                            <label style="
                                color: white;
                                font-weight: 600;
                                margin-bottom: 8px;
                                display: block;
                                font-size: 0.9rem;
                            ">👤 Name *</label>
                            <input type="text" class="edit-input" id="editName" value="${client.name || ''}" required style="
                                width: 100%;
                                padding: 12px 15px;
                                border: 2px solid rgba(255,255,255,0.2);
                                border-radius: 10px;
                                background: rgba(255,255,255,0.1);
                                color: white;
                                font-size: 1rem;
                                transition: all 0.3s ease;
                            " placeholder="Enter full name">
                        </div>

                        <div style="margin-bottom: 20px;">
                            <label style="
                                color: white;
                                font-weight: 600;
                                margin-bottom: 8px;
                                display: block;
                                font-size: 0.9rem;
                            ">📧 Email</label>
                            <input type="email" class="edit-input" id="editEmail" value="${client.email || ''}" style="
                                width: 100%;
                                padding: 12px 15px;
                                border: 2px solid rgba(255,255,255,0.2);
                                border-radius: 10px;
                                background: rgba(255,255,255,0.1);
                                color: white;
                                font-size: 1rem;
                                transition: all 0.3s ease;
                            " placeholder="Enter email address">
                        </div>

                        <div style="margin-bottom: 20px;">
                            <label style="
                                color: white;
                                font-weight: 600;
                                margin-bottom: 8px;
                                display: block;
                                font-size: 0.9rem;
                            ">📞 Phone</label>
                            <input type="tel" class="edit-input" id="editPhone" value="${client.phone || ''}" style="
                                width: 100%;
                                padding: 12px 15px;
                                border: 2px solid rgba(255,255,255,0.2);
                                border-radius: 10px;
                                background: rgba(255,255,255,0.1);
                                color: white;
                                font-size: 1rem;
                                transition: all 0.3s ease;
                            " placeholder="Enter phone number">
                        </div>

                        <div style="margin-bottom: 20px;">
                            <label style="
                                color: white;
                                font-weight: 600;
                                margin-bottom: 8px;
                                display: block;
                                font-size: 0.9rem;
                            ">🏢 Company</label>
                            <input type="text" class="edit-input" id="editCompany" value="${client.company || ''}" style="
                                width: 100%;
                                padding: 12px 15px;
                                border: 2px solid rgba(255,255,255,0.2);
                                border-radius: 10px;
                                background: rgba(255,255,255,0.1);
                                color: white;
                                font-size: 1rem;
                                transition: all 0.3s ease;
                            " placeholder="Enter company name">
                        </div>

                        <div style="margin-bottom: 20px;">
                            <label style="
                                color: white;
                                font-weight: 600;
                                margin-bottom: 8px;
                                display: block;
                                font-size: 0.9rem;
                            ">🔗 LinkedIn</label>
                            <input type="url" class="edit-input" id="editLinkedin" value="${client.linkedIn || ''}" style="
                                width: 100%;
                                padding: 12px 15px;
                                border: 2px solid rgba(255,255,255,0.2);
                                border-radius: 10px;
                                background: rgba(255,255,255,0.1);
                                color: white;
                                font-size: 1rem;
                                transition: all 0.3s ease;
                            " placeholder="Enter LinkedIn URL">
                        </div>

                        <div style="margin-bottom: 25px;">
                            <label style="
                                color: white;
                                font-weight: 600;
                                margin-bottom: 8px;
                                display: block;
                                font-size: 0.9rem;
                            ">📝 Notes</label>
                            <textarea class="edit-input" id="editNotes" style="
                                width: 100%;
                                padding: 12px 15px;
                                border: 2px solid rgba(255,255,255,0.2);
                                border-radius: 10px;
                                background: rgba(255,255,255,0.1);
                                color: white;
                                font-size: 1rem;
                                transition: all 0.3s ease;
                                min-height: 80px;
                                resize: vertical;
                            " placeholder="Add any additional notes">${client.notes || ''}</textarea>
                        </div>
                    </form>
                </div>

                <div style="
                    padding: 20px 30px 30px;
                    display: flex;
                    gap: 15px;
                    justify-content: flex-end;
                ">
                    <button type="button" class="edit-cancel-btn" style="
                        padding: 12px 25px;
                        border: 2px solid rgba(255,255,255,0.3);
                        border-radius: 10px;
                        background: rgba(255,255,255,0.1);
                        color: white;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        font-size: 0.9rem;
                    ">❌ Cancel</button>
                    <button type="button" class="edit-update-btn" style="
                        padding: 12px 25px;
                        border: none;
                        border-radius: 10px;
                        background: linear-gradient(135deg, #00c851, #007e33);
                        color: white;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        font-size: 0.9rem;
                        box-shadow: 0 4px 15px rgba(0,200,81,0.3);
                    ">✅ Update Client</button>
                </div>
            </div>
        `;

        document.body.appendChild(modal);

        // Add hover effects for inputs
        const inputs = modal.querySelectorAll('.edit-input');
        inputs.forEach(input => {
            input.addEventListener('focus', () => {
                input.style.borderColor = '#00ff88'; // Focus color
                input.style.background = 'rgba(255,255,255,0.15)';
                input.style.boxShadow = '0 0 10px rgba(0,255,136,0.3)';
            });
            input.addEventListener('blur', () => {
                input.style.borderColor = 'rgba(255,255,255,0.2)';
                input.style.background = 'rgba(255,255,255,0.1)';
                input.style.boxShadow = 'none';
            });
            input.addEventListener('mouseover', () => {
                input.style.borderColor = 'rgba(255,255,255,0.4)';
            });
            input.addEventListener('mouseout', () => {
                if (document.activeElement !== input) {
                    input.style.borderColor = 'rgba(255,255,255,0.2)';
                }
            });
        });

        // Add hover effects and click listeners for buttons
        const cancelBtn = modal.querySelector('.edit-cancel-btn');
        const updateBtn = modal.querySelector('.edit-update-btn');

        cancelBtn.addEventListener('click', () => modal.remove());

        updateBtn.addEventListener('click', () => {
            this.updateClient(index);
            modal.remove(); // Close modal after update
        });

        cancelBtn.addEventListener('mouseenter', () => {
            cancelBtn.style.background = 'rgba(255,255,255,0.2)';
            cancelBtn.style.borderColor = 'rgba(255,255,255,0.5)';
        });
        cancelBtn.addEventListener('mouseleave', () => {
            cancelBtn.style.background = 'rgba(255,255,255,0.1)';
            cancelBtn.style.borderColor = 'rgba(255,255,255,0.3)';
        });

        updateBtn.addEventListener('mouseenter', () => {
            updateBtn.style.transform = 'translateY(-2px)';
            updateBtn.style.boxShadow = '0 6px 20px rgba(0,200,81,0.4)';
        });
        updateBtn.addEventListener('mouseleave', () => {
            updateBtn.style.transform = 'translateY(0)';
            updateBtn.style.boxShadow = '0 4px 15px rgba(0,200,81,0.3)';
        });

        // Focus on first input
        setTimeout(() => {
            document.getElementById('editName').focus();
        }, 100);

        // Close modal when clicking outside
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });

        // Add keyframe styles for animations dynamically
        const styleSheet = document.styleSheets[0];
        styleSheet.insertRule(`
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
        `, styleSheet.cssRules.length);
        styleSheet.insertRule(`
            @keyframes slideInFromTop {
                from { transform: translateY(-50px); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }
        `, styleSheet.cssRules.length);
    }

    updateClient(index) {
        const name = document.getElementById('editName').value.trim();
        const email = document.getElementById('editEmail').value.trim();
        const phone = document.getElementById('editPhone').value.trim();
        const company = document.getElementById('editCompany').value.trim();
        const linkedin = document.getElementById('editLinkedin').value.trim();
        const notes = document.getElementById('editNotes').value.trim(); // Get notes field

        if (!name) {
            this.showStatus('❌ Name is required!', 'error');
            return;
        }

        // Validate email format if provided
        if (email && !this.isValidEmail(email)) {
            this.showStatus('❌ Please enter a valid email address', 'error');
            return;
        }

        // Update client data with all existing fields preserved
        const updatedClient = {
            ...this.clients[index], // Preserve existing fields like source, timestamp, etc.
            name: name,
            email: email,
            phone: phone,
            company: company,
            linkedIn: linkedin,
            notes: notes // Update notes field
        };

        // Update the client in the array
        this.clients[index] = updatedClient;

        // Save to localStorage
        this.saveClients();

        // Update display
        this.updateClientsTable();

        // Show success message
        this.showStatus('✅ Client updated successfully!', 'success');

        console.log('Client updated:', updatedClient);
    }
}

// Initialize the application when the page loads
document.addEventListener('DOMContentLoaded', () => {
    try {
        new ExhibitionCardReaderPro();
        console.log('🚀 Exhibition Card Reader Pro initialized successfully!');
    } catch (error) {
        console.error('❌ Error initializing application:', error);
        document.body.innerHTML = `
            <div style="text-align: center; padding: 50px; color: white;">
                <h1>❌ Application Error</h1>
                <p>Failed to initialize the card reader. Please refresh the page.</p>
                <p style="font-size: 0.9rem; opacity: 0.8;">Error: ${error.message}</p>
            </div>
        `;
    }
});

// Add some helpful keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
            case 's':
                e.preventDefault();
                document.getElementById('startCamera').click();
                break;
            case 'e':
                e.preventDefault();
                document.getElementById('exportData').click();
                break;
        }
    }
});
   </script>
</body>
</html>