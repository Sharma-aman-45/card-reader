<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Honeyman ExhibitionCardReaderPro.">
    <title>Exhibition Card Reader Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background:  #fdb26c;
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        .background-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
            animation: fadeInDown 1s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 15px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.4);
            font-weight: 700;
            background: linear-gradient(45deg, #fff, #f0f0f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.95;
            font-weight: 300;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1.2fr 0.8fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 25px;
            padding: 35px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
        }

        .card h2 {
            color: white;
            margin-bottom: 25px;
            font-size: 1.6rem;
            text-align: center;
            font-weight: 600;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .scanner-section {
            text-align: center;
        }

        .camera-container {
            position: relative;
            max-width: 100%;
            margin: 25px 0;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 15px 35px rgba(0,0,0,0.3);
            background: #000;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #video {
            width: 100%;
            height: auto;
            max-height: 400px;
            object-fit: cover;
            border-radius: 20px;
        }

        .camera-placeholder {
            color: rgba(255,255,255,0.7);
            font-size: 1.1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .camera-placeholder .icon {
            font-size: 3rem;
            opacity: 0.5;
        }

        #canvas {
            display: none;
        }

        .scanning-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(102, 126, 234, 0.1);
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: 20px;
        }

        .scanning-overlay.active {
            display: flex;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        .scan-line {
            width: 80%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ff00, transparent);
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateY(-100px); }
            100% { transform: translateY(100px); }
        }

        .upload-area {
            border: 3px dashed rgba(255,255,255,0.4);
            border-radius: 20px;
            padding: 40px 20px;
            text-align: center;
            margin: 25px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.05);
            color: white;
        }

        .upload-area:hover {
            border-color: rgba(255,255,255,0.8);
            background: rgba(255,255,255,0.1);
            transform: scale(1.02);
        }

        .upload-area.dragover {
            border-color: #00ff88;
            background: rgba(0,255,136,0.1);
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0,255,136,0.3);
        }

        .upload-area .icon {
            font-size: 2.5rem;
            margin-bottom: 15px;
            opacity: 0.8;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            margin: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .mode-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 0.9rem;
            padding: 8px 16px;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #e8ff1a,  #ff8800);
            border-color:  #ff8800;
            box-shadow: 0 4px 15px rgba(200, 113, 0, 0.822);
        }

        .mode-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
        }

        .mode-btn.active:hover {
            background: linear-gradient(135deg, #e8ff1a,  #ff8800);
            box-shadow: 0 6px 20px rgba(200, 113, 0, 0.822);
        }

        .btn.success {
            background:  #ff8800;
            color: white;
        }

        .btn.danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: white;
            font-size: 0.95rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .form-group input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 15px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.1);
            color: white;
            backdrop-filter: blur(10px);
        }

        .form-group input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .form-group input:focus {
            outline: none;
            border-color: #ffee00;
            box-shadow: 0 4px 15px rgba(200, 113, 0, 0.822);
            background: rgba(255,255,255,0.15);
        }
        .form-group textarea:focus {
            outline: none;
            border-color: #ffee00;
            box-shadow: 0 4px 15px rgba(200, 113, 0, 0.822);
            background: rgba(255,255,255,0.15);
        }
        .clients-table {
            grid-column: 1 / -1;
            overflow-x: auto;
            animation: fadeInUp 1s ease-out 0.3s both;
        }

        .table-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .stats {
            background: rgba(255,255,255,0.1);
            padding: 15px 25px;
            border-radius: 15px;
            color: white;
            font-weight: 600;
            backdrop-filter: blur(10px);
            margin-left: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        th, td {
            padding: 15px 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: white;
        }

        th {
            background: linear-gradient(135deg, #e8ff1a,  #ff8800);
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        tr:hover {
            background: rgba(255,255,255,0.1);
        }

        .linkedin-link {
            color: #fbff00;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        .linkedin-link:hover {
            color: #ffbb00;
            text-shadow: 0 0 5px rgba(200, 113, 0, 0.822);
        }

        .status-message {
            padding: 20px;
            border-radius: 15px;
            margin: 15px 0;
            text-align: center;
            font-weight: 600;
            backdrop-filter: blur(10px);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .success {
            background:  #ff8800;
            color: white;
            border: 2px solid rgba(200, 113, 0, 0.822);
            box-shadow: 0 0 20px rgba(200, 113, 0, 0.822);
        }

        .error {
            background: rgba(255, 68, 68, 0.2);
            color: #ff6b6b;
            border: 2px solid rgba(255, 107, 107, 0.3);
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.2);
        }

        .info {
            background:  #ff8800;
            color: white;
            border: 2px solid rgba(200, 113, 0, 0.822);
            box-shadow: 0 0 20px rgba(200, 113, 0, 0.822);
        }

        .file-input {
            display: none;
        }

        .processing {
            display: none;
            text-align: center;
            padding: 30px;
            color: white;
        }

        .spinner {
            border: 4px solid rgba(255,255,255,0.2);
            border-top: 4px solid #fbff00;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .detection-info {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            color: white;
            font-size: 0.9rem;
            backdrop-filter: blur(5px);
        }

        .source-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin: 2px;
        }

        .source-qr {
            background: linear-gradient(135deg, #e8ff1a,  #ff8800);
            color: white;
        }

        .source-ocr {
            background: linear-gradient(135deg, #e8ff1a,  #ff8800);
            color: white;
        }

        .source-manual {
            background: linear-gradient(135deg, #e8ff1a,  #ff8800);
            color: white;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 25px;
            }
            
            .header h1 {
                font-size: 2.5rem;
            }
            
            .card {
                padding: 25px;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            table {
                font-size: 0.85rem;
            }
            
            th, td {
                padding: 10px 8px;
            }
            
            .table-controls {
                flex-direction: column;
            }
            
            .stats {
                margin-left: 0;
                text-align: center;
            }
        }

        /* Mobile Responsive Table Styles */
        @media (max-width: 600px) {
            .clients-table {
                overflow-x: auto;
            }
            
            table {
                min-width: 800px;
                font-size: 0.75rem;
            }
            
            th, td {
                padding: 8px 6px;
                white-space: nowrap;
            }
            
            .table-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }
            
            .stats {
                font-size: 0.8rem;
                padding: 10px 15px;
            }
            
            /* Hide less important columns on mobile */
            .mobile-hide {
                display: none;
            }
            
            /* Make source badges smaller on mobile */
            .source-badge {
                font-size: 0.7rem;
                padding: 2px 8px;
            }
        }



        /* Category Selection Styles */
        .category-select {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            color: white;
            padding: 8px 12px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .category-select:focus {
            outline: none;
            border-color: #fffb00;
            box-shadow: 0 0 15px rgba(200, 113, 0, 0.822);
        }

        .category-select option {
            background: #333;
            color: white;
        }

        .category-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            margin: 2px;
        }

        .category-1 {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
        }

        .category-2 {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
        }

        .category-3 {
            background: linear-gradient(135deg, #45b7d1, #96c93d);
            color: white;
        }

        .category-4 {
            background: linear-gradient(135deg, #f9ca24, #f0932b);
            color: white;
        }

        /* Enhanced Drag and Drop Styles */
        .upload-area.dragover {
            border-color: #ffee00;
            background: rgba(200, 113, 0, 0.822);
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(200, 113, 0, 0.822);
        }

        .upload-area.dragover .icon {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* QR Reader Enhancement for Drag and Drop */
        .qr-reader-enhanced {
            position: relative;
            min-height: 200px;
            border-radius: 15px;
            overflow: hidden;
            background: rgba(0,0,0,0.8);
            border: 2px dashed rgba(255,255,255,0.3);
            transition: all 0.3s ease;
        }

        .qr-reader-enhanced.dragover {
            border: 3px solid #ffee00;
            box-shadow: 0 0 30px rgba(200, 113, 0, 0.822);
            background: rgba(200, 113, 0, 0.822);
            transform: scale(1.02);
        }

        .qr-reader-enhanced .drop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,255,136,0.15);
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 1.2rem;
            z-index: 1000;
            backdrop-filter: blur(5px);
            border-radius: 15px;
        }

        .qr-reader-enhanced.dragover .drop-overlay {
            display: flex;
            animation: pulse 1s infinite;
        }

        .qr-reader-enhanced:hover {
            border-color: rgba(255,255,255,0.5);
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }

        /* Image Editor Styles */
        #brightnessSlider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.2);
            outline: none;
            cursor: pointer;
        }

        #brightnessSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #e8ff1a,  #ff8800);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        #brightnessSlider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #e8ff1a,  #ff8800);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        #brightnessSlider::-webkit-slider-track {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }

        #brightnessSlider::-moz-range-track {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            height: 6px;
        }

        .control-group {
            transition: all 0.3s ease;
        }

        .control-group:hover {
            background: rgba(255,255,255,0.1) !important;
            transform: translateY(-2px);
        }

        #editorCanvas {
            transition: all 0.3s ease;
        }

        #editorCanvas:hover {
            border-color: rgba(255,255,255,0.5);
            box-shadow: 0 0 20px rgba(0,255,136,0.2);
        }
      


    </style>
</head>
<body>
    <div class="background-animation"></div>
    
    <div class="container">
        <div class="header">
            <img src="header image.jpeg" alt="" height="200px" width="50%">   
            <h5>🚀 Exhibition Card Reader </h5> 
        </div>

        <div class="main-content">
            <!-- Enhanced Scanner Section -->
            <div class="card">
                <h2>📱 Smart Scanner</h2>
                <div class="scanner-section">
                    <div class="camera-container">
                        <video id="video" autoplay playsinline></video>
                        <div class="camera-placeholder" id="cameraPlaceholder">
                            <div class="icon">📷</div>
                            <div>Click "Start Camera" to begin scanning business cards</div>
                        </div>
                    </div>
                    <div style="margin: 20px 0;">
                        <div style="text-align: center;">
                            <button id="startCamera" class="btn" style="margin-top: 10px; background: #ff8800;">🔴 Start Camera</button>
                            <button id="captureImage" class="btn" style="margin-top: 10px; background: #ff8800;">📸 Capture & Analyze</button>
                            <button id="stopCamera" class="btn" style="margin-top: 10px; background: #ff8800;">⏹️ Stop Camera</button>
                        </div>
                    </div>
                    <div class="detection-info">
                        <strong>🤖 Business Card Scanner:</strong> 
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li><strong>Camera Capture:</strong> Take photos of business cards for data extraction</li>
                            <li><strong>Drag & Drop:</strong> Upload business card images for processing</li>
                        </ul>
                        AI-powered extraction with immediate field population. Review and save your data.
                    </div>
                </div>

                <div class="upload-area" id="uploadArea">
                    <div class="icon">📁</div>
                    <p><strong>Drag & Drop Images Here</strong></p>
                    <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 10px;">
                        Supports QR codes, business cards, and contact images
                    </p>
                    <input type="file" id="fileInput" class="file-input" accept="image/*">
                    <button class="btn" style="margin-top: 10px; background: #ff8800;" onclick="document.getElementById('fileInput').click()">
                        Choose File
                    </button>
                </div>



                <div class="processing" id="processing">
                    <div class="spinner"></div>
                    <p>🔍 Analyzing image and extracting contact data...</p>
                </div>

                <!-- Result Display Section -->
                <div id="resultDisplay" style="display: none; background: rgba(255,255,255,0.1); border-radius: 15px; padding: 20px; margin: 20px 0; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2);">
                    <h3 style="color: white; margin-bottom: 15px; text-align: center;">📋 Extracted Data</h3>
                    <div id="extractedData" style="color: white; font-size: 0.9rem;">
                        <!-- Extracted data will be displayed here -->
                    </div>
                    <div style="text-align: center; margin-top: 15px;">
                        <button id="useExtractedData" class="btn success" style="margin: 5px;" onclick="">✅ Use This Data</button>
                        <button id="discardData" class="btn danger" style="margin: 5px;">❌ Discard</button>
                    </div>
                </div>

                <div id="statusMessage"></div>
            </div>

            <!-- Enhanced Manual Entry -->
            <div class="card">
                <h2>✍️ Manual Entry</h2>
                <form id="manualForm">
                    <div class="form-group">
                        <label for="manualName">👤 Full Name:</label>
                        <input type="text" id="manualName" placeholder="Enter client's full name">
                    </div>
                    
                    <div class="form-group">
                        <label for="manualEmail">📧 Email Address:</label>
                        <input type="email" id="manualEmail" placeholder="Enter email address">
                    </div>
                    
                    <div class="form-group">
                        <label for="manualPhone">📞 Phone Number:</label>
                        <input type="tel" id="manualPhone" placeholder="Enter phone number">
                    </div>
                    
                    <div class="form-group">
                        <label for="manualCompany">🏢 Company:</label>
                        <input type="text" id="manualCompany" placeholder="Enter company name (optional)">
                    </div>
                    <div class="form-group">
                        <label for="manualNotes">📝 Notes:</label>
                         <textarea name="" id="manualNotes" placeholder="Enter notes (optional)" style="width: 100%; height: 100px; border-radius: 2px; border: 1px solid #cccccc; padding: 10px; margin-top: 10px; background: transparent;"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="manualLinkedIn">💼 LinkedIn Profile:</label>
                        <input type="url" id="manualLinkedIn" placeholder="LinkedIn profile URL (optional)">
                    </div>
                    
                    <div class="form-group">
                        <label for="manualCategory">📂 Category:</label>
                        <select id="manualCategory" class="category-select">
                            <option value="">Select Category</option>
                            <option value="1">General</option>
                            <option value="2">Business</option>
                            <option value="3">Franchise</option>
                            <option value="4">Investors</option>
                            <option value="4">Others</option>
                        </select>
                    </div>
                    
                    <div style="text-align: center; margin-top: 30px;">
                        <button type="submit" class="btn success">➕ Add Client</button>
                        <button type="button" id="searchLinkedIn" class="btn" style="margin-top: 10px; background: #ff8800;">🔍 Find LinkedIn</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Quick Actions Section -->
        <div class="card">
            <h2>⚡ Quick Actions</h2>
            
                          <div class="table-controls" style="justify-content: center; gap: 15px;">
                  <button id="viewSavedData" class="btn text-white" style="background: #ff8800;">💾 View Saved Data</button>
                  <button id="exportData" class="btn success text-white">📊 Export CSV</button>
                  <button id="exportPDF" class="btn info text-white">📄 Export PDF</button>
                  <a href="login.html" class="btn text-white" style="background: #ff8800; text-decoration: none;">🔐 Login</a>
                  <div class="stats" id="clientStats">
                      📊 Total Clients: 0
                  </div>
              </div>
            
            <div style="text-align: center; margin-top: 20px; color: white; opacity: 0.8;">
                <p>📝 All scanned data is automatically saved. Use the buttons above to view, export, or integrate your data.</p>
               
            </div>
        </div>
        <div id="crmModal" class="modal" style="display: none; margin-top: 20px;">
            <div class="modal-content" style="max-width: 600px;">
                <div class="modal-header">
                    <h3>🔗 CRM Integration</h3>
                    <span class="close" style="height: 30px; width: 60px; margin-bottom: 10px; background-color: #ff8800; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer;" onclick="document.getElementById('crmModal').style.display='none'">close &times;</span>
                </div>
                <div class="modal-body">
                    <div class="crm-tabs">
                        <button class="crm-tab active text-white" data-tab="salesforce">Salesforce</button>
                        <button class="crm-tab text-white" data-tab="hubspot">HubSpot</button>
                        <button class="crm-tab text-white" data-tab="pipedrive">Pipedrive</button>
                        <button class="crm-tab  text-white" data-tab="zoho">Zoho CRM</button>
                        <button class="crm-tab  text-white" data-tab="custom">Custom API</button>
                    </div>
                    
                    <div class="crm-content">
                        <!-- Salesforce Tab -->
                        <div id="salesforce" class="crm-tab-content active">
                            <h4>Salesforce Integration</h4>
                            <p>Export data to Salesforce as leads or contacts.</p>
                            <div class="form-group">
                                <label>Instance URL:</label>
                                <input type="text" id="sfInstance" placeholder="https://yourcompany.salesforce.com" />
                            </div>
                            <div class="form-group">
                                <label>Access Token:</label>
                                <input type="password" id="sfToken" placeholder="Your Salesforce access token" />
                            </div>
                            <div class="form-group">
                                <label>Object Type:</label>
                                <select id="sfObject">
                                    <option value="Lead">Lead</option>
                                    <option value="Contact">Contact</option>
                                </select>
                            </div>
                            <button class="btn success text-white" onclick="app.exportToSalesforce()">Export to Salesforce</button>
                        </div>
                        
                        <!-- HubSpot Tab -->
                        <div id="hubspot" class="crm-tab-content">
                            <h4>HubSpot Integration</h4>
                            <p>Export data to HubSpot as contacts.</p>
                            <div class="form-group">
                                <label>API Key:</label>
                                <input type="password" id="hsApiKey" placeholder="Your HubSpot API key" />
                            </div>
                            <div class="form-group">
                                <label>Pipeline:</label>
                                <select id="hsPipeline">
                                    <option value="default">Default Pipeline</option>
                                </select>
                            </div>
                            <button class="btn success text-white" onclick="app.exportToHubSpot()">Export to HubSpot</button>
                        </div>
                        
                        <!-- Pipedrive Tab -->
                        <div id="pipedrive" class="crm-tab-content">
                            <h4>Pipedrive Integration</h4>
                            <p>Export data to Pipedrive as persons.</p>
                            <div class="form-group">
                                <label>API Token:</label>
                                <input type="password" id="pdToken" placeholder="Your Pipedrive API token" />
                            </div>
                            <div class="form-group">
                                <label>Deal Stage:</label>
                                <select id="pdStage">
                                    <option value="new">New</option>
                                    <option value="qualified">Qualified</option>
                                    <option value="proposal">Proposal</option>
                                </select>
                            </div>
                            <button class="btn success text-white" onclick="app.exportToPipedrive()">Export to Pipedrive</button>
                        </div>
                        
                        <!-- Zoho CRM Tab -->
                        <div id="zoho" class="crm-tab-content">
                            <h4>Zoho CRM Integration</h4>
                            <p>Export data to Zoho CRM as leads.</p>
                            <div class="form-group">
                                <label>Access Token:</label>
                                <input type="password" id="zohoToken" placeholder="Your Zoho CRM access token" />
                            </div>
                            <div class="form-group">
                                <label>Module:</label>
                                <select id="zohoModule">
                                    <option value="Leads">Leads</option>
                                    <option value="Contacts">Contacts</option>
                                </select>
                            </div>
                            <button class="btn success text-white" onclick="app.exportToZoho()">Export to Zoho CRM</button>
                            </div>
                        
                        <!-- Custom API Tab -->
                        <div id="custom" class="crm-tab-content">
                            <h4>Custom API Integration</h4>
                            <p>Export data to your custom CRM via API.</p>
                            <div class="form-group">
                                <label>API Endpoint:</label>
                                <input type="text" id="customEndpoint" placeholder="https://your-crm-api.com/contacts" />
                            </div>
                            <div class="form-group">
                                <label>API Key (Optional):</label>
                                <input type="password" id="customApiKey" placeholder="Your API key" />
                            </div>
                            <div class="form-group">
                                <label>Request Method:</label>
                                <select id="customMethod">
                                    <option value="POST">POST</option>
                                    <option value="PUT">PUT</option>
                                    <option value="PATCH">PATCH</option>
                                </select>
                            </div>
                            <button class="btn success text-white" onclick="app.exportToCustomAPI()">Export to Custom API</button>
                        </div>
                    </div>
                    
                    <div class="crm-status" id="crmStatus" style="display: none;">
                        <div class="status-content"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Libraries -->
    <!-- Enhanced OCR Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
    <script src="https://unpkg.com/opencv.js@1.2.1/opencv.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
   


    <script>
        // Helper class for the efficient name extraction
        class EfficientNameExtractor {
            constructor() {
                // Define name patterns with scoring weights
                this.namePatterns = [
                    // High confidence patterns (score: 10)
                    { pattern: /^[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/, score: 10, description: "Standard First Last" },
                    { pattern: /^[A-Z][a-z]{2,}\s+[A-Z]\.\s+[A-Z][a-z]{2,}$/, score: 10, description: "First M. Last" },
                    { pattern: /^[A-Z]\.\s+[A-Z][a-z]{2,}$/, score: 9, description: "F. Last" },
                    
                    // Medium confidence patterns (score: 7-8)
                    { pattern: /^[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/, score: 8, description: "First Middle Last" },
                    { pattern: /^[A-Z][a-z]{2,}\s+[A-Z][a-z]+-[A-Z][a-z]{2,}$/, score: 7, description: "First Hyphen-Last" },
                    { pattern: /^[A-Z][a-z]{2,}\s+[A-Z][a-z]+'[A-Z][a-z]{2,}$/, score: 7, description: "First O'Last" },
                    
                    // Title patterns (score: 8-9)
                    { pattern: /^Dr\.\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/i, score: 9, description: "Dr. First Last" },
                    { pattern: /^Mr\.\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/i, score: 9, description: "Mr. First Last" },
                    { pattern: /^Ms\.\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/i, score: 9, description: "Ms. First Last" },
                    { pattern: /^Mrs\.\s+[A-Z][a-z]{2,}\s+[A-Z][a-z]{2,}$/i, score: 9, description: "Mrs. First Last" },
                    
                    // Lower confidence patterns (score: 5-6)
                    { pattern: /^[A-Z]{2,}\s+[A-Z]{2,}$/, score: 6, description: "FIRST LAST" },
                    { pattern: /^[A-Z][a-z]{1,}\s+[A-Z][a-z]{1,}$/, score: 5, description: "Short names" },
                    { pattern: /^[A-Z][a-z]{2,}$/, score: 4, description: "Single name" },
                    
                    // Initials patterns (score: 6-7)
                    { pattern: /^[A-Z]\.\s+[A-Z]\.\s+[A-Z][a-z]{2,}$/, score: 7, description: "A.B. Last" },
                    { pattern: /^[A-Z][a-z]{2,}\s+[A-Z]\.\s+[A-Z]\.$/, score: 6, description: "First A.B." }
                ];
                
                // Common words that should be excluded from names
                this.excludeWords = new Set([
                    'the', 'and', 'or', 'for', 'with', 'from', 'to', 'in', 'on', 'at', 'by', 'of', 'a', 'an',
                    'inc', 'llc', 'corp', 'ltd', 'company', 'co', 'corporation', 'group', 'solutions', 
                    'services', 'technologies', 'tech', 'systems', 'associates', 'partners', 'consulting',
                    'email', 'phone', 'tel', 'fax', 'mobile', 'cell', 'office', 'home', 'work',
                    'address', 'street', 'avenue', 'road', 'drive', 'lane', 'blvd', 'suite', 'apt',
                    'www', 'http', 'https', 'com', 'org', 'net', 'edu', 'gov'
                ]);
                
                // Common first names for additional validation
                this.commonFirstNames = new Set([
                    'james', 'john', 'robert', 'michael', 'william', 'david', 'richard', 'joseph', 'thomas', 'christopher',
                    'charles', 'daniel', 'matthew', 'anthony', 'mark', 'donald', 'steven', 'paul', 'andrew', 'joshua',
                    'mary', 'patricia', 'jennifer', 'linda', 'elizabeth', 'barbara', 'susan', 'jessica', 'sarah', 'karen',
                    'nancy', 'lisa', 'betty', 'helen', 'sandra', 'donna', 'carol', 'ruth', 'sharon', 'michelle'
                ]);
            }
            
            /**
             * Extract name with scoring system - main method
             */
            extractName(text) {
                if (!text || typeof text !== 'string') {
                    return { name: '', confidence: 0, method: 'invalid_input' };
                }
                
                // Clean and prepare text
                const lines = this.preprocessText(text);
                if (lines.length === 0) {
                    return { name: '', confidence: 0, method: 'no_lines' };
                }
                
                // Try different extraction methods in order of reliability
                const methods = [
                    () => this.extractWithPatternMatching(lines),
                    () => this.extractWithPositionalLogic(lines),
                    () => this.extractWithHeuristics(lines)
                ];
                
                for (let i = 0; i < methods.length; i++) {
                    const result = methods[i]();
                    if (result.confidence >= 5) { // Minimum confidence threshold
                        return result;
                    }
                }
                
                return { name: '', confidence: 0, method: 'no_match' };
            }
            
            /**
             * Preprocess text into clean lines
             */
            preprocessText(text) {
                return text
                    .split(/[\n\r]+/)
                    .map(line => line.trim())
                    .filter(line => {
                        if (line.length < 2) return false;
                        if (line.includes('@')) return false;
                        if (/https?:\/\//.test(line)) return false;
                        if (/^\+?\d[\d\s\-\(\)]{7,}/.test(line)) return false;
                        if (/^\d+/.test(line)) return false;
                        return true;
                    })
                    .slice(0, 8);
            }
            
            /**
             * Method 1: Pattern matching with scoring
             */
            extractWithPatternMatching(lines) {
                let bestMatch = { name: '', confidence: 0, method: 'pattern_matching' };
                
                for (const line of lines) {
                    for (const { pattern, score, description } of this.namePatterns) {
                        if (pattern.test(line)) {
                            let adjustedScore = score;
                            
                            // Boost score if first name is common
                            const firstWord = line.split(/\s+/)[0].toLowerCase().replace(/[^a-z]/g, '');
                            if (this.commonFirstNames.has(firstWord)) {
                                adjustedScore += 2;
                            }
                            
                            // Boost score if it's in the first few lines
                            const lineIndex = lines.indexOf(line);
                            if (lineIndex === 0) adjustedScore += 3;
                            else if (lineIndex === 1) adjustedScore += 2;
                            else if (lineIndex === 2) adjustedScore += 1;
                            
                            // Penalty for very long lines
                            if (line.length > 40) adjustedScore -= 2;
                            
                            // Penalty if line contains excluded words
                            const words = line.toLowerCase().split(/\s+/);
                            const hasExcludedWords = words.some(word => this.excludeWords.has(word));
                            if (hasExcludedWords) adjustedScore -= 3;
                            
                            if (adjustedScore > bestMatch.confidence) {
                                bestMatch = {
                                    name: line.trim(),
                                    confidence: adjustedScore,
                                    method: `pattern_matching_${description}`
                                };
                            }
                        }
                    }
                }
                
                return bestMatch;
            }
            
            /**
             * Method 2: Positional logic
             */
            extractWithPositionalLogic(lines) {
                for (let i = 0; i < Math.min(lines.length, 3); i++) {
                    const line = lines[i];
                    
                    if (this.isLikelyName(line)) {
                        let confidence = 6 - i;
                        
                        if (/^[A-Z][a-z]+\s+[A-Z][a-z]+$/.test(line)) {
                            confidence += 3;
                        }
                        
                        return {
                            name: line.trim(),
                            confidence: confidence,
                            method: `positional_logic_line_${i + 1}`
                        };
                    }
                }
                
                return { name: '', confidence: 0, method: 'positional_logic' };
            }
            
            /**
             * Method 3: Heuristic-based extraction
             */
            extractWithHeuristics(lines) {
                const candidates = [];
                
                for (const line of lines) {
                    if (this.isLikelyName(line)) {
                        let score = 0;
                        
                        const wordCount = line.split(/\s+/).length;
                        if (wordCount === 2) score += 4;
                        else if (wordCount === 3) score += 3;
                        else if (wordCount === 1) score += 1;
                        else score -= 1;
                        
                        const words = line.split(/\s+/);
                        const properlyCapitalized = words.every(word => 
                            /^[A-Z][a-z]*$/.test(word) || /^[A-Z]\.$/.test(word)
                        );
                        if (properlyCapitalized) score += 3;
                        
                        if (line.length >= 4 && line.length <= 30) score += 2;
                        if (line.length > 40) score -= 3;
                        
                        const letterRatio = (line.match(/[a-zA-Z]/g) || []).length / line.length;
                        if (letterRatio > 0.85) score += 2;
                        
                        candidates.push({
                            name: line.trim(),
                            confidence: Math.max(0, score),
                            method: 'heuristic_analysis'
                        });
                    }
                }
                
                candidates.sort((a, b) => b.confidence - a.confidence);
                return candidates[0] || { name: '', confidence: 0, method: 'heuristics' };
            }
            
            /**
             * Check if a line is likely to be a name
             */
            isLikelyName(line) {
                if (!line || line.length < 2 || line.length > 50) return false;
                
                if (!/^[A-Za-z\s\.\-']+$/.test(line)) return false;
                
                if (line === line.toUpperCase()) {
                    const words = line.split(/\s+/);
                    if (words.length > 3 || words.some(word => word.length > 8)) return false;
                }
                
                const words = line.toLowerCase().split(/\s+/);
                if (words.some(word => this.excludeWords.has(word))) return false;
                
                if (words.length > 5) return false;
                
                if (words.some(word => word.length > 20)) return false;
                
                return true;
            }
        }

        class ExhibitionCardReaderPro {
            constructor() {
                try {
                    this.clients = this.loadClients();
                    this.stream = null;
                    this.cameraStarted = false;
                    this.isCapturing = false; // Prevent multiple captures
                    this.extractedData = null; // Store extracted data
                    
                    this.initializeEventListeners();
                    this.updateClientStats();
                    this.setupDragAndDrop();
                } catch (error) {
                    console.error('Error in constructor:', error);
                    throw error;
                }
            }

            initializeEventListeners() {
                // Helper function to safely add event listeners
                const safeAddEventListener = (elementId, event, handler) => {
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.addEventListener(event, handler);
                    } else {
                        console.warn(`Element with id '${elementId}' not found, skipping event listener`);
                    }
                };

                // Camera and capture controls
                safeAddEventListener('startCamera', 'click', () => this.startCamera());
                safeAddEventListener('captureImage', 'click', () => this.captureImage());
                safeAddEventListener('stopCamera', 'click', () => this.stopCamera());
                
                // File upload and form
                safeAddEventListener('fileInput', 'change', (e) => this.handleFileUpload(e));
                safeAddEventListener('manualForm', 'submit', (e) => this.handleManualEntry(e));
                safeAddEventListener('searchLinkedIn', 'click', () => this.searchLinkedIn());
                
                // Export and data management
                safeAddEventListener('exportData', 'click', () => this.exportToCSV());
                safeAddEventListener('exportPDF', 'click', () => this.exportToPDF());
                safeAddEventListener('viewSavedData', 'click', () => this.viewSavedData());
    
                safeAddEventListener('clearData', 'click', () => this.clearAllData());
                
                // Result display controls
                safeAddEventListener('useExtractedData', 'click', () => this.useExtractedData());
                safeAddEventListener('discardData', 'click', () => this.discardData());
            }

            setupDragAndDrop() {
                const uploadArea = document.getElementById('uploadArea');
                
                // Check if upload area exists
                if (!uploadArea) {
                    console.warn('Upload area not found, skipping drag and drop setup');
                    return;
                }
                
                // Enhanced drag and drop for upload area
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, this.preventDefaults, false);
                });

                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => {
                        uploadArea.classList.add('dragover');
                        this.showStatus('📁 Drop your business card image here!', 'info');
                    }, false);
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragover'), false);
                });

                uploadArea.addEventListener('drop', (e) => {
                    const files = e.dataTransfer.files;
                    console.log('Drop event triggered, files:', files);
                    if (files.length > 0) {
                        this.showStatus('📁 File dropped, processing business card...', 'info');
                        this.processImageFile(files[0]);
                        // Clear any file input to ensure fresh state
                        const fileInput = document.getElementById('fileInput');
                        if (fileInput) {
                            fileInput.value = '';
                        }
                    }
                }, false);
            }

            preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            async startCamera() {
                try {
                    this.stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'environment' } 
                    });
                    
                    const video = document.getElementById('video');
                    video.srcObject = this.stream;
                    document.getElementById('cameraPlaceholder').style.display = 'none';
                    document.getElementById('captureImage').disabled = false;
                    document.getElementById('startCamera').disabled = true;
                    
                    this.cameraStarted = true;
                    this.showStatus('📷 Camera started! Position the business card and click "Capture & Analyze"', 'success');
                } catch (error) {
                    this.showStatus('❌ Camera access denied: ' + error.message, 'error');
                }
            }

            stopCamera() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                document.getElementById('video').srcObject = null;
                document.getElementById('cameraPlaceholder').style.display = 'flex';
                document.getElementById('captureImage').disabled = true;
                document.getElementById('startCamera').disabled = false;
                
                this.cameraStarted = false;
                this.showStatus('⏹️ Camera stopped', 'info');
            }

            async captureImage() {
    if (this.isProcessing) {
        this.showStatus('⏳ Already processing, please wait...', 'info');
        return;
    }

    if (!this.cameraStarted) {
        this.showStatus('❌ Camera not started', 'error');
        return;
    }

    this.isProcessing = true;
    this.showStatus('📸 Capturing image...', 'info');

    try {
        const video = document.getElementById('video');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.drawImage(video, 0, 0);

        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.9));
        const file = new File([blob], 'captured-card.jpg', { type: 'image/jpeg' });
        
        // Process and save the image
        await this.processImageFile(file);
    } catch (error) {
        this.showStatus('❌ Failed to capture image: ' + error.message, 'error');
        this.isProcessing = false;
    }
}

            handleFileUpload(event) {
                const file = event.target.files[0];
                if (file) {
                    this.processImageFile(file);
                    event.target.value = ''; // Clear input
                }
            }

            async processImageFile(file) {
    if (!file.type.startsWith('image/')) {
        this.showStatus('❌ Please upload a valid image file', 'error');
        return;
    }

    this.isProcessing = true;
    this.showProcessing(true);
    this.showStatus('🔍 Analyzing business card...', 'info');

    try {
        // Extract text using OCR
        const text = await this.extractTextFromImage(file);
        console.log('Extracted text:', text);

        // Parse and display results
        const contactData = this.parseContactData(text);
        this.displayExtractedData(contactData);

        // Add this line to automatically save the extracted data
        if (contactData.name || contactData.email || contactData.phone) {
            this.addClient({
                ...contactData,
                source: 'Image Upload',
                timestamp: new Date().toLocaleString()
            });
        }

        this.showStatus('✅ Data extracted and saved successfully!', 'success');
    } catch (error) {
        console.error('Processing error:', error);
        this.showStatus('❌ Failed to process image: ' + error.message, 'error');
    } finally {
        this.isProcessing = false;
        this.showProcessing(false);
    }
}

            async extractTextFromImage(file) {
                return new Promise((resolve, reject) => {
                    Tesseract.recognize(file, 'eng', {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                this.showStatus(`🔍 OCR Progress: ${Math.round(m.progress * 100)}%`, 'info');
                            }
                        }
                    }).then(({ data: { text } }) => {
                        resolve(text);
                    }).catch(reject);
                });
            }

            parseContactData(text) {
                const data = {
                    name: '',
                    email: '',
                    phone: '',
                    company: '',
                    jobTitle: '',
                    website: '',
                    address: '',
                    notes: ''
                };

                const lines = text.split('\n').filter(line => line.trim().length > 0);

                // Extract email
                const emailMatch = text.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/);
                if (emailMatch) {
                    data.email = emailMatch[0];
                }

                // Extract phone numbers
                const phoneMatches = text.match(/(?:\+?[\d\s\-\(\)]{10,20})/g);
                if (phoneMatches && phoneMatches.length > 0) {
                    data.phone = phoneMatches[0].trim();
                }

                // Extract website
                const websiteMatch = text.match(/https?:\/\/[^\s]+/g);
                if (websiteMatch) {
                    data.website = websiteMatch[0];
                }

                // Extract name (usually in first few lines, properly capitalized)
                for (let i = 0; i < Math.min(3, lines.length); i++) {
                    const line = lines[i].trim();
                    if (line && /^[A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3}$/.test(line)) {
                        data.name = line;
                        break;
                    }
                }

                // Extract company (look for company patterns)
                const companyPatterns = [
                    /(.*?)\s+(Inc\.?|LLC|Corp\.?|Ltd\.?|Company|Co\.?|Corporation|Group|Solutions|Services|Technologies|Tech|Systems)/i,
                    /^[A-Z][a-zA-Z\s&]+(?:Inc\.?|LLC|Corp\.?|Ltd\.?)$/i
                ];

                for (const line of lines) {
                    for (const pattern of companyPatterns) {
                        const match = line.match(pattern);
                        if (match && !data.company) {
                            data.company = line.trim();
                            break;
                        }
                    }
                    if (data.company) break;
                }

                // Extract job title (look for common job titles)
                const jobTitles = ['CEO', 'CTO', 'CFO', 'Manager', 'Director', 'President', 'Vice President', 'VP', 'Senior', 'Lead', 'Head of', 'Chief'];
                for (const line of lines) {
                    for (const title of jobTitles) {
                        if (line.toLowerCase().includes(title.toLowerCase())) {
                            data.jobTitle = line.trim();
                            break;
                        }
                    }
                    if (data.jobTitle) break;
                }

                // Extract address (lines with street patterns)
                const addressPatterns = [/street/i, /avenue/i, /road/i, /drive/i, /lane/i, /blvd/i, /suite/i, /apt/i];
                for (const line of lines) {
                    if (addressPatterns.some(pattern => pattern.test(line))) {
                        data.address = line.trim();
                        break;
                    }
                }

                return data;
            }

            displayExtractedData(data) {
                this.extractedData = data;
                const resultDiv = document.getElementById('resultDisplay');
                const dataDiv = document.getElementById('extractedData');
                
                let html = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">';
                
                Object.entries(data).forEach(([key, value]) => {
                    if (value) {
                        const label = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
                        html += `<div><strong>${label}:</strong> ${value}</div>`;
                    }
                });
                
                html += '</div>';
                
                if (Object.values(data).some(v => v)) {
                    dataDiv.innerHTML = html;
                    resultDiv.style.display = 'block';
                } else {
                    dataDiv.innerHTML = '<p style="text-align: center; opacity: 0.7;">No data could be extracted from this image.</p>';
                    resultDiv.style.display = 'block';
                }
            }

            useExtractedData() {
                if (this.extractedData) {
                    this.populateForm(this.extractedData);
                    document.getElementById('resultDisplay').style.display = 'none';
                    this.showStatus('✅ Data applied to form! Review and save.', 'success');
                }
            }

            discardData() {
                this.extractedData = null;
                document.getElementById('resultDisplay').style.display = 'none';
                this.showStatus('🗑️ Extracted data discarded', 'info');
            }

            populateForm(data) {
                Object.keys(data).forEach(key => {
                    const element = document.getElementById(key);
                    if (element && data[key]) {
                        element.value = data[key];
                    }
                });
            }

            /**
             * Setup global drag and drop fallback for QR reader
             */
            setupGlobalDragAndDrop() {
                // Add global drop handler for the entire document
                document.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);

                document.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Check if drop is in QR reader area
                    const qrReader = document.getElementById('qr-reader');
                    if (qrReader && qrReader.contains(e.target)) {
                        const files = e.dataTransfer.files;
                        if (files.length > 0) {
                            const file = files[0];
                            if (file.type.startsWith('image/')) {
                                this.showStatus('📱 Processing dropped image for QR codes...', 'info');
                                try {
                                    this.processImageFile(file);
                                } catch (error) {
                                    console.error('Error processing dropped file:', error);
                                    this.showStatus('❌ Error processing dropped image', 'error');
                                }
                            } else {
                                this.showStatus('❌ Please drop an image file', 'error');
                            }
                        }
                    }
                }, false);
            }

            /**
             * Clear file input to allow re-uploading the same file
             */
            clearFileInput() {
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    fileInput.value = '';
                }
            }





            async captureAndAnalyze() {
                if (!this.cameraStarted) {
                    this.showStatus('❌ Camera not started.', 'error');
                    return;
                }
                
                this.showProcessing(true);
                try {
                    // Get the video element from html5-qrcode
                    const video = document.querySelector('#qr-reader video');
                    if (!video) {
                        this.showStatus('❌ Video stream not found.', 'error');
                        this.showProcessing(false);
                        return;
                    }
                    
                    // Create canvas and capture frame
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    canvas.getContext('2d').drawImage(video, 0, 0);
                    const imageDataUrl = canvas.toDataURL('image/png');
                    
                    // Try QR scan from image
                    const qrResult = await this.scanQRCodeFromImage(imageDataUrl);
                    if (qrResult) {
                        await this.processQRResult(qrResult, 'Camera QR');
                } else {
                        this.showStatus('🔄 No QR found, running OCR...', 'info');
                        await this.analyzeImageWithOCR(imageDataUrl, 'Camera OCR');
                    }
                } catch (err) {
                    this.showStatus('❌ Error during capture: ' + err.message, 'error');
                } finally {
                    this.showProcessing(false);
                    this.stopCamera();
                }
            }

            async scanQRCodeFromImage(imageDataUrl) {
        console.log('Starting enhanced QR code scanning...');
        
        try {
            // Method 1: HTML5-QRCode (most reliable for files)
            const html5Result = await this.tryHtml5QrCode(imageDataUrl);
            if (html5Result) {
                console.log('✅ HTML5-QRCode succeeded');
                return html5Result;
            }

            // Method 2: QR-Scanner library (if available)
            const qrScannerResult = await this.tryQrScanner(imageDataUrl);
            if (qrScannerResult) {
                console.log('✅ QR-Scanner succeeded');
                return qrScannerResult;
            }

            // Method 3: jsQR with multiple image variations
            const jsQrResult = await this.tryJsQRWithVariations(imageDataUrl);
            if (jsQrResult) {
                console.log('✅ jsQR with variations succeeded');
                return jsQrResult;
            }

            // Method 4: Try with different image formats
            const formatResult = await this.tryDifferentFormats(imageDataUrl);
            if (formatResult) {
                console.log('✅ Format conversion succeeded');
                return formatResult;
            }

            console.log('❌ All QR scanning methods failed');
            return null;

        } catch (error) {
            console.error('QR scanning error:', error);
            return null;
        }
    }
    async tryHtml5QrCode(imageDataUrl) {
        if (!this.qrLibraries.html5QrCode) return null;

        try {
            const html5QrCode = new this.qrLibraries.html5QrCode("qr-reader");
            
            // Convert data URL to blob
            const response = await fetch(imageDataUrl);
            const blob = await response.blob();
            
            // Try with different configurations
            const configs = [
                { fps: 10, qrbox: { width: 250, height: 250 } },
                { fps: 10, qrbox: { width: 150, height: 150 } },
                { fps: 10, qrbox: { width: 350, height: 350 } },
                { fps: 5, aspectRatio: 1.0 }
            ];

            for (const config of configs) {
                try {
                    const result = await html5QrCode.scanFile(blob, true);
                    if (result) return result;
                } catch (e) {
                    continue;
                }
            }
            return null;
        } catch (error) {
            console.log('HTML5-QRCode failed:', error);
            return null;
        }
    }
    async tryQrScanner(imageDataUrl) {
        if (!this.qrLibraries.qrScanner) return null;

        try {
            const img = await this.createImageFromDataUrl(imageDataUrl);
            const result = await this.qrLibraries.qrScanner.scanImage(img);
            return result;
        } catch (error) {
            console.log('QR-Scanner failed:', error);
            return null;
        }
    }async tryJsQRWithVariations(imageDataUrl) {
        if (!this.qrLibraries.jsQR) return null;

        try {
            const img = await this.createImageFromDataUrl(imageDataUrl);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            // Create multiple image variations
            const variations = await this.createImageVariations(canvas, ctx);

            // Try each variation
            for (let i = 0; i < variations.length; i++) {
                const imageData = variations[i];
                const code = this.qrLibraries.jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: "dontInvert"
                });
                
                if (code && code.data) {
                    console.log(`jsQR succeeded with variation ${i}`);
                    return code.data;
                }
            }

            // Try with inversionAttempts
            const originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const codeWithInversion = this.qrLibraries.jsQR(
                originalImageData.data, 
                originalImageData.width, 
                originalImageData.height, 
                {
                    inversionAttempts: "attemptBoth"
                }
            );
            
            if (codeWithInversion && codeWithInversion.data) {
                console.log('jsQR succeeded with inversion attempts');
                return codeWithInversion.data;
            }

            return null;
        } catch (error) {
            console.log('jsQR with variations failed:', error);
            return null;
        }
    }

    async tryDifferentFormats(imageDataUrl) {
        try {
            const img = await this.createImageFromDataUrl(imageDataUrl);
            const formats = ['image/png', 'image/jpeg', 'image/webp'];
            
            for (const format of formats) {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    
                    const newDataUrl = canvas.toDataURL(format, 0.95);
                    const result = await this.tryJsQRWithVariations(newDataUrl);
                    
                    if (result) {
                        console.log(`Format conversion to ${format} succeeded`);
                        return result;
                    }
                } catch (formatError) {
                    continue;
                }
            }
            return null;
        } catch (error) {
            console.log('Format conversion failed:', error);
            return null;
        }
    }
    preprocessImage(canvas, ctx) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Convert to grayscale and increase contrast
        for (let i = 0; i < data.length; i += 4) {
            const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
            
            // Increase contrast
            const contrast = 1.5;
            const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
            const enhancedGray = Math.min(255, Math.max(0, factor * (gray - 128) + 128));
            
            data[i] = enhancedGray;     // Red
            data[i + 1] = enhancedGray; // Green
            data[i + 2] = enhancedGray; // Blue
        }
        
        ctx.putImageData(imageData, 0, 0);
        return imageData;
    }

    // Create multiple variations of the image for better detection
    async createImageVariations(originalCanvas, originalCtx) {
        const variations = [];
        const width = originalCanvas.width;
        const height = originalCanvas.height;

        // Original image
        variations.push(originalCtx.getImageData(0, 0, width, height));

        // Preprocessed image
        const preprocessedCanvas = document.createElement('canvas');
        const preprocessedCtx = preprocessedCanvas.getContext('2d');
        preprocessedCanvas.width = width;
        preprocessedCanvas.height = height;
        preprocessedCtx.drawImage(originalCanvas, 0, 0);
        variations.push(this.preprocessImage(preprocessedCanvas, preprocessedCtx));

        // Inverted image (for cases where QR code is white on black)
        const invertedCanvas = document.createElement('canvas');
        const invertedCtx = invertedCanvas.getContext('2d');
        invertedCanvas.width = width;
        invertedCanvas.height = height;
        invertedCtx.drawImage(originalCanvas, 0, 0);
        const invertedImageData = invertedCtx.getImageData(0, 0, width, height);
        const invertedData = invertedImageData.data;
        
        for (let i = 0; i < invertedData.length; i += 4) {
            invertedData[i] = 255 - invertedData[i];         // Red
            invertedData[i + 1] = 255 - invertedData[i + 1]; // Green
            invertedData[i + 2] = 255 - invertedData[i + 2]; // Blue
        }
        invertedCtx.putImageData(invertedImageData, 0, 0);
        variations.push(invertedImageData);

        // Scaled versions for small QR codes
        if (width > 400 || height > 400) {
            const scaledCanvas = document.createElement('canvas');
            const scaledCtx = scaledCanvas.getContext('2d');
            scaledCanvas.width = width * 1.5;
            scaledCanvas.height = height * 1.5;
            scaledCtx.imageSmoothingEnabled = false;
            scaledCtx.drawImage(originalCanvas, 0, 0, scaledCanvas.width, scaledCanvas.height);
            variations.push(scaledCtx.getImageData(0, 0, scaledCanvas.width, scaledCanvas.height));
        }

        return variations;
    }

    createImageFromDataUrl(dataUrl) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = dataUrl;
        });
    }


    validateClientData(clientData) {
        if (!clientData || typeof clientData !== 'object') {
            return false;
        }

        // Check if at least one valid contact field exists
        const hasName = clientData.name && clientData.name.trim().length > 0;
        const hasEmail = clientData.email && this.isValidEmail(clientData.email);
        const hasPhone = clientData.phone && clientData.phone.trim().length > 0;

        return hasName || hasEmail || hasPhone;
    }

    isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }




            /**
             * Process business card with AI vision for better accuracy
             */
            async processBusinessCardWithAI(blob, canvas) {
                try {
                    this.showStatus('📸 Captured business card image', 'info');
                    
                    // Show processing time indicator
                    const startTime = Date.now();
                    this.showStatus('⏱️ Processing business card with AI vision...', 'info');
                    
                    // Display the captured image on screen and wait for user confirmation
                    await this.displayCapturedImageAndWait(canvas, blob);
                    
                    // Calculate and show processing time
                    const processingTime = Date.now() - startTime;
                    this.showStatus(`✅ AI processing completed in ${processingTime}ms`, 'success');
                    
                } catch (error) {
                    console.error('AI processing error:', error);
                    this.showStatus('❌ AI processing failed, trying OCR fallback...', 'warning');
                    await this.processImageFile(blob);
                }
            }

            /**
             * Display captured image on screen and wait for user confirmation
             */
            async displayCapturedImageAndWait(canvas, blob) {
                return new Promise((resolve, reject) => {
                    // Create image preview container if it doesn't exist
                    let previewContainer = document.getElementById('imagePreview');
                    if (!previewContainer) {
                        previewContainer = document.createElement('div');
                        previewContainer.id = 'imagePreview';
                        previewContainer.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background: white;
                            border: 2px solid #007bff;
                            border-radius: 10px;
                            padding: 10px;
                            z-index: 1000;
                            max-width: 80vw;
                            max-height: 80vh;
                            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                        `;
                        document.body.appendChild(previewContainer);
                    }
                    
                    // Clear previous content
                    previewContainer.innerHTML = '';
                    previewContainer.style.display = 'block';
                    
                    // Add image
                    const img = document.createElement('img');
                    img.src = canvas.toDataURL('image/jpeg', 0.9);
                    img.style.cssText = 'max-width: 100%; max-height: 70vh; border-radius: 5px;';
                    
                    // Add controls
                    const controls = document.createElement('div');
                    controls.style.cssText = 'text-align: center; margin-top: 10px;';
                    controls.innerHTML = `
                        <button id="confirmImage" class="btn btn-success" style="margin-right: 10px;">
                            ✅ Confirm & Process
                        </button>
                        <button id="retakeImage" class="btn btn-secondary">
                            📸 Retake
                        </button>
                    `;
                    
                    previewContainer.appendChild(img);
                    previewContainer.appendChild(controls);
                    
                    // Add event listeners
                    document.getElementById('confirmImage').addEventListener('click', async () => {
                        previewContainer.style.display = 'none';
                        this.showStatus('🤖 Processing confirmed business card with AI...', 'info');
                        
                        try {
                            // Convert blob to base64 for AI processing
                            const base64Image = await this.blobToBase64(blob);
                            
                            // Extract data using Mindee API (if available) or fallback to AI vision
                            const clientData = await this.extractBusinessCardDataWithMindee(base64Image);
                            
                            if (clientData && (clientData.name || clientData.email || clientData.phone)) {
                                // Add image data to client data
                                clientData.imageData = base64Image;
                                await this.addClientWithLinkedInSearch(clientData, 'AI Business Card Scanner');
                                this.showStatus('✅ Business card data extracted successfully with AI!', 'success');
                                resolve();
                            } else {
                                // Fallback to OCR if AI extraction fails
                                this.showStatus('🔄 AI extraction incomplete, trying OCR fallback...', 'info');
                                await this.processImageFile(blob);
                                resolve();
                            }
                        } catch (error) {
                            console.error('Error processing confirmed image:', error);
                            this.showStatus('❌ AI processing failed, trying OCR fallback...', 'warning');
                            await this.processImageFile(blob);
                            resolve();
                        }
                    });
                    
                    document.getElementById('retakeImage').addEventListener('click', () => {
                        previewContainer.style.display = 'none';
                        this.isCapturing = false;
                        this.showStatus('📸 Ready to capture new image', 'info');
                        reject(new Error('User chose to retake image'));
                    });
                    
                    // Auto-hide after 15 seconds
                    setTimeout(() => {
                        if (previewContainer.style.display !== 'none') {
                            previewContainer.style.display = 'none';
                            this.isCapturing = false;
                            this.showStatus('⏰ Image preview timed out', 'warning');
                            reject(new Error('Image preview timed out'));
                        }
                    }, 15000);
                });
            }

            /**
             * Display captured image on screen for user confirmation (legacy method)
             */
            displayCapturedImage(canvas) {
                // Create image preview container if it doesn't exist
                let previewContainer = document.getElementById('imagePreview');
                if (!previewContainer) {
                    previewContainer = document.createElement('div');
                    previewContainer.id = 'imagePreview';
                    previewContainer.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: white;
                        border: 2px solid #007bff;
                        border-radius: 10px;
                        padding: 10px;
                        z-index: 1000;
                        max-width: 80vw;
                        max-height: 80vh;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                    `;
                    document.body.appendChild(previewContainer);
                }
                
                // Clear previous content
                previewContainer.innerHTML = '';
                
                // Add image
                const img = document.createElement('img');
                img.src = canvas.toDataURL('image/jpeg', 0.9);
                img.style.cssText = 'max-width: 100%; max-height: 70vh; border-radius: 5px;';
                
                // Add controls
                const controls = document.createElement('div');
                controls.style.cssText = 'text-align: center; margin-top: 10px;';
                controls.innerHTML = `
                    <button id="confirmImage" class="btn btn-success" style="margin-right: 10px;">
                        ✅ Confirm & Process
                    </button>
                    <button id="retakeImage" class="btn btn-secondary">
                        📸 Retake
                    </button>
                `;
                
                previewContainer.appendChild(img);
                previewContainer.appendChild(controls);
                
                // Add event listeners
                document.getElementById('confirmImage').addEventListener('click', () => {
                    previewContainer.style.display = 'none';
                    this.processConfirmedImage(blob);
                });
                
                document.getElementById('retakeImage').addEventListener('click', () => {
                    previewContainer.style.display = 'none';
                    this.isCapturing = false;
                });
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    if (previewContainer.style.display !== 'none') {
                        previewContainer.style.display = 'none';
                    }
                }, 10000);
            }

            /**
             * Convert blob to base64 for AI processing
             */
            blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }



            /**
             * Extract business card data using Mindee API with OCR fallback
             */
            async extractBusinessCardDataWithMindee(base64Image) {
                try {
                    this.showStatus('🤖 Processing with Mindee AI...', 'info');
                    console.log('Starting Mindee API extraction...');
                    
                    // Use Mindee API for extraction
                    const mindeeResult = await this.mindeeAPI.extractBusinessCardData(base64Image, false); // false for sync
                    console.log('Mindee API result:', mindeeResult);
                    
                    if (mindeeResult && (mindeeResult.name || mindeeResult.email || mindeeResult.phone)) {
                        this.showStatus(`✅ Mindee extraction completed (${mindeeResult.confidence ? Math.round(mindeeResult.confidence * 100) : 'Unknown'}% confidence)`, 'success');
                        
                        // Convert Mindee result to our format
                        return {
                            name: mindeeResult.name || '',
                            email: mindeeResult.email || '',
                            phone: mindeeResult.phone || '',
                            company: mindeeResult.company || '',
                            linkedIn: mindeeResult.website || '', // Use website as LinkedIn for now
                            jobTitle: mindeeResult.jobTitle || '',
                            address: mindeeResult.address || '',
                            confidence: mindeeResult.confidence || 0,
                            source: 'Mindee AI'
                        };
                    } else {
                        console.log('Mindee extraction failed or no data found, falling back to OCR');
                        this.showStatus('🔄 Mindee extraction incomplete, falling back to OCR...', 'info');
                        return await this.extractBusinessCardDataWithAI(base64Image);
                    }
                } catch (error) {
                    console.error('Mindee API error:', error);
                    this.showStatus('❌ Mindee API failed, falling back to OCR...', 'warning');
                    return await this.extractBusinessCardDataWithAI(base64Image);
                }
            }

            /**
             * Enhanced OCR text extraction using Tesseract.js with better configuration
             */
            async extractTextFromImage(imageData) {
                try {
                    this.showStatus('🔍 Extracting text from image...', 'info');
                    
                    const { data: { text } } = await Tesseract.recognize(
                        imageData,
                        'eng',
                        {
                            logger: m => {
                                if (m.status === 'recognizing text') {
                                    this.showStatus(`🔍 OCR Progress: ${Math.round(m.progress * 100)}%`, 'info');
                                }
                            },
                            // Enhanced OCR settings for better business card recognition
                            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@.-_+() /\\',
                            preserve_interword_spaces: '1',
                            tessedit_pageseg_mode: '6' // Assume uniform block of text
                        }
                    );
                    
                    console.log('Extracted text:', text);
                    return text;
                } catch (error) {
                    console.error('OCR extraction error:', error);
                    throw error;
                }
            }

            /**
             * Extract business card data using enhanced OCR
             */
            async extractBusinessCardDataWithOCR(base64Image) {
                try {
                    // Show processing status
                    this.showStatus('🔍 Processing image with enhanced OCR...', 'info');
                    
                    // Create a temporary canvas to process the image
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    return new Promise((resolve) => {
                        img.onload = () => {
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            
                            // Use Tesseract.js for enhanced OCR with better configuration
                            Tesseract.recognize(canvas, 'eng', {
                                logger: m => {
                                    if (m.status === 'recognizing text') {
                                        this.showStatus(`🔍 OCR Processing: ${Math.round(m.progress * 100)}%`, 'info');
                                    }
                                },
                                // Enhanced OCR settings for business cards
                                tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@.-_+() ',
                                preserve_interword_spaces: '1'
                            }).then(({ data: { text } }) => {
                                console.log('OCR Text:', text);
                                
                                // Enhanced extraction with improved patterns
                                const clientData = this.extractBusinessCardDataFromText(text);
                                
                                // Verify extracted data quality
                                const verificationScore = this.verifyExtractedData(clientData);
                                console.log('Data verification score:', verificationScore);
                                
                                if (verificationScore >= 0.6) {
                                    this.showStatus('✅ OCR extraction completed with high confidence', 'success');
                                } else if (verificationScore >= 0.3) {
                                    this.showStatus('⚠️ OCR extraction completed with medium confidence', 'info');
                                } else {
                                    this.showStatus('❌ OCR extraction completed with low confidence', 'warning');
                                }
                                
                                resolve(clientData);
                            }).catch(error => {
                                console.error('OCR Error:', error);
                                this.showStatus('❌ OCR processing failed', 'error');
                                resolve(null);
                            });
                        };
                        img.src = base64Image;
                    });
                    
                } catch (error) {
                    console.error('OCR extraction error:', error);
                    return null;
                }
            }

            /**
             * Verify the quality of extracted data
             */
            verifyExtractedData(clientData) {
                let score = 0;
                let totalChecks = 0;
                
                // Check name quality
                if (clientData.name) {
                    totalChecks++;
                    const nameWords = clientData.name.split(' ').filter(word => word.length > 0);
                    if (nameWords.length >= 2 && nameWords.every(word => /^[A-Za-z]+$/.test(word))) {
                        score += 0.3; // Good name format
                    } else if (nameWords.length >= 1) {
                        score += 0.1; // Basic name
                    }
                }
                
                // Check email quality
                if (clientData.email) {
                    totalChecks++;
                    if (this.isValidEmail(clientData.email)) {
                        score += 0.3; // Valid email
                    } else {
                        score += 0.1; // Invalid but present
                    }
                }
                
                // Check phone quality
                if (clientData.phone) {
                    totalChecks++;
                    const cleanPhone = clientData.phone.replace(/[^\d+]/g, '');
                    if (cleanPhone.length >= 7) {
                        score += 0.2; // Valid phone
                    } else {
                        score += 0.05; // Invalid but present
                    }
                }
                
                // Check company quality
                if (clientData.company) {
                    totalChecks++;
                    if (clientData.company.length >= 3) {
                        score += 0.2; // Valid company
                    }
                }
                
                return totalChecks > 0 ? score / totalChecks : 0;
            }

            /**
             * Enhanced business card data extraction with notes field
             */
            extractBusinessCardDataFromText(text) {
                const clientData = { name: '', email: '', phone: '', company: '', notes: '', jobTitle: '', website: '' };
                
                // Clean and normalize text
                const cleanText = text.replace(/\s+/g, ' ').trim();
                const lines = cleanText.split('\n').filter(line => line.trim().length > 0);
                
                console.log('Processing business card text:', cleanText);
                
                // Extract emails (highest priority)
                const emails = this.extractEmails(cleanText);
                if (emails.length > 0) {
                    clientData.email = emails[0];
                    console.log('Found email:', clientData.email);
                }
                
                // Extract phone numbers
                const phones = this.extractPhoneNumbers(cleanText);
                if (phones.length > 0) {
                    clientData.phone = phones[0];
                    console.log('Found phone:', clientData.phone);
                }
                
                // Extract name with enhanced patterns
                clientData.name = this.extractNameFromBusinessCard(lines, emails, phones);
                if (clientData.name) {
                    console.log('Found name:', clientData.name);
                }
                
                // Extract company with enhanced patterns
                clientData.company = this.extractCompanyFromBusinessCard(lines, emails, phones);
                if (clientData.company) {
                    console.log('Found company:', clientData.company);
                }
                
                // Store additional info in notes
                const additionalInfo = [];
                if (emails.length > 1) additionalInfo.push(`Additional emails: ${emails.slice(1).join(', ')}`);
                if (phones.length > 1) additionalInfo.push(`Additional phones: ${phones.slice(1).join(', ')}`);
                
                // Extract website if found
                const websiteMatch = cleanText.match(/https?:\/\/[^\s]+/g);
                if (websiteMatch) {
                    additionalInfo.push(`Website: ${websiteMatch[0]}`);
                }
                
                if (additionalInfo.length > 0) {
                    clientData.notes = additionalInfo.join('; ');
                }
                
                return clientData;
            }

            /**
             * Extract name from business card with enhanced patterns
             */
            extractNameFromBusinessCard(lines, emails, phones) {
                // Priority 1: Look for name patterns in first few lines
                for (let i = 0; i < Math.min(3, lines.length); i++) {
                    const line = lines[i].trim();
                    
                    // Skip if line contains email or phone
                    if (emails.some(email => line.includes(email)) || 
                        phones.some(phone => line.includes(phone))) {
                        continue;
                    }
                    
                    // Enhanced name patterns
                    const namePatterns = [
                        /^[A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3}$/, // "John Doe"
                        /^[A-Z][a-z]+\s+[A-Z]\.\s*[A-Z][a-z]+$/, // "John M. Doe"
                        /^[A-Z][a-z]+\s+[A-Z][a-z]+$/, // "John Doe"
                        /^[A-Z][a-z]+$/, // Single name
                    ];
                    
                    for (const pattern of namePatterns) {
                        if (pattern.test(line)) {
                            const nameExtractor = new EfficientNameExtractor();
                            const result = nameExtractor.extractName(line);
                            if (result.confidence >= 5) {
                                return this.validateNameWithDataset(result.name);
                            }
                        }
                    }
                }
                
                // Priority 2: Extract from email prefix
                if (emails.length > 0) {
                    const emailPrefix = emails[0].split('@')[0];
                    const nameFromEmail = emailPrefix
                        .replace(/[^a-zA-Z]/g, ' ')
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    if (nameFromEmail.split(' ').length <= 3) {
                        const nameExtractor = new EfficientNameExtractor();
                        const result = nameExtractor.extractName(nameFromEmail);
                        if (result.confidence >= 4) {
                            return this.validateNameWithDataset(result.name);
                        }
                    }
                }
                
                return '';
            }

            /**
             * Extract company from business card with enhanced patterns
             */
            extractCompanyFromBusinessCard(lines, emails, phones) {
                // Look for company patterns
                const companyPatterns = [
                    /(.*?)\s+(Inc\.?|LLC|Corp\.?|Ltd\.?|Company|Co\.?|Corporation|Group|Solutions|Services|Technologies|Tech|Systems|Associates|Partners|Consulting)(?!\w)/i,
                    /^[A-Z][a-zA-Z\s&]+(?:Inc\.?|LLC|Corp\.?|Ltd\.?)$/i,
                    /^[A-Z][a-zA-Z\s&]{3,}$/i // Standalone company names
                ];
                
                for (const line of lines) {
                    const cleanLine = line.trim();
                    
                    // Skip if line contains email or phone
                    if (emails.some(email => cleanLine.includes(email)) || 
                        phones.some(phone => cleanLine.includes(phone))) {
                        continue;
                    }
                    
                    for (const pattern of companyPatterns) {
                        const match = cleanLine.match(pattern);
                        if (match && cleanLine.length > 3) {
                            return cleanLine;
                        }
                    }
                }
                
                return '';
            }







            /**
             * Optimized phone number extraction with multiple number handling
             */
            extractPhoneNumbers(text) {
                // Enhanced phone regex patterns
                const phonePatterns = [
                    // Standard formats (highest priority)
                    /(?:\+?91[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})/g,
                    /(?:\+?[0-9]{1,3}[-.\s]?)?\(?[0-9]{2,4}\)?[-.\s]?[0-9]{2,4}[-.\s]?[0-9]{2,4}[-.\s]?[0-9]{2,4}/g,
                    
                    // International formats
                    /\+[\d\s\-\(\)]{10,20}/g,
                    
                    // Special cases (lower priority)
                    /tel:([+\d\s\-\(\)]+)/gi,
                    /phone:([+\d\s\-\(\)]+)/gi,
                    /mobile:([+\d\s\-\(\)]+)/gi
                ];

                const foundNumbers = new Set();
                
                // Try each pattern in order of priority
                for (const pattern of phonePatterns) {
                    const matches = text.match(pattern);
                    if (matches) {
                        matches.forEach(num => {
                            // Clean the number
                            let cleanNum = num.replace(/[^\d+]/g, '');
                            
                            // Remove tel: or phone: prefixes if present
                            if (cleanNum.startsWith('tel') || cleanNum.startsWith('phone')) {
                                cleanNum = cleanNum.replace(/^[a-z]+/i, '');
                            }
                            
                            // Validate length (minimum 7 digits for local numbers, 10 for full numbers)
                            if ((cleanNum.startsWith('+') && cleanNum.length >= 8) || 
                                (!cleanNum.startsWith('+') && cleanNum.length >= 7)) {
                                foundNumbers.add(cleanNum);
                            }
                        });
                        
                        // If we found numbers with high confidence pattern, stop searching
                        if (foundNumbers.size > 0 && pattern === phonePatterns[0]) break;
                    }
                }

                // Convert to array and prioritize numbers
                const numbers = Array.from(foundNumbers);
                
                // Prioritization logic:
                // 1. Numbers with + prefix (international)
                // 2. Longer numbers (more likely to be complete)
                // 3. Numbers that appear earlier in the text
                numbers.sort((a, b) => {
                    const aIsIntl = a.startsWith('+');
                    const bIsIntl = b.startsWith('+');
                    
                    if (aIsIntl && !bIsIntl) return -1;
                    if (!aIsIntl && bIsIntl) return 1;
                    
                    if (a.length !== b.length) return b.length - a.length;
                    
                    return text.indexOf(a) - text.indexOf(b);
                });

                return numbers;
            }

            /**
             * Enhanced email extraction with multiple email handling
             */
            extractEmails(text) {
                // Multiple email patterns for better accuracy
                const emailPatterns = [
                    // Standard email pattern
                    /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g,
                    // Email with common prefixes
                    /(?:email|e-mail|mail|contact)[\s:]*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/gi,
                    // Email in parentheses or brackets
                    /[\(\[][^\)\]]*([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})[^\(\[\]]*[\)\]]/g
                ];
                
                const foundEmails = new Set();
                
                for (const pattern of emailPatterns) {
                    const matches = text.match(pattern);
                    if (matches && matches.length > 0) {
                        matches.forEach(email => {
                            // Clean up the email (remove prefixes, parentheses, etc.)
                            let cleanEmail = email;
                            
                            // Extract email from patterns with prefixes
                            if (pattern.source.includes('email|e-mail|mail|contact')) {
                                const emailMatch = email.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
                                if (emailMatch) cleanEmail = emailMatch[1];
                            }
                            
                            // Remove parentheses/brackets if present
                            cleanEmail = cleanEmail.replace(/[\(\)\[\]]/g, '');
                            
                            // Validate email format
                            if (this.isValidEmail(cleanEmail)) {
                                foundEmails.add(cleanEmail.toLowerCase());
                            }
                        });
                    }
                }
                
                // Convert to array and prioritize emails
                const emails = Array.from(foundEmails);
                
                // Prioritization logic:
                // 1. Personal emails (not business domains like noreply, info, etc.)
                // 2. Shorter emails (more likely to be personal)
                // 3. Emails that appear earlier in the text
                emails.sort((a, b) => {
                    const aIsPersonal = !a.includes('noreply') && !a.includes('info') && !a.includes('contact');
                    const bIsPersonal = !b.includes('noreply') && !b.includes('info') && !b.includes('contact');
                    
                    if (aIsPersonal && !bIsPersonal) return -1;
                    if (!aIsPersonal && bIsPersonal) return 1;
                    
                    if (a.length !== b.length) return a.length - b.length;
                    
                    return text.indexOf(a) - text.indexOf(b);
                });
                
                return emails;
            }

            /**
             * Enhanced name extraction considering surrounding context with name dataset validation
             */
            extractNameWithContext(text) {
                const nameExtractor = new EfficientNameExtractor();
                const nameResult = nameExtractor.extractName(text);
                
                // If we found a high confidence name, validate with dataset
                if (nameResult.confidence >= 7) {
                    const validatedName = this.validateNameWithDataset(nameResult.name);
                    if (validatedName) {
                        return validatedName;
                    }
                    return nameResult.name;
                }
                
                // Fallback to context-based extraction
                const lines = text.split('\n').filter(line => line.trim().length > 2);
                
                // Try to find name near email or phone
                const emails = this.extractEmails(text);
                const phones = this.extractPhoneNumbers(text);
                
                // If we have email or phone, look for name in nearby lines
                if (emails.length > 0 || phones.length > 0) {
                    const referencePoints = [...emails, ...phones];
                    
                    for (const point of referencePoints) {
                        const pointIndex = text.indexOf(point);
                        if (pointIndex === -1) continue;
                        
                        // Get the line containing the reference point
                        let lineIndex = 0;
                        let currentPos = 0;
                        for (let i = 0; i < lines.length; i++) {
                            currentPos += lines[i].length + 1; // +1 for newline
                            if (currentPos > pointIndex) {
                                lineIndex = i;
                                break;
                            }
                        }
                        
                        // Check previous lines for name
                        for (let i = Math.max(0, lineIndex - 2); i <= Math.min(lines.length - 1, lineIndex + 1); i++) {
                            const line = lines[i];
                            const check = nameExtractor.extractName(line);
                            if (check.confidence >= 5) {
                                const validatedName = this.validateNameWithDataset(check.name);
                                if (validatedName) {
                                    return validatedName;
                                }
                                return check.name;
                            }
                        }
                    }
                }
                
                // Final fallback to the best name we found (even if low confidence)
                if (nameResult.name) {
                    const validatedName = this.validateNameWithDataset(nameResult.name);
                    if (validatedName) {
                        return validatedName;
                    }
                }
                return nameResult.name || '';
            }

            /**
             * Validate and correct name using the name dataset
             */
            validateNameWithDataset(extractedName) {
                if (!extractedName || extractedName.length < 2) return null;
                
                // Clean the extracted name
                const cleanName = extractedName.trim().toLowerCase();
                const nameParts = cleanName.split(/\s+/);
                
                // Name dataset (common Indian names)
                const nameDataset = [
                    'aaban', 'aabharan', 'aabhas', 'aabhat', 'aabheer', 'aabir', 'aabishan', 'aacharya', 'aachman', 'aadarsh', 'aadarshan', 'aadavan', 'aadesh', 'aadhan', 'aadhar', 'aadhav', 'aadhi', 'aadhidev', 'aadhil', 'aadhiraj', 'aadhiran', 'aadhish', 'aadhishankar', 'aadhithan', 'aadhithya', 'aaditya', 'aadvay', 'aadvik', 'aadyant', 'aafiya', 'aafreen', 'aaftab', 'aagash', 'aahaan', 'aahan', 'aahil', 'aahlaad', 'aahnik', 'aahvan', 'aajeevan', 'aakaar', 'aakaash', 'aakarsh', 'aakash', 'aakashi', 'aakshat', 'aalam', 'aalan', 'aalap', 'aalok', 'aamil', 'aamir', 'aamish', 'aamod', 'aamodh', 'aanand', 'aanandit', 'aananth', 'aansh', 'aapt', 'aapu', 'aaqib', 'aaqil', 'aaradhak', 'aaran', 'aarav', 'aarif', 'aarish', 'aarit', 'aarnab', 'aarnav', 'aarsh', 'aarth', 'aaryan', 'aaryav', 'aashang', 'aashank', 'aashay', 'aashir', 'aashish', 'aashlesh', 'aashman', 'aashray', 'aashresh', 'aashrith', 'aashrut', 'aashu', 'aashutosh', 'aasif', 'aasim', 'aasit', 'aastha', 'aastik', 'aasvi', 'aathan', 'aathavan', 'aathees', 'aathijeyan', 'aathikan', 'aathipan', 'aathiran', 'aathish', 'aathith', 'aathithan', 'aathrav', 'aatif', 'aatish', 'aatma', 'aatmaj', 'aatman', 'aatmanand', 'aatmaram', 'aatmay', 'aatmik', 'aatrey', 'aatreya', 'aavansh', 'aavanyan', 'aavarthan', 'aaveg', 'aavesh', 'aavi', 'aavish', 'aayam', 'aayan', 'aayansh', 'aayu', 'aayush', 'aayudh', 'aayus', 'aayushmaan', 'aazim', 'abaan', 'abadhya', 'abay', 'abayan', 'abbas', 'abbhinav', 'abbir', 'abbott', 'abbud', 'abdul', 'abdullah', 'abdus', 'abed', 'abedin', 'abeer', 'abel', 'abenayan', 'abezag', 'abhaidev', 'abhaijeet', 'abharajithan', 'abhas', 'abhav', 'abhay', 'abhayan', 'abhayananda', 'abhayanankar', 'abheek', 'abheesht', 'abheet', 'abhey', 'abhibhava', 'abhicandra', 'abhidharm', 'abhidhi', 'abhigyaan', 'abhiijaat', 'abhijan', 'abhijat', 'abhijay', 'abhijaya', 'abhijeet', 'abhijit', 'abhijith', 'abhijun', 'abhik', 'abhikam', 'abhilash', 'abhilesh', 'abhim', 'abhiman', 'abhimand', 'abhimani', 'abhimanyu', 'abhimath', 'abhimoda', 'abhinabhas', 'abhinand', 'abhinanda', 'abhinandan', 'abhinandana', 'abhinash', 'abhinatha', 'abhinav', 'abhinava', 'abhinay', 'abhineet', 'abhinesh', 'abhinit', 'abhinivesh', 'abhinuj', 'abhipuj', 'abhir', 'abhiraam', 'abhiraj', 'abhiram', 'abhirath', 'abhiroop', 'abhirup', 'abhisar', 'abhisek', 'abhisheik', 'abhishek', 'abhishekita', 'abhishrey', 'abhisoka', 'abhisumat', 'abhisumath', 'abhisyanta', 'abhith', 'abhivaadan', 'abhivadan', 'abhivanth', 'abhivira', 'abhjeet', 'abhoy', 'abhra', 'abhrakasin', 'abhram', 'abhranila', 'abhu', 'abhya', 'abhyagni', 'abhyan', 'abhyank', 'abhypsit', 'abhyuday', 'abhyudaya', 'abhyudev', 'abhyudita', 'abid', 'abidin', 'abijith', 'abimanyu', 'abinash', 'abinav', 'abinay', 'abinayan', 'abinesh', 'abinish', 'abiram', 'abisali', 'abishek', 'abivanth', 'abjayoni', 'abjit', 'abner', 'abninayan', 'abra', 'abrad', 'abraham', 'abrar', 'abrash', 'abrik', 'abu', 'abul', 'acalapati', 'acalendra', 'acalesvara', 'acanda', 'acaryanandana', 'acaryasuta', 'acaryatanaya', 'acchindra', 'acchutan', 'achal', 'achalapati', 'achalendra', 'achalesvara', 'achalraj', 'achanda', 'achapal', 'acharya', 'acharyanandana', 'acharyasuta', 'achindra', 'achint', 'achintya', 'achuthan', 'achyut', 'achyuta', 'achyutam', 'achyutaraya', 'achyuth', 'achyuthan', 'acintya', 'acyutaraya', 'adalarachan', 'adalarasen', 'adalarasu', 'adam', 'adarsh', 'adavan', 'adbhutah', 'addison', 'adedev', 'adeel', 'adeela', 'adeem', 'adeep', 'adel', 'adenya', 'adesh', 'adeshwar', 'adham', 'adharsh', 'adharv', 'adhavan', 'adheer', 'adheesh', 'adhik', 'adhikara', 'adhinath', 'adhinav', 'adhip', 'adhipa', 'adhir', 'adhiraiyan', 'adhiraj', 'adhiratha', 'adhish', 'adhit', 'adhita', 'adhithya', 'adhitya', 'adhrit', 'adhrith', 'adhvait', 'adhvesh', 'adhvik', 'adhyan', 'adhyayan', 'adhyuth', 'adi', 'adib', 'adidev', 'adikavi', 'adikya', 'adil', 'adiman', 'adinath', 'adipurush', 'adipurusha', 'adisesh', 'adit', 'aditeya', 'adith', 'adithiya', 'adithya', 'aditiya', 'aditraj', 'aditya', 'adityaharicharan', 'adityakiran', 'adityanandan', 'adityanandana', 'adityavardhana', 'adiv', 'adiyaman', 'adler', 'adley', 'adlin', 'adnan', 'adotka', 'adrav', 'adrian', 'adrien', 'adrik', 'adripathi', 'adrish', 'adriyan', 'adrush', 'adtiya', 'advait', 'advaith', 'advay', 'advaya', 'advik', 'advit', 'adviteeya', 'advith', 'advitya', 'adwaid', 'adwait', 'adwaita', 'advaitha', 'adwaith', 'adway', 'adwaya', 'adwik', 'adwin', 'adyant', 'aedan', 'aiden', 'aekansh', 'aeshan', 'aeyush', 'afeef', 'aftab', 'aftaab', 'afzal', 'agam', 'agamiya', 'agampreet', 'aganit', 'aganveer', 'agarv', 'agarvin', 'agasthya', 'agasti', 'agathiyan', 'agavoli', 'agendra', 'agha', 'aghartha', 'aghat', 'aghor', 'aghornath', 'aghosh', 'agilan', 'agnello', 'agnes', 'agneya', 'aagneya', 'agnibahu', 'agnihotra', 'agnikumara', 'agnimitra', 'agniprava', 'agniras', 'agniv', 'agnivesh', 'agnivo', 'agraj', 'agrani', 'agrim', 'agrima', 'agriya', 'agustya', 'agyeya', 'ahaan', 'ahachcudar', 'ahad', 'ahaliyan', 'ahalyan', 'ahamathi', 'ahamynthan', 'ahan', 'ahanaeyan', 'ahankar', 'ahanyan', 'ahar', 'aharan', 'aharathan', 'aharihan', 'aharijan', 'aharshi', 'aharsi', 'ahaventhan', 'ahi', 'ahijit', 'ahil', 'ahilan', 'ahim', 'ahin', 'ahir', 'ahlad', 'ahmad', 'ahnay', 'ahren', 'ahrooran', 'ahruran', 'ahsan', 'ahti', 'aiden', 'aifa', 'aijaz', 'aiken', 'ail', 'aiman', 'ainesh', 'ainitosh', 'airaawat', 'airawat', 'eirawat', 'erawat', 'irawat', 'airavath', 'airawat', 'aishwa', 'aiyan', 'aiyappa', 'aiyyapa', 'ajaat', 'ajaatshatru', 'ajatshatru', 'ajah', 'ajahni', 'ajai', 'ajaipal', 'ajamil', 'ajan', 'ajanma', 'ajanthan', 'ajanya', 'ajat', 'ajatashatru', 'ajathasathru', 'ajatshatru', 'ajay', 'ajayan', 'ajeesh', 'ajeet', 'ajendra', 'ajesh', 'ajinkya', 'ajish', 'ajisth', 'ajit', 'ajitaabh', 'ajitabh', 'ajitesh', 'ajith', 'ajithabh', 'ajithesh', 'ajkhyat', 'ajmal', 'ajmil', 'ajneesh', 'ajoy', 'akal', 'akaldeep', 'akalin', 'akaljot', 'akalmash', 'akalnivas', 'akalpa', 'akalpreet', 'akalroop', 'akalsharan', 'akalsimar', 'akalsukh', 'akand', 'akansh', 'akanshit', 'akarsh', 'akash', 'akashdeep', 'akashini', 'akathiyan', 'akbar', 'akeem', 'akendra', 'akhalesh', 'akhand', 'akharsh', 'akhas', 'akhil', 'akhilash', 'akhilesh', 'akhileshwar', 'akhileswar', 'akhsaj', 'akhtar', 'akhurath', 'akhyath', 'akif', 'akil', 'akilan', 'akilesh', 'akira', 'akkamma', 'akkrum', 'akmal', 'akram', 'akaram', 'akrash', 'akrish', 'akrit', 'akroor', 'akruti', 'aksh', 'akshad', 'akshagna', 'akshahantre', 'akshaj', 'akshan', 'akshansh', 'akshant', 'akshar', 'aksharan', 'akshat', 'akshath', 'akshay', 'akshaya', 'akshayan', 'akshaykeerti', 'akshey', 'akshit', 'akshith', 'akshobhya', 'akshu', 'akshun', 'akshyan', 'akshyat', 'akul', 'ala', 'alaa', 'alaap', 'alabhya', 'alagan', 'alagappan', 'alagarasu', 'alagen', 'alaginiyan', 'alagiri', 'alahan', 'alakeshan', 'alakeshwaran', 'alakshendra', 'alamgir', 'alampata', 'alan', 'allan', 'alankar', 'alankrit', 'alarka', 'alastair', 'albern', 'albert', 'albion', 'alden', 'aldis', 'aldrich', 'alec', 'aleem', 'alek', 'alexander', 'alfie', 'alfred', 'algernon', 'alhad', 'alhasan', 'alhusain', 'alhusayn', 'ali', 'alice', 'alif', 'alin', 'alipta', 'allah', 'allaiyamuthan', 'allappariyan', 'alman', 'almir', 'alok', 'alok', 'aalok', 'aloke', 'alokendra', 'alolupan', 'alop', 'alpesh', 'alpha', 'alpit', 'alston', 'altaf', 'altair', 'alton', 'alvin', 'amaan', 'amaanat', 'amaar', 'amaay', 'amad', 'amadhya', 'amain', 'amaithipriyan', 'amaiyaran', 'amal', 'amalendu', 'amalesh', 'amam', 'aman', 'amanat', 'amanath', 'amanbir', 'amandeep', 'amandev', 'amaneesh', 'amanjeet', 'amanpal', 'amanpreet', 'amapramaadhy', 'amar', 'amaradhevan', 'amaran', 'amaranaath', 'amarnath', 'amaranayagan', 'amardeep', 'amardev', 'amarender', 'amarendra', 'amaresh', 'amarinder', 'amaris', 'amarjeet', 'amarjot', 'amarleen', 'amarnath', 'amarpreet', 'amarshayan', 'amarthevan', 'amartya', 'amav', 'amay', 'ambadi', 'ambak', 'ambalavan', 'ambar', 'ambareesh', 'ambarish', 'ambav', 'amber', 'amberish', 'ambesh', 'ambhoj', 'ambikanath', 'ambikapathi', 'ambikeya', 'ambili', 'ambrose', 'ambud', 'ambuj', 'ambujakshan', 'ambunath', 'ameer', 'ameet', 'amer', 'amery', 'amet', 'amey', 'ameyaatmaa', 'ameyatma', 'amid', 'amil', 'amildhiniyan', 'amileigh', 'amin', 'ameen', 'amir', 'amirathan', 'amirtha', 'amirtharasan', 'amish', 'amit', 'amitab', 'amitabh', 'amitaabh', 'amitabha', 'amitav', 'amitava', 'amitay', 'amitbikram', 'amitesh', 'amith', 'amithran', 'amitiyoti', 'amitrasudan', 'amiy', 'amjad', 'amlan', 'amlangusum', 'amod', 'amogh', 'amoghah', 'amoghraj', 'amol', 'amolak', 'amolik', 'amoorta', 'amos', 'ampulli', 'amrik', 'amrinder', 'amrish', 'amrit', 'amritambu', 'amritaya', 'amrith', 'amrithash', 'amritpal', 'amrut', 'amruth', 'amrutheswar', 'amsan', 'amshu', 'amshul', 'amshuman', 'amuda', 'amudan', 'amudhan', 'amuk', 'amul', 'amuthan', 'amuthiniyan', 'amuthithan', 'amzad', 'an', 'anaad', 'anaadhrushya', 'anaadi', 'anaadih', 'anaan', 'anaathi', 'anadh', 'anadhi', 'anadi', 'anagh', 'anahath', 'anak', 'anakh', 'anakul', 'anal', 'anam', 'anamay', 'anamaya', 'anami', 'anamitra', 'anan', 'ananay', 'anand', 'aanand', 'ananda', 'anandaganesh', 'anandamay', 'anandan', 'anandh', 'anandhamurugan', 'anandhan', 'anandhu', 'anandsagar', 'anang', 'ananinay', 'ananmay', 'ananmaya', 'anant', 'anantachidrupamayam', 'anantadrishti', 'anantaguna', 'anantajeet', 'anantajit', 'ananth', 'anant', 'ananthaa', 'ananthan', 'ananthu', 'anantim', 'anantram', 'anany', 'ananye', 'ananyo', 'anash', 'anashay', 'anashin', 'anashwar', 'anashya', 'anathikan', 'anav', 'anaye', 'anbaenthi', 'anbalagan', 'anbarasan', 'anbarasu', 'anbazhagan', 'anbu', 'anbuchelvan', 'anbumadi', 'anbuselvan', 'anbushelvan', 'anchit', 'andeep', 'andrew', 'aneek', 'aneeq', 'anees', 'aneesh', 'aneeth', 'anek', 'anesh', 'angad', 'angada', 'angadan', 'angaj', 'angak', 'angamuthu', 'angara', 'angaran', 'angayapriyan', 'angiras', 'angith', 'angleen', 'angus', 'anhar', 'anidev', 'aniesh', 'aniij', 'anik', 'anikait', 'anikanchan', 'anikant', 'aniket', 'aniketh', 'anikt', 'anil', 'anilaabh', 'anilabh', 'anilan', 'anilesh', 'animan', 'animash', 'animesh', 'anindith', 'anindo', 'anindya', 'aniq', 'anirban', 'aniroodh', 'aniruddh', 'aniruddha', 'aniruddhan', 'anirudh', 'anirudhha', 'anirudra', 'anirudu', 'aniruth', 'anirvan', 'anirved', 'anirvin', 'anirvinya', 'anis', 'anish', 'anishk', 'anishvar', 'aniswar', 'anit', 'aniteja', 'aniv', 'anivardh', 'anjaan', 'anjak', 'anjal', 'anjan', 'anjanappa', 'anjaneya', 'anjas', 'anjasa', 'anjay', 'anjesh', 'anjik', 'anjish', 'anjor', 'anjum', 'anjuman', 'ankal', 'ankesh', 'ankit', 'ankith', 'ankolit', 'ankur', 'ankush', 'anmay', 'anmesh', 'anmol', 'anna', 'annanathan', 'anniruddha', 'annsh', 'annuabhuj', 'annul', 'anokha', 'anoob', 'anoop', 'anoor', 'anosh', 'anoush', 'anpalagan', 'anpalahan', 'anpalakan', 'anpan', 'anpukiniyan', 'anram', 'ansal', 'ansel', 'ansh', 'anshaan', 'anshak', 'anshal', 'anshin', 'anshit', 'anshrith', 'anshu', 'anshuk', 'anshul', 'anshum', 'anshuman', 'anshumaan', 'anshumat', 'ansil', 'ansu', 'ansuman', 'antam', 'antar', 'antarang', 'antareeksh', 'antariksh', 'anthamaan', 'anthaman', 'anthikan', 'anthony', 'anthudaran', 'antim', 'antrix', 'anubhab', 'anubhaj', 'anubhav', 'anubodh', 'anuchan', 'anuchana', 'anudarshan', 'anudeep', 'anudev', 'anugrah', 'anugya', 'anuh', 'anuha', 'anuj', 'anukash', 'anukrit', 'anukul', 'anul', 'anumit', 'anumodith', 'anunay', 'anup', 'anupam', 'anupreet', 'anuprit', 'anuraag', 'anurag', 'anuraag', 'anuraj', 'anuritha', 'anurodh', 'anuroop', 'anurup', 'anuroop', 'anush', 'anushahan', 'anushan', 'anushivan', 'anuthaman', 'anutharshan', 'anutosh', 'anuttam', 'anuvindha', 'anuyog', 'anvay', 'anveer', 'anvesh', 'anveshan', 'anvit', 'anvith', 'anwar', 'anwesh', 'anwit', 'anyah', 'anyang', 'anzan', 'apar', 'aparajeet', 'aparajit', 'aparant', 'aparichit', 'apasyu', 'apij', 'apoorv', 'appaji', 'apparajito', 'appu', 'apsaran', 'apure', 'apurti', 'apurv', 'apurva', 'apoorva', 'ara', 'araahan', 'arab', 'aradhy', 'araha', 'arahan', 'arakhsan', 'aralan', 'aram', 'arambhi', 'aranab', 'aranamuthan', 'aranmakan', 'aranyak', 'araon', 'arasu', 'arav', 'aravali', 'aravan', 'aravin', 'aravind', 'aravindan', 'aravindhan', 'aravinth', 'arawo', 'archak', 'archan', 'archat', 'archer', 'archibald', 'archin', 'archish', 'archishman', 'archit', 'archith', 'archuna', 'ardashir', 'ardhendu', 'arean', 'areehah', 'areen', 'aref', 'arif', 'arekh', 'aresh', 'arganesh', 'argha', 'arghya', 'arha', 'arhaan', 'arhan', 'arhant', 'arhat', 'ariez', 'arihaan', 'arihan', 'arihant', 'ariharan', 'arijeet', 'arijit', 'arin', 'arindam', 'arindham', 'arine', 'arinjay', 'arinjoy', 'arish', 'arishwaran', 'arit', 'arivahan', 'arivalagan', 'arivali', 'arivarasan', 'arivarasu', 'arivoli', 'arivolli', 'arivozhi', 'arivuchelvan', 'arivukumaran', 'arivumadhi', 'arivumani', 'arivunambi', 'arivuselvan', 'arivuththamil', 'ariyan', 'arjan', 'arjav', 'arjeeth', 'arjit', 'arju', 'arjun', 'arjuna', 'arjunan', 'arjune', 'arjunna', 'arjunnan', 'arjunnen', 'ark', 'arka', 'arkaj', 'arkash', 'arkesh', 'arkin', 'arkish', 'arksh', 'arlen', 'arman', 'arnab', 'arnad', 'arnav', 'arnesh', 'arnik', 'arnish', 'arnit', 'arnoh', 'arnold', 'arnon', 'arnrit', 'aroha', 'arohan', 'aroop', 'aroush', 'arpan', 'arpil', 'arpit', 'arravind', 'arravinth', 'arsalan', 'arsha', 'arshad', 'arshan', 'artabandhu', 'artagnan', 'artatrana', 'arth', 'artham', 'arthav', 'arthikan', 'arthin', 'arthish', 'arthit', 'arthur', 'arudhra', 'aruj', 'arujas', 'arul', 'arulan', 'arulchelvan', 'arulganeshan', 'arulkumar', 'arulmozhiselvan', 'arulmozhivarman', 'arulnithi', 'arumai', 'arumbu', 'arumin', 'arumugam', 'arumugan', 'arumugathamudhu', 'arumughan', 'arumukhan', 'arun', 'arunabh', 'arunachaleshwara', 'arunageethayan', 'arunan', 'arunesh', 'arungedan', 'arunkannan', 'arunmozhithevan', 'arunmozhivarman', 'arunoday', 'arunothayan', 'arunthavan', 'aruran', 'arush', 'arushan', 'arushanan', 'aruth', 'arva', 'arvalan', 'arvel', 'arvin', 'arvind', 'arvinda', 'arvindswamy', 'ary', 'arya', 'aryaa', 'aryaan', 'aryadit', 'aryadita', 'aryamaan', 'aryaman', 'aryan', 'aryaraj', 'aryasb', 'aryash', 'aryav', 'aryavan', 'aryaveer', 'asad', 'asaja', 'asas', 'asav', 'aseelah', 'aseem', 'asees', 'asgar', 'ashakiran', 'ashan', 'ashank', 'ashankit', 'ashanko', 'ashcharya', 'asheem', 'ashesh', 'ashik', 'ashimat', 'ashirvad', 'ashis', 'ashish', 'ashit', 'ashith', 'ashitosh', 'ashkan', 'ashkaran', 'ashlesh', 'ashman', 'ashmik', 'ashmit', 'ashmith', 'ashneel', 'asho', 'ashok', 'ashokan', 'ashooja', 'ashpan', 'ashraf', 'asraf', 'ashrav', 'ashravya', 'ashray', 'ashrit', 'ashrith', 'ashrut', 'ashsri', 'ashtavakra', 'ashu', 'ashuthosh', 'ashutosh', 'aashutosh', 'ashva', 'ashvad', 'ashvanth', 'ashvarya', 'ashvat', 'ashvath', 'ashvik', 'ashvin', 'ashvind', 'ashwaghosh', 'ashwant', 'ashwanth', 'ashwarth', 'ashwath', 'ashwatham', 'ashwathama', 'ashwatthama', 'ashwathama', 'ashwesh', 'ashwin', 'ashwinraj', 'asidhan', 'asim', 'asish', 'asit', 'asitvaran', 'aslam', 'aslan', 'aslesh', 'aslun', 'aslunak', 'aslunit', 'asmit', 'asmith', 'asner', 'asok', 'asokan', 'asotosa', 'aashutosh', 'asrith', 'astik', 'astitva', 'astitya', 'astrit', 'asuman', 'asvin', 'aswanth', 'aswantha', 'aswapn', 'aswathaama', 'aswin', 'aswinikumar', 'atal', 'atambhu', 'atanu', 'atas', 'atash', 'ateeksh', 'ateet', 'atharav', 'atharv', 'atharva', 'atharvan', 'atheesh', 'athi', 'athiban', 'athighashen', 'athikaya', 'athikunan', 'athinarayanan', 'athiraiyan', 'athirayan', 'athish', 'athishan', 'athishay', 'athishen', 'athithan', 'athitya', 'athiyen', 'athrava', 'athreya', 'athrv', 'athul', 'athyajat', 'ati', 'atikish', 'atiksh', 'atim', 'atimanav', 'atin', 'atish', 'atishay', 'atit', 'atiya', 'atma', 'atmadeep', 'atmaj', 'atmajyothi', 'atmakanth', 'atman', 'atmanand', 'atmananda', 'atmaprakash', 'atmaram', 'atmik', 'atraiu', 'atralarasu', 'atreya', 'atri', 'atul', 'atultejas', 'atulya', 'atun', 'atvar', 'atvi', 'atwater', 'atwood', 'aubrey', 'audvik', 'augadh', 'auniket', 'aurel', 'austin', 'avadh', 'avadhesh', 'avadhoot', 'avalok', 'avan', 'avaneesh', 'avanish', 'avaneeth', 'avanesh', 'avanindra', 'avanish', 'avanithan', 'avaraj', 'avas', 'avashesh', 'avasyu', 'avatar', 'avaya', 'avdhoot', 'avdhut', 'aveekshith', 'aveen', 'avery', 'avhimanyu', 'avi', 'avichal', 'avigyan', 'avijit', 'avik', 'avikalp', 'avikam', 'avikrish', 'avikrut', 'avikshit', 'avilash', 'avin', 'avinash', 'avinay', 'avinesh', 'avingha', 'avir', 'aviraaj', 'aviraj', 'aviral', 'avirat', 'avirbhav', 'avirup', 'avish', 'avishkar', 'aviyukta', 'avkash', 'avneesh', 'avnendra', 'avnesh', 'avniel', 'avtar', 'avya', 'avyaansh', 'avyan', 'avyaya', 'avyayaprabhu', 'avyukt', 'avyukta', 'avyukth', 'awadhesh', 'awan', 'awas', 'awdhesh', 'awesh', 'axel', 'ayaan', 'ayaansh', 'ayan', 'ayank', 'ayansh', 'ayavanth', 'ayilyam', 'ayngaran', 'ayobaahu', 'ayodhya', 'ayog', 'ayub', 'ayudh', 'ayushmaan', 'ayushman', 'ayyan', 'ayyapan', 'ayyappa', 'ayyappadas', 'ayyappan', 'azad', 'azar', 'azeez', 'aziz', 'azhaar', 'azhagan', 'azhagar', 'azhagu', 'azhar'
                ];
                
                // Check if any part of the extracted name matches the dataset
                for (const namePart of nameParts) {
                    if (namePart.length < 2) continue;
                    
                    // Direct match
                    if (nameDataset.includes(namePart)) {
                        console.log(`Name validated with dataset: ${namePart} -> ${extractedName}`);
                        return extractedName;
                    }
                    
                    // Fuzzy match for common variations
                    const variations = this.generateNameVariations(namePart);
                    for (const variation of variations) {
                        if (nameDataset.includes(variation)) {
                            console.log(`Name corrected with dataset: ${namePart} -> ${variation}`);
                            return extractedName.replace(namePart, variation);
                        }
                    }
                }
                
                return null;
            }

            /**
             * Generate common name variations for fuzzy matching
             */
            generateNameVariations(name) {
                const variations = [];
                
                // Common spelling variations
                if (name.includes('aa')) variations.push(name.replace(/aa/g, 'a'));
                if (name.includes('a')) variations.push(name.replace(/a/g, 'aa'));
                if (name.includes('ee')) variations.push(name.replace(/ee/g, 'i'));
                if (name.includes('i')) variations.push(name.replace(/i/g, 'ee'));
                if (name.includes('oo')) variations.push(name.replace(/oo/g, 'u'));
                if (name.includes('u')) variations.push(name.replace(/u/g, 'oo'));
                
                // Common letter substitutions
                if (name.includes('c')) variations.push(name.replace(/c/g, 'k'));
                if (name.includes('k')) variations.push(name.push(name.replace(/k/g, 'c')));
                if (name.includes('ph')) variations.push(name.replace(/ph/g, 'f'));
                if (name.includes('f')) variations.push(name.replace(/f/g, 'ph'));
                
                // Remove common suffixes
                if (name.endsWith('an')) variations.push(name.slice(0, -2));
                if (name.endsWith('esh')) variations.push(name.slice(0, -3));
                if (name.endsWith('ish')) variations.push(name.slice(0, -3));
                
                return variations;
            }

            // EMAIL VALIDATION HELPER
            isValidEmail(email) {
                const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
                return emailRegex.test(email) && 
                       email.length >= 5 && 
                       email.length <= 254 &&
                       !email.includes('..') &&
                       !email.startsWith('.') &&
                       !email.endsWith('.');
            }

            // Enhanced OCR text extraction using the new optimized methods
            extractClientDataFromText(text) {
                console.log('Extracting client data from text:', text);
                const clientData = { name: '', email: '', phone: '', company: '', notes: '' };
                
                // Extract all possible emails and phones using optimized methods
                const allEmails = this.extractEmails(text);
                const allPhones = this.extractPhoneNumbers(text);
                
                // Select the best email and phone
                if (allEmails.length > 0) {
                    clientData.email = allEmails[0];
                    console.log('OCR found primary email:', clientData.email);
                    
                    // If we have multiple emails, add secondary to notes
                    if (allEmails.length > 1) {
                        clientData.notes = `Additional emails: ${allEmails.slice(1).join(', ')}`;
                        console.log('OCR found additional emails:', allEmails.slice(1));
                    }
                }
                
                if (allPhones.length > 0) {
                    clientData.phone = allPhones[0];
                    console.log('OCR found primary phone:', clientData.phone);
                    
                    // If we have multiple phones, add secondary to notes
                    if (allPhones.length > 1) {
                        const phoneNote = `Additional phones: ${allPhones.slice(1).join(', ')}`;
                        clientData.notes = clientData.notes 
                            ? `${clientData.notes}; ${phoneNote}`
                            : phoneNote;
                        console.log('OCR found additional phones:', allPhones.slice(1));
                    }
                }
                
                // Extract name with context awareness (lower threshold for OCR)
                const nameExtractor = new EfficientNameExtractor();
                const nameResult = nameExtractor.extractName(text);
                if (nameResult.name && nameResult.confidence >= 4) { // Lower threshold for OCR
                    clientData.name = nameResult.name;
                    console.log(`OCR name extraction: ${clientData.name} (confidence: ${nameResult.confidence})`);
                } else {
                    // Try context-based extraction for OCR
                    clientData.name = this.extractNameWithContext(text);
                    if (clientData.name) {
                        console.log('OCR found name with context:', clientData.name);
                    }
                }
                
                // Extract company (existing logic)
                const lines = text.split('\n').filter(line => line.trim().length > 2);
                const companyPatterns = [
                    /(.*?)\s+(Inc\.?|LLC|Corp\.?|Ltd\.?|Company|Co\.?|Corporation|Group|Solutions|Services|Technologies|Tech)(?!\w)/i,
                    /^[A-Z][a-zA-Z\s&]+(?:Inc\.?|LLC|Corp\.?|Ltd\.?)$/i
                ];
                
                for (const line of lines) {
                    const cleanLine = line.trim();
                    for (const pattern of companyPatterns) {
                        const match = cleanLine.match(pattern);
                        if (match && !clientData.company) {
                            clientData.company = match[0];
                            console.log('OCR found company:', clientData.company);
                            break;
                        }
                    }
                    if (clientData.company) break;
                }
                
                // If we have email but no name, try to extract name from email prefix
                if (clientData.email && !clientData.name) {
                    const emailPrefix = clientData.email.split('@')[0];
                    const nameFromEmail = emailPrefix
                        .replace(/[^a-zA-Z]/g, ' ')
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    if (nameFromEmail.split(' ').length <= 3) {
                        const nameCheck = nameExtractor.extractName(nameFromEmail);
                        if (nameCheck.confidence >= 3) { // Lower threshold for OCR
                            clientData.name = nameCheck.name;
                            console.log('OCR extracted name from email:', clientData.name);
                        }
                    }
                }
                
                console.log('Final extracted client data:', clientData);
                return clientData;
            }

            async analyzeImageWithOCR(imageData, source, storedImageData = null) {
                try {
                    console.log('Starting OCR analysis for source:', source);
                    this.showStatus('🔍 Performing text recognition...', 'info');
                    
                    // Use the enhanced OCR method
                    const clientData = await this.extractBusinessCardDataWithOCR(imageData);
                    
                    if (clientData && (clientData.email || clientData.name || clientData.phone)) {
                        console.log('Contact info found, adding client...');
                        // Add image data to client data
                        if (storedImageData) {
                            clientData.imageData = storedImageData;
                        } else {
                            clientData.imageData = imageData;
                        }
                        await this.addClientWithLinkedInSearch(clientData, source);
                    } else {
                        console.log('No contact info found in OCR text');
                        this.showStatus('❌ No contact information found in the image. Please try manual entry.', 'error');
                    }
                } catch (error) {
                    console.error('OCR processing failed:', error);
                    this.showStatus('❌ OCR processing failed: ' + error.message, 'error');
                }
            }

            async addClientWithLinkedInSearch(clientData, source) {
                console.log('Adding client with data:', clientData, 'Source:', source);
                
                if (clientData.name) {
                    this.showStatus('🔍 Searching for LinkedIn profile...', 'info');
                    clientData.linkedIn = await this.findLinkedInProfile(clientData.name, clientData.company);
                }
                
                this.addClient({...clientData, source});
                this.showStatus(`✅ Client data extracted and added successfully! Source: ${source}`, 'success');
                console.log('Client added successfully');
            }

            async findLinkedInProfile(name, company = '') {
                try {
                    // Create LinkedIn search URL
                    const searchQuery = `${name} ${company}`.trim().replace(/\s+/g, '+');
                    const linkedInSearchURL = `https://www.linkedin.com/search/results/people/?keywords=${encodeURIComponent(searchQuery)}`;
                    
                    return linkedInSearchURL;
                } catch (error) {
                    console.log('LinkedIn search failed:', error);
                    return '';
                }
            }

            searchLinkedIn() {
                const name = document.getElementById('manualName').value;
                const company = document.getElementById('manualCompany').value;
                
                if (!name.trim()) {
                    this.showStatus('❌ Please enter a name to search LinkedIn', 'error');
                    return;
                }
                
                const searchQuery = `${name} ${company}`.trim().replace(/\s+/g, '+');
                const linkedInURL = `https://www.linkedin.com/search/results/people/?keywords=${encodeURIComponent(searchQuery)}`;
                
                document.getElementById('manualLinkedIn').value = linkedInURL;
                this.showStatus('🔗 LinkedIn search URL generated!', 'success');
                
                // Open LinkedIn search in new tab
                window.open(linkedInURL, '_blank');
            }

            handleManualEntry(event) {
                event.preventDefault();
                
                const clientData = {
                    name: document.getElementById('manualName').value.trim(),
                    email: document.getElementById('manualEmail').value.trim(),
                    phone: document.getElementById('manualPhone').value.trim(),
                    company: document.getElementById('manualCompany').value.trim(),
                    linkedIn: document.getElementById('manualLinkedIn').value.trim(),
                    category: document.getElementById('manualCategory').value.trim(),
                    notes: document.getElementById('manualNotes').value.trim(),
                    source: 'Manual Entry'
                };
                
                if (!clientData.name && !clientData.email && !clientData.phone) {
                    this.showStatus('❌ Please fill in at least name, email, or phone number', 'error');
                    return;
                }
                
                // Validate email format
                if (clientData.email && !this.isValidEmail(clientData.email)) {
                    this.showStatus('❌ Please enter a valid email address', 'error');
                    return;
                }
                
                this.addClient(clientData);
                this.showStatus('✅ Client added successfully via manual entry!', 'success');
                
                // Clear form
                document.getElementById('manualForm').reset();
            }

            isValidEmail(email) {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                return emailRegex.test(email);
            }

            addClient(clientData) {
    // Validate the client data
    if (!this.validateClientData(clientData)) {
        console.error('Invalid client data:', clientData);
        this.showStatus('❌ Invalid client data - not saved', 'error');
        return;
    }

    const client = {
        id: Date.now(),
        ...clientData,
        timestamp: new Date().toLocaleString(),
        imageData: clientData.imageData || null,
        notes: clientData.notes || ''
    };
    
    this.clients.push(client);
    this.saveClients();
    this.updateClientStats();
    
    console.log('Client added:', client);
    this.showStatus(`✅ Client ${client.name || ''} added successfully!`, 'success');
}
            updateClientStats() {
                const stats = document.getElementById('clientStats');
                if (!stats) {
                    console.warn('Client stats element not found');
                    return;
                }
                
                // Update stats
                const qrCount = this.clients.filter(c => c.source.toLowerCase().includes('qr')).length;
                const ocrCount = this.clients.filter(c => c.source.toLowerCase().includes('ocr')).length;
                const manualCount = this.clients.filter(c => c.source === 'Manual Entry').length;
                
                stats.innerHTML = `
                    📊 Total: ${this.clients.length} | 
                    📱 QR: ${qrCount} | 
                    🤖 OCR: ${ocrCount} | 
                    ✍️ Manual: ${manualCount}
                `;
            }

            exportToCSV() {
                if (this.clients.length === 0) {
                    this.showStatus('❌ No data to export', 'error');
                    return;
                }
                
                const headers = ['Name', 'Email', 'Phone', 'Company', 'Category', 'LinkedIn', 'Notes', 'Source', 'Timestamp'];
                const csvContent = [
                    headers.join(','),
                    ...this.clients.map(client => [
                        `"${(client.name || '').replace(/"/g, '""')}"`,
                        `"${(client.email || '').replace(/"/g, '""')}"`,
                        `"${(client.phone || '').replace(/"/g, '""')}"`,
                        `"${(client.company || '').replace(/"/g, '""')}"`,
                        `"${(client.category ? `Option ${client.category}` : '').replace(/"/g, '""')}"`,
                        `"${(client.linkedIn || '').replace(/"/g, '""')}"`,
                        `"${(client.notes || '').replace(/"/g, '""')}"`,
                        `"${client.source.replace(/"/g, '""')}"`,
                        `"${client.timestamp.replace(/"/g, '""')}"`
                    ].join(','))
                ].join('\n');
                
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `exhibition-clients-${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                this.showStatus('📊 Data exported successfully!', 'success');
            }

            async exportToPDF() {
                if (this.clients.length === 0) {
                    this.showStatus('❌ No data to export', 'error');
                    return;
                }

                this.showStatus('📄 Generating PDF...', 'info');

                try {
                    // Create PDF using jsPDF
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();
                    
                    // Set up PDF content
                    const title = 'Exhibition Card Reader Pro - Client Data';
                    const date = new Date().toLocaleDateString();
                    const totalClients = this.clients.length;
                    
                    // Add title
                    doc.setFontSize(20);
                    doc.setFont(undefined, 'bold');
                    doc.text(title, 20, 20);
                    
                    // Add date and total
                    doc.setFontSize(12);
                    doc.setFont(undefined, 'normal');
                    doc.text(`Generated on: ${date}`, 20, 35);
                    doc.text(`Total Clients: ${totalClients}`, 20, 45);
                    
                    // Add statistics
                    const qrCount = this.clients.filter(c => c.source.toLowerCase().includes('qr')).length;
                    const ocrCount = this.clients.filter(c => c.source.toLowerCase().includes('ocr')).length;
                    const manualCount = this.clients.filter(c => c.source === 'Manual Entry').length;
                    
                    doc.text('Statistics:', 20, 60);
                    doc.text(`- QR Code Scans: ${qrCount}`, 25, 70);
                    doc.text(`- OCR Scans: ${ocrCount}`, 25, 80);
                    doc.text(`- Manual Entries: ${manualCount}`, 25, 90);
                    
                    // Add client data
                    let yPosition = 110;
                    doc.setFontSize(14);
                    doc.setFont(undefined, 'bold');
                    doc.text('Client Details:', 20, yPosition);
                    yPosition += 10;
                    
                    doc.setFontSize(10);
                    doc.setFont(undefined, 'normal');
                    
                    // Process clients sequentially to handle async image loading
                    for (let index = 0; index < this.clients.length; index++) {
                        const client = this.clients[index];
                        
                        // Check if we need a new page
                        if (yPosition > 250) {
                            doc.addPage();
                            yPosition = 20;
                        }
                        
                        doc.setFont(undefined, 'bold');
                        doc.text(`${index + 1}. ${client.name || 'N/A'}`, 20, yPosition);
                        yPosition += 7;
                        
                        doc.setFont(undefined, 'normal');
                        doc.text(`Email: ${client.email || 'N/A'}`, 25, yPosition);
                        yPosition += 5;
                        doc.text(`Phone: ${client.phone || 'N/A'}`, 25, yPosition);
                        yPosition += 5;
                        doc.text(`Company: ${client.company || 'N/A'}`, 25, yPosition);
                        yPosition += 5;
                        doc.text(`Category: ${client.category ? `Option ${client.category}` : 'N/A'}`, 25, yPosition);
                        yPosition += 5;
                        doc.text(`LinkedIn: ${client.linkedIn || 'N/A'}`, 25, yPosition);
                        yPosition += 5;
                        if (client.notes) {
                            doc.text(`Notes: ${client.notes}`, 25, yPosition);
                            yPosition += 5;
                        }
                        doc.text(`Source: ${client.source}`, 25, yPosition);
                        yPosition += 5;
                        doc.text(`Added: ${client.timestamp}`, 25, yPosition);
                        
                        // Add image if available
                     
                        
                        yPosition += 15;
                    }
                    
                    // Save the PDF
                    const filename = `exhibition-clients-${new Date().toISOString().split('T')[0]}.pdf`;
                    doc.save(filename);
                    
                    this.showStatus('📄 PDF exported successfully!', 'success');
                    
                } catch (error) {
                    console.error('PDF generation error:', error);
                    this.showStatus('❌ PDF generation failed. Please try again.', 'error');
                }
            }



            viewSavedData() {
                // Open saved data page in new tab
                window.open('saved_data.html', '_blank');
            }

            deleteClient(index) {
                if (index < 0 || index >= this.clients.length) {
                    this.showStatus('❌ Invalid client index', 'error');
                    return;
                }

                const client = this.clients[index];
                const confirmDelete = confirm(`Are you sure you want to delete ${client.name || 'this client'}?`);
                
                if (confirmDelete) {
                    this.clients.splice(index, 1);
                    this.saveClients();
                    this.updateClientStats();
                    this.showStatus(`🗑️ Deleted client: ${client.name || 'Unknown'}`, 'success');
                }
            }

            clearAllData() {
                if (this.clients.length === 0) {
                    this.showStatus('❌ No data to clear', 'error');
                    return;
                }
                
                if (confirm(`🗑️ Are you sure you want to clear all ${this.clients.length} client records? This action cannot be undone.`)) {
                    this.clients = [];
                    this.saveClients();
                    this.updateClientStats();
                    this.showStatus('🗑️ All client data cleared', 'info');
                }
            }



            getClients() {
                return this.clients;
            }

            loadClients() {
                try {
                    const stored = localStorage.getItem('exhibitionCardReaderClients');
                    return stored ? JSON.parse(stored) : [];
                } catch (error) {
                    console.error('Error loading clients:', error);
                    return [];
                }
            }

            saveClients() {
                try {
                    localStorage.setItem('exhibitionCardReaderClients', JSON.stringify(this.clients));
                    console.log('Clients saved to localStorage:', this.clients.length);
                } catch (error) {
                    console.error('Error saving clients:', error);
                }
            }

            showStatus(message, type) {
                const statusEl = document.getElementById('statusMessage');
                statusEl.innerHTML = `<div class="status-message ${type}">${message}</div>`;
                
                // Auto-hide success and info messages after 5 seconds
                if (type === 'success' || type === 'info') {
                    setTimeout(() => {
                        if (statusEl.innerHTML.includes(message)) {
                            statusEl.innerHTML = '';
                        }
                    }, 5000);
                }
            }

            showProcessing(show) {
                document.getElementById('processing').style.display = show ? 'block' : 'none';
            }


            






            /**
             * Render the current image with all applied effects
             */
            renderImage() {
                if (!this.currentImage) return;

                const canvas = this.editorCanvas;
                const ctx = this.editorCtx;
                
                // Calculate dimensions to fit in canvas while maintaining aspect ratio
                const maxWidth = 600;
                const maxHeight = 400;
                const scale = Math.min(maxWidth / this.currentImage.width, maxHeight / this.currentImage.height);
                
                canvas.width = this.currentImage.width * scale;
                canvas.height = this.currentImage.height * scale;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Apply rotation
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate((this.rotation * Math.PI) / 180);
                
                // Apply brightness filter
                if (this.brightness !== 0) {
                    ctx.filter = `brightness(${100 + parseInt(this.brightness)}%)`;
                }
                
                // Draw image
                ctx.drawImage(
                    this.currentImage,
                    -canvas.width / 2,
                    -canvas.height / 2,
                    canvas.width,
                    canvas.height
                );
                
                ctx.restore();
            }



            /**
             * Adjust brightness
             */
            adjustBrightness(value) {
                this.brightness = parseInt(value);
                document.getElementById('brightnessValue').textContent = this.brightness + '%';
                this.renderImage();
            }

            /**
             * Rotate image
             */
            rotateImage(degrees) {
                this.rotation += degrees;
                this.renderImage();
                this.showStatus(`🔄 Image rotated ${degrees > 0 ? '+' : ''}${degrees}°`, 'info');
            }

            /**
             * Reset rotation
             */
            resetRotation() {
                this.rotation = 0;
                this.renderImage();
                this.showStatus('🔄 Rotation reset', 'info');
            }

            /**
             * Reset all editor changes
             */
            resetEditor() {
                this.currentImage = this.originalImage;
                this.rotation = 0;
                this.brightness = 0;
                
                // Reset UI
                document.getElementById('brightnessSlider').value = 0;
                document.getElementById('brightnessValue').textContent = '0%';
                
                this.renderImage();
                this.showStatus('🔄 Editor reset to original image', 'info');
            }

            /**
             * Process the edited image
             */
            async processEditedImage() {
                if (!this.currentImage) {
                    this.showStatus('❌ No image to process', 'error');
                    return;
                }
                
                this.showStatus('🔍 Processing edited image...', 'info');
                
                // Convert canvas to blob
                const canvas = this.editorCanvas;
                canvas.toBlob(async (blob) => {
                    if (blob) {
                        try {
                            console.log('Processing edited image blob:', blob.size, 'bytes');
                            
                            // Try QR scan first
                            let qrText = null;
                            try {
                                const html5QrCodeFile = new Html5Qrcode();
                                qrText = await html5QrCodeFile.scanFile(blob, true);
                                console.log('QR scan result:', qrText);
                            } catch (qrError) {
                                console.log('QR scan failed, trying OCR:', qrError);
                                // QR scan failed, continue to OCR
                            }
                            
                            if (qrText) {
                                console.log('QR code found, processing...');
                                const contactFound = await this.processQRResult(qrText, 'Edited Image QR');
                                if (!contactFound) {
                                    // QR found but no contact info, run OCR
                                    console.log('QR found but no contact info, running OCR...');
                                    await this.analyzeImageWithOCR(canvas.toDataURL(), 'Edited Image OCR');
                                }
                            } else {
                                // No QR found, run OCR
                                console.log('No QR found, running OCR...');
                                this.showStatus('🔄 No QR found, running OCR on edited image...', 'info');
                                await this.analyzeImageWithOCR(canvas.toDataURL(), 'Edited Image OCR');
                            }
                            
                            // Hide editor after processing
                            this.hideImageEditor();
                            
                        } catch (error) {
                            console.error('Error processing edited image:', error);
                            this.showStatus('❌ Error processing edited image: ' + error.message, 'error');
                        }
                    } else {
                        this.showStatus('❌ Failed to create image from editor', 'error');
                    }
                }, 'image/jpeg', 0.9);
            }

            /**
             * Test method for debugging process image functionality
             */
            async testProcessImage() {
                console.log('Test process image called');
                this.showStatus('🧪 Testing process image functionality...', 'info');
                
                if (!this.currentImage) {
                    this.showStatus('❌ No image loaded for testing', 'error');
                    return;
                }
                
                try {
                    // Test with a simple OCR first
                    const canvas = this.editorCanvas;
                    const imageDataUrl = canvas.toDataURL('image/jpeg', 0.9);
                    
                    console.log('Testing with image data URL:', imageDataUrl.substring(0, 100) + '...');
                    
                    // Test OCR directly
                    await this.analyzeImageWithOCR(imageDataUrl, 'Test Process');
                    
                } catch (error) {
                    console.error('Test process failed:', error);
                    this.showStatus('❌ Test process failed: ' + error.message, 'error');
                }
            }

            editClient(index) {
                const client = this.clients[index];
                if (!client) return;
                
                // Create and show edit modal with better styling
                const modal = document.createElement('div');
                modal.className = 'edit-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 9999;
                    backdrop-filter: blur(5px);
                `;
                
                modal.innerHTML = `
                    <div class="edit-modal-content" style="
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        border-radius: 20px;
                        padding: 0;
                        width: 90%;
                        max-width: 500px;
                        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                        border: 2px solid rgba(255,255,255,0.1);
                        backdrop-filter: blur(10px);
                    ">
                        <div style="
                            background: rgba(255,255,255,0.1);
                            padding: 25px 30px;
                            border-radius: 18px 18px 0 0;
                            border-bottom: 1px solid rgba(255,255,255,0.2);
                        ">
                            <h3 style="
                                color: white;
                                margin: 0;
                                font-size: 1.5rem;
                                font-weight: 600;
                                display: flex;
                                align-items: center;
                                gap: 10px;
                            ">
                                ✏️ Edit Client
                            </h3>
                        </div>
                        
                        <div style="padding: 30px;">
                            <form id="editClientForm">
                                <div style="margin-bottom: 20px;">
                                    <label style="
                                        color: white;
                                        font-weight: 600;
                                        margin-bottom: 8px;
                                        display: block;
                                        font-size: 0.9rem;
                                    ">👤 Name *</label>
                                    <input type="text" class="edit-input" id="editName" value="${client.name || ''}" required style="
                                        width: 100%;
                                        padding: 12px 15px;
                                        border: 2px solid rgba(255,255,255,0.2);
                                        border-radius: 10px;
                                        background: rgba(255,255,255,0.1);
                                        color: white;
                                        font-size: 1rem;
                                        transition: all 0.3s ease;
                                    " placeholder="Enter full name">
                                </div>
                                
                                <div style="margin-bottom: 20px;">
                                    <label style="
                                        color: white;
                                        font-weight: 600;
                                        margin-bottom: 8px;
                                        display: block;
                                        font-size: 0.9rem;
                                    ">📧 Email</label>
                                    <input type="email" class="edit-input" id="editEmail" value="${client.email || ''}" style="
                                        width: 100%;
                                        padding: 12px 15px;
                                        border: 2px solid rgba(255,255,255,0.2);
                                        border-radius: 10px;
                                        background: rgba(255,255,255,0.1);
                                        color: white;
                                        font-size: 1rem;
                                        transition: all 0.3s ease;
                                    " placeholder="Enter email address">
                                </div>
                                
                                <div style="margin-bottom: 20px;">
                                    <label style="
                                        color: white;
                                        font-weight: 600;
                                        margin-bottom: 8px;
                                        display: block;
                                        font-size: 0.9rem;
                                    ">📞 Phone</label>
                                    <input type="tel" class="edit-input" id="editPhone" value="${client.phone || ''}" style="
                                        width: 100%;
                                        padding: 12px 15px;
                                        border: 2px solid rgba(255,255,255,0.2);
                                        border-radius: 10px;
                                        background: rgba(255,255,255,0.1);
                                        color: white;
                                        font-size: 1rem;
                                        transition: all 0.3s ease;
                                    " placeholder="Enter phone number">
                                </div>
                                
                                <div style="margin-bottom: 20px;">
                                    <label style="
                                        color: white;
                                        font-weight: 600;
                                        margin-bottom: 8px;
                                        display: block;
                                        font-size: 0.9rem;
                                    ">🏢 Company</label>
                                    <input type="text" class="edit-input" id="editCompany" value="${client.company || ''}" style="
                                        width: 100%;
                                        padding: 12px 15px;
                                        border: 2px solid rgba(255,255,255,0.2);
                                        border-radius: 10px;
                                        background: rgba(255,255,255,0.1);
                                        color: white;
                                        font-size: 1rem;
                                        transition: all 0.3s ease;
                                    " placeholder="Enter company name">
                                </div>
                                
                                <div style="margin-bottom: 20px;">
                                    <label style="
                                        color: white;
                                        font-weight: 600;
                                        margin-bottom: 8px;
                                        display: block;
                                        font-size: 0.9rem;
                                    ">🔗 LinkedIn</label>
                                    <input type="url" class="edit-input" id="editLinkedin" value="${client.linkedIn || ''}" style="
                                        width: 100%;
                                        padding: 12px 15px;
                                        border: 2px solid rgba(255,255,255,0.2);
                                        border-radius: 10px;
                                        background: rgba(255,255,255,0.1);
                                        color: white;
                                        font-size: 1rem;
                                        transition: all 0.3s ease;
                                    " placeholder="Enter LinkedIn URL">
                                </div>
                                
                                <div style="margin-bottom: 25px;">
                                    <label style="
                                        color: white;
                                        font-weight: 600;
                                        margin-bottom: 8px;
                                        display: block;
                                        font-size: 0.9rem;
                                    ">📂 Category</label>
                                    <select class="edit-input category-select" id="editCategory" style="
                                        width: 100%;
                                        padding: 12px 15px;
                                        border: 2px solid rgba(255,255,255,0.2);
                                        border-radius: 10px;
                                        background: rgba(255,255,255,0.1);
                                        color: white;
                                        font-size: 1rem;
                                        transition: all 0.3s ease;
                                    ">
                                        <option value="">Select Category</option>
                                        <option value="1" ${client.category === '1' ? 'selected' : ''}>Option 1</option>
                                        <option value="2" ${client.category === '2' ? 'selected' : ''}>Option 2</option>
                                        <option value="3" ${client.category === '3' ? 'selected' : ''}>Option 3</option>
                                        <option value="4" ${client.category === '4' ? 'selected' : ''}>Option 4</option>
                                    </select>
                                </div>
                            </form>
                        </div>
                        
                        <div style="
                            padding: 20px 30px 30px;
                            display: flex;
                            gap: 15px;
                            justify-content: flex-end;
                        ">
                            <button type="button" class="edit-cancel-btn" onclick="this.closest('.edit-modal').remove()" style="
                                padding: 12px 25px;
                                border: 2px solid rgba(255,255,255,0.3);
                                border-radius: 10px;
                                background: rgba(255,255,255,0.1);
                                color: white;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                font-size: 0.9rem;
                            ">❌ Cancel</button>
                            <button type="button" class="edit-update-btn" style="
                                padding: 12px 25px;
                                border: none;
                                border-radius: 10px;
                                background: linear-gradient(135deg, #00c851, #007e33);
                                color: white;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.3s ease;
                                font-size: 0.9rem;
                                box-shadow: 0 4px 15px rgba(0,200,81,0.3);
                            ">✅ Update Client</button>
                            <button type="button" class="update-btn" data-index="${index}" style="display: none;"></button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Add hover effects for inputs
                const inputs = modal.querySelectorAll('.edit-input');
                inputs.forEach(input => {
                    input.addEventListener('focus', () => {
                        input.style.borderColor = 'rgba(255,255,255,0.5)';
                        input.style.background = 'rgba(255,255,255,0.15)';
                    });
                    input.addEventListener('blur', () => {
                        input.style.borderColor = 'rgba(255,255,255,0.2)';
                        input.style.background = 'rgba(255,255,255,0.1)';
                    });
                });
                
                // Add hover effects for buttons
                const cancelBtn = modal.querySelector('.edit-cancel-btn');
                const updateBtn = modal.querySelector('.edit-update-btn');
                const hiddenUpdateBtn = modal.querySelector('.update-btn');
                
                // Add click event for update button
                updateBtn.addEventListener('click', () => {
                    const index = parseInt(hiddenUpdateBtn.dataset.index);
                    console.log('Update button clicked for index:', index);
                    this.updateClient(index);
                });
                
                cancelBtn.addEventListener('mouseenter', () => {
                    cancelBtn.style.background = 'rgba(255,255,255,0.2)';
                    cancelBtn.style.borderColor = 'rgba(255,255,255,0.5)';
                });
                cancelBtn.addEventListener('mouseleave', () => {
                    cancelBtn.style.background = 'rgba(255,255,255,0.1)';
                    cancelBtn.style.borderColor = 'rgba(255,255,255,0.3)';
                });
                
                updateBtn.addEventListener('mouseenter', () => {
                    updateBtn.style.transform = 'translateY(-2px)';
                    updateBtn.style.boxShadow = '0 6px 20px rgba(0,200,81,0.4)';
                });
                updateBtn.addEventListener('mouseleave', () => {
                    updateBtn.style.transform = 'translateY(0)';
                    updateBtn.style.boxShadow = '0 4px 15px rgba(0,200,81,0.3)';
                });
                
                // Focus on first input
                setTimeout(() => {
                    document.getElementById('editName').focus();
                }, 100);
                
                // Close modal when clicking outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }
            
            updateClient(index) {
                const name = document.getElementById('editName').value.trim();
                const email = document.getElementById('editEmail').value.trim();
                const phone = document.getElementById('editPhone').value.trim();
                const company = document.getElementById('editCompany').value.trim();
                const linkedin = document.getElementById('editLinkedin').value.trim();
                const category = document.getElementById('editCategory').value.trim();
                
                if (!name) {
                    alert('Name is required!');
                    return;
                }
                
                // Update client data with all existing fields preserved
                const updatedClient = {
                    ...this.clients[index], // Preserve existing fields like source, timestamp, etc.
                    name: name,
                    email: email,
                    phone: phone,
                    company: company,
                    linkedIn: linkedin,
                    category: category
                };
                
                // Update the client in the array
                this.clients[index] = updatedClient;
                
                // Save to localStorage
                this.saveClients();
                
                // Update display
                this.updateClientStats();
                
                // Close modal
                document.querySelector('.modal').remove();
                
                // Show success message
                this.showStatus('✅ Client updated successfully!', 'success');
                
                console.log('Client updated:', updatedClient);
            }


        }

        // Cleanup function for camera
        function cleanupCamera() {
            if (window.app && window.app.html5QrCode && window.app.cameraStarted) {
                window.app.stopCamera();
            }
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            try {
                // Check if required elements exist before initializing
                const requiredElements = [
                    'startCamera', 'captureImage', 'restartCamera', 'fileInput', 
                    'manualForm', 'searchLinkedIn', 'exportData', 'exportPDF', 
                    'viewSavedData', 'clearData', 'qrModeBtn', 
                    'imageModeBtn', 'uploadArea', 'qr-reader'
                ];
                
                const missingElements = requiredElements.filter(id => !document.getElementById(id));
                if (missingElements.length > 0) {
                    console.warn('Missing elements:', missingElements);
                }
                
                window.app = new ExhibitionCardReaderPro();
                console.log('🚀 Exhibition Card Reader Pro initialized successfully!');
            } catch (error) {
                console.error('❌ Error initializing application:', error);
                document.body.innerHTML = `
                    <div style="text-align: center; padding: 50px; color: white;">
                        <h1>❌ Application Error</h1>
                        <p>Failed to initialize the card reader. Please refresh the page.</p>
                        <p style="font-size: 0.9rem; opacity: 0.8;">Error: ${error.message}</p>
                        <button onclick="location.reload()" style="
                            background: linear-gradient(135deg, #667eea, #764ba2);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            border-radius: 25px;
                            cursor: pointer;
                            font-size: 1rem;
                            margin-top: 20px;
                        ">🔄 Refresh Page</button>
                    </div>
                `;
            }
        });

        // Add cleanup on page unload
        window.addEventListener('beforeunload', cleanupCamera);
        window.addEventListener('pagehide', cleanupCamera);

        // Add some helpful keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        document.getElementById('startCamera').click();
                        break;
                    case 'e':
                        e.preventDefault();
                        document.getElementById('exportData').click();
                        break;
                }
            }
        });
    </script>
    

</body>
</html>